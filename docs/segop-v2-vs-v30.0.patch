diff --git a/segop_send.sh b/segop_send.sh
new file mode 100755
index 0000000000..fb1c40038f
--- /dev/null
+++ b/segop_send.sh
@@ -0,0 +1,104 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+# segop_send.sh
+#
+# Usage:
+#   ./segop_send.sh <wallet> <dest_address> <amount_btc> <payload_hex> [mine]
+#
+# Example:
+#   ./segop_send.sh segoptest bcrt1qm7nmrglev9qt0fqvk8df9e7qjvdmvmgeectxhu 0.1 01020304 mine
+#
+# If the last argument is "mine", the script will:
+#   - generate 1 block to a new regtest address
+#   - fetch the confirmed transaction with getrawtransaction (verbose=1, with blockhash)
+
+DATADIR="/root/segop-data"
+CLI_BASE="/root/bitcoin-segop/build/bin/bitcoin-cli -regtest -datadir=${DATADIR}"
+
+if ! command -v jq >/dev/null 2>&1; then
+  echo "ERROR: jq is required (apt install jq)" >&2
+  exit 1
+fi
+
+if [ $# -lt 4 ]; then
+  echo "Usage: $0 <wallet> <dest_address> <amount_btc> <payload_hex> [mine]"
+  exit 1
+fi
+
+WALLET="$1"
+DEST="$2"
+AMOUNT="$3"
+PAYLOAD_HEX="$4"
+MINE="${5:-}"
+
+CLI="${CLI_BASE} -rpcwallet=${WALLET}"
+
+echo "[0] Checking wallet: ${WALLET}"
+if ! $CLI getwalletinfo >/dev/null 2>&1; then
+  echo "    Wallet not loaded, attempting loadwallet..."
+  $CLI_BASE loadwallet "$WALLET" >/dev/null
+  echo "    Wallet loaded."
+fi
+
+echo "[0] Wallet info:"
+$CLI getwalletinfo | jq '{name, balance, txcount}'
+
+echo "[1] Building P2SOP commitment for payload: ${PAYLOAD_HEX}"
+COMMIT_JSON=$($CLI segopbuildp2sop "$PAYLOAD_HEX")
+P2SOP_DATA=$(echo "$COMMIT_JSON" | jq -r '.data')
+echo "    P2SOP_DATA = $P2SOP_DATA"
+
+echo "[2] Creating base transaction (dest=${DEST}, amount=${AMOUNT})..."
+RAW_BASE=$($CLI createrawtransaction "[]" \
+  "[{\"$DEST\":$AMOUNT},{\"data\":\"$P2SOP_DATA\"}]")
+echo "    RAW_BASE = $RAW_BASE"
+
+echo "[3] Funding transaction..."
+FUNDED_JSON=$($CLI fundrawtransaction "$RAW_BASE")
+FUNDED_HEX=$(echo "$FUNDED_JSON" | jq -r '.hex')
+FEE=$(echo "$FUNDED_JSON" | jq -r '.fee')
+echo "    fee        = $FEE"
+echo "    FUNDED_HEX = $FUNDED_HEX"
+
+echo "[4] Signing transaction with wallet ${WALLET}..."
+SIGNED_JSON=$($CLI signrawtransactionwithwallet "$FUNDED_HEX")
+SIGNED_HEX=$(echo "$SIGNED_JSON" | jq -r '.hex')
+COMPLETE=$(echo "$SIGNED_JSON" | jq -r '.complete')
+echo "    complete   = $COMPLETE"
+
+if [ "$COMPLETE" != "true" ]; then
+  echo "ERROR: signrawtransactionwithwallet returned complete=false" >&2
+  echo "$SIGNED_JSON" | jq .
+  exit 1
+fi
+
+echo "[5] Attaching segOP payload..."
+SEGOP_JSON=$($CLI createsegoptx "$SIGNED_HEX" "$PAYLOAD_HEX")
+SEGOP_HEX=$(echo "$SEGOP_JSON" | jq -r '.hex')
+echo "    SEGOP_HEX  = $SEGOP_HEX"
+
+echo "[6] Broadcasting..."
+TXID=$($CLI sendrawtransaction "$SEGOP_HEX")
+echo "    TXID       = $TXID"
+
+echo
+echo "=== Decoderawtransaction view ==="
+$CLI decoderawtransaction "$SEGOP_HEX" | jq '{txid, vout, segop}'
+
+if [ "$MINE" = "mine" ]; then
+  echo
+  echo "[7] Mining 1 block to confirm..."
+  MINER_ADDR=$($CLI_BASE getnewaddress)
+  BLOCKS_JSON=$($CLI_BASE generatetoaddress 1 "$MINER_ADDR")
+  BLOCKHASH=$(echo "$BLOCKS_JSON" | jq -r '.[0]')
+  echo "    Mined block: $BLOCKHASH"
+
+  echo
+  echo "=== getrawtransaction (confirmed) ==="
+  $CLI_BASE getrawtransaction "$TXID" 1 "$BLOCKHASH" \
+    | jq '{txid, blockhash, confirmations, vout, segop}'
+fi
+
+echo
+echo "Done."
diff --git a/segop_src_v1_snapshot.tgz b/segop_src_v1_snapshot.tgz
new file mode 100644
index 0000000000..cbf96bf2ff
Binary files /dev/null and b/segop_src_v1_snapshot.tgz differ
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 9abbf9586b..3d6cb15293 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -440,3 +440,4 @@ endif()
 if(BUILD_FUZZ_BINARY)
   add_subdirectory(test/fuzz)
 endif()
+add_subdirectory(segop)
diff --git a/src/consensus/consensus.h b/src/consensus/consensus.h
index 71b5fe2468..7bb8fe60fa 100644
--- a/src/consensus/consensus.h
+++ b/src/consensus/consensus.h
@@ -18,6 +18,9 @@ static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;
 /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */
 static const int COINBASE_MATURITY = 100;
 
+/** Maximum size of the coinbase scriptSig (network rule). */
+static const unsigned int MAX_COINBASE_SCRIPTSIG_SIZE = 100;
+
 static const int WITNESS_SCALE_FACTOR = 4;
 
 static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction
diff --git a/src/consensus/tx_check.cpp b/src/consensus/tx_check.cpp
index b3fee1e8b1..c7f777b796 100644
--- a/src/consensus/tx_check.cpp
+++ b/src/consensus/tx_check.cpp
@@ -1,59 +1,284 @@
-// Copyright (c) 2017-2021 The Bitcoin Core developers
+// Copyright (c) 2025 - Defenwycke - segOP
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
 #include <consensus/tx_check.h>
 
 #include <consensus/amount.h>
-#include <primitives/transaction.h>
+#include <consensus/consensus.h>
 #include <consensus/validation.h>
+#include <primitives/transaction.h>
+
+#include <algorithm>
+#include <set>
+
+// segOP helpers (CSegopPayload, SegopIsValidTLV, BuildSegopCommitmentBlob)
+#include <segop/segop.h>
+
+/**
+ * segOP: P2SOP script pattern and coupling rules
+ *
+ * Spec (high level):
+ *
+ *  - If a segOP payload is present:
+ *      * There MUST be exactly one P2SOP output.
+ *      * That P2SOP output MUST commit to the segOP payload using:
+ *
+ *          segop_commitment = TAGGED_HASH("segop:commitment", segop_payload_bytes)
+ *          P2SOP_blob       = "P2SOP" || segop_commitment
+ *
+ *        and the script is:
+ *
+ *          scriptPubKey = OP_RETURN <len = P2SOP_blob.size()> <P2SOP_blob bytes>
+ *
+ *  - If no segOP payload is present:
+ *      * There MUST NOT be any P2SOP output.
+ *
+ *  This file enforces that structural coupling at consensus.
+ */
+
+// -----------------------------------------------------------------------------
+// Helpers for detecting and matching P2SOP outputs
+// -----------------------------------------------------------------------------
+
+/** Return true if the given scriptPubKey looks like *any* P2SOP output
+ *  (regardless of which commitment it carries).
+ *
+ *  Format we match:
+ *      OP_RETURN <len> "P2SOP" ...
+ *  where:
+ *      - len >= 5 (enough to hold "P2SOP")
+ */
+static bool ScriptHasP2SOPPrefix(const CScript& script)
+{
+    if (script.size() < 1 + 1 + 5) return false; // OP_RETURN + len + "P2SOP"
+
+    if (script[0] != OP_RETURN) return false;
+    const unsigned char push_len = static_cast<unsigned char>(script[1]);
+
+    // Need at least 5 bytes of data for "P2SOP"
+    if (push_len < 5) return false;
+
+    // script structure: OP_RETURN [len] [len bytes of data...]
+    // We only check the first 5 data bytes for the ASCII tag.
+    if (script[2] != 'P') return false;
+    if (script[3] != '2') return false;
+    if (script[4] != 'S') return false;
+    if (script[5] != 'O') return false;
+    if (script[6] != 'P') return false;
+
+    return true;
+}
+
+/** Return true if the transaction has *any* P2SOP-looking output. */
+static bool TxHasAnyP2SOP(const CTransaction& tx)
+{
+    for (const auto& txout : tx.vout) {
+        if (ScriptHasP2SOPPrefix(txout.scriptPubKey)) {
+            return true;
+        }
+    }
+    return false;
+}
+
+/**
+ * Check that the transaction has *exactly one* P2SOP output whose data bytes
+ * match the expected P2SOP blob exactly:
+ *
+ *   expected_blob = "P2SOP" || TAGGED_HASH("segop:commitment", payload)
+ *
+ * The script must be:
+ *
+ *   OP_RETURN <len = expected_blob.size()> <expected_blob bytes...>
+ *
+ * Returns true iff:
+ *   - there is at least one P2SOP-looking output, and
+ *   - exactly one of them has data == expected_blob, and
+ *   - there are no *other* P2SOP-looking outputs with different data.
+ */
+static bool TxHasExactlyOneMatchingP2SOP(const CTransaction& tx,
+                                         const std::vector<unsigned char>& expected_blob)
+{
+    if (expected_blob.size() < 5) {
+        // Should never happen; P2SOP tag alone is 5 bytes.
+        return false;
+    }
+
+    int match_count = 0;
+
+    for (const auto& txout : tx.vout) {
+        const CScript& script = txout.scriptPubKey;
+
+        // Quickly skip anything that doesn't look like P2SOP at all.
+        if (!ScriptHasP2SOPPrefix(script)) {
+            continue;
+        }
+
+        // script layout: [0] = OP_RETURN
+        //                [1] = push_len
+        //                [2..] = data bytes ("P2SOP" || commitment)
+        const unsigned char push_len = static_cast<unsigned char>(script[1]);
 
+        // Data length must match expected_blob size.
+        if (push_len != expected_blob.size()) {
+            // This is a P2SOP-looking output, but with the wrong length.
+            // That is not allowed when segOP is present.
+            return false;
+        }
+
+        if (script.size() != 1 + 1 + expected_blob.size()) {
+            // Malformed script length relative to push_len; also invalid.
+            return false;
+        }
+
+        // Compare the data bytes directly to expected_blob.
+        const bool equal = std::equal(
+            expected_blob.begin(),
+            expected_blob.end(),
+            script.begin() + 2
+        );
+
+        if (!equal) {
+            // A P2SOP-looking output exists but commits to the wrong blob.
+            // Invalid for segOP-bearing transactions.
+            return false;
+        }
+
+        // Found one correct P2SOP.
+        match_count++;
+        if (match_count > 1) {
+            // More than one P2SOP with the correct blob is not allowed.
+            return false;
+        }
+    }
+
+    return match_count == 1;
+}
+
+// -----------------------------------------------------------------------------
+// Main structural transaction checks (with segOP rules)
+// -----------------------------------------------------------------------------
+
+/**
+ * Check basic structural properties of a transaction that do not depend on the
+ * UTXO set or chain state.
+ *
+ * This is where we also enforce segOP's structural consensus rules:
+ *   - if a segOP payload is present:
+ *       * version must match CSegopPayload::SEGOP_VERSION
+ *       * size must not exceed the spec cap
+ *       * TLV structure must be valid
+ *       * there must be exactly one P2SOP output whose data matches
+ *         "P2SOP" || TAGGED_HASH("segop:commitment", segop_payload)
+ *
+ *   - if NO segOP payload is present:
+ *       * there must be NO P2SOP outputs at all.
+ */
 bool CheckTransaction(const CTransaction& tx, TxValidationState& state)
 {
     // Basic checks that don't depend on any context
-    if (tx.vin.empty())
+    if (tx.vin.empty()) {
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vin-empty");
-    if (tx.vout.empty())
+    }
+    if (tx.vout.empty()) {
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-empty");
-    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)
+    }
+
+    // Basic size limit: the non-witness serialized size times WITNESS_SCALE_FACTOR
+    // must not exceed MAX_BLOCK_WEIGHT.
+    //
+    // Note: TX_NO_WITNESS(tx) does *not* include segOP; segOP bytes are carried
+    // in the extended lane and pay full weight via the GetTransactionWeight()
+    // logic (see segOP spec: 4 WU/byte, no discount).
     if (::GetSerializeSize(TX_NO_WITNESS(tx)) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT) {
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-oversize");
     }
 
-    // Check for negative or overflow output values (see CVE-2010-5139)
-    CAmount nValueOut = 0;
-    for (const auto& txout : tx.vout)
-    {
-        if (txout.nValue < 0)
+    const bool has_segop = !tx.segop_payload.IsNull();
+
+    if (has_segop) {
+        // ---------------------------------------------------------------------
+        // segOP present: enforce payload, TLV, and P2SOP coupling.
+        // ---------------------------------------------------------------------
+
+        // Version enforcement (segOP v1 only for now).
+        if (tx.segop_payload.version != CSegopPayload::SEGOP_VERSION) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-version");
+        }
+
+        // 1) Size cap (prototype / spec value: 64 KiB).
+        static constexpr unsigned int MAX_SEGOP_PAYLOAD_SIZE = 64000;
+        if (tx.segop_payload.data.size() > MAX_SEGOP_PAYLOAD_SIZE) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-toolarge");
+        }
+
+        // 2) TLV well-formedness: [type(1)][len(1)][value(len)] repeated; exact end.
+        if (!SegopIsValidTLV(tx.segop_payload.data)) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-tlv");
+        }
+
+        // 3) Build the expected P2SOP blob according to the spec:
+        //      P2SOP_blob = "P2SOP" || TAGGED_HASH("segop:commitment", payload)
+        //
+        //    and require the transaction to contain *exactly one* OP_RETURN
+        //    output whose pushed data exactly equals this blob, with no
+        //    additional P2SOP-looking outputs.
+        const std::vector<unsigned char> expected_p2sop_blob =
+            BuildSegopCommitmentBlob(tx.segop_payload.data);
+
+        if (!TxHasExactlyOneMatchingP2SOP(tx, expected_p2sop_blob)) {
+            // Either:
+            //  - no P2SOP found,
+            //  - more than one P2SOP,
+            //  - or a P2SOP is present but its commitment does not match.
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-no-p2sop");
+        }
+    } else {
+        // ---------------------------------------------------------------------
+        // No segOP payload: P2SOP must not be present at all.
+        // ---------------------------------------------------------------------
+        if (TxHasAnyP2SOP(tx)) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-p2sop-without-segop");
+        }
+    }
+
+    // Check for negative or overflow output values (same style as upstream).
+    CAmount nValueOut{0};
+    for (const auto& txout : tx.vout) {
+        if (!MoneyRange(txout.nValue)) {
             return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-negative");
-        if (txout.nValue > MAX_MONEY)
-            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-toolarge");
+        }
+
         nValueOut += txout.nValue;
-        if (!MoneyRange(nValueOut))
-            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-txouttotal-toolarge");
+
+        if (!MoneyRange(nValueOut)) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-toolarge");
+        }
     }
 
-    // Check for duplicate inputs (see CVE-2018-17144)
-    // While Consensus::CheckTxInputs does check if all inputs of a tx are available, and UpdateCoins marks all inputs
-    // of a tx as spent, it does not check if the tx has duplicate inputs.
-    // Failure to run this check will result in either a crash or an inflation bug, depending on the implementation of
-    // the underlying coins database.
+    // Check for duplicate inputs.
     std::set<COutPoint> vInOutPoints;
     for (const auto& txin : tx.vin) {
-        if (!vInOutPoints.insert(txin.prevout).second)
+        if (!vInOutPoints.insert(txin.prevout).second) {
             return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-inputs-duplicate");
+        }
     }
 
-    if (tx.IsCoinBase())
-    {
-        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)
+    if (tx.IsCoinBase()) {
+        // Coinbase scriptsig size limits.
+        if (tx.vin[0].scriptSig.size() < 2 ||
+            tx.vin[0].scriptSig.size() > MAX_COINBASE_SCRIPTSIG_SIZE) {
             return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-cb-length");
-    }
-    else
-    {
-        for (const auto& txin : tx.vin)
-            if (txin.prevout.IsNull())
+        }
+    } else {
+        // For non-coinbase transactions, prevouts must not be null.
+        for (const auto& txin : tx.vin) {
+            if (txin.prevout.IsNull()) {
                 return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-prevout-null");
+            }
+        }
     }
 
     return true;
diff --git a/src/core_read.cpp b/src/core_read.cpp
index 27d0d9d740..15fc518a7e 100644
--- a/src/core_read.cpp
+++ b/src/core_read.cpp
@@ -130,7 +130,8 @@ static bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>&
     //   0-input 1-output incomplete transaction).
     //   - Restricted by try_no_witness (which disables legacy if false) and try_witness (which
     //     disables extended if false).
-    //   - Ignore serializations that do not fully consume the hex string.
+    //   - Ignore serializations that do not fully consume the hex string, *except* that for the
+    //     extended form we allow a trailing segOP payload and attempt to parse it.
     // - If neither succeeds, fail.
     // - If only one succeeds, return that one.
     // - If both decode attempts succeed:
@@ -141,12 +142,33 @@ static bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>&
     bool ok_extended = false, ok_legacy = false;
 
     // Try decoding with extended serialization support, and remember if the result successfully
-    // consumes the entire input.
+    // consumes the entire input. With segOP support, we additionally allow a trailing segOP
+    // payload after the witness data and try to parse it into tx_extended.segop_payload.
     if (try_witness) {
         DataStream ssData(tx_data);
         try {
             ssData >> TX_WITH_WITNESS(tx_extended);
-            if (ssData.empty()) ok_extended = true;
+
+            if (ssData.empty()) {
+                // Normal (non-segOP) extended transaction: everything consumed.
+                ok_extended = true;
+            } else {
+                // segOP-aware decode: if there are trailing bytes, try to interpret them
+                // as a CSegopPayload. Only treat this as successful if that parse consumes
+                // *all* remaining bytes.
+                try {
+                    CSegopPayload segop;
+                    ssData >> segop;
+
+                    if (ssData.empty()) {
+                        tx_extended.segop_payload = std::move(segop);
+                        ok_extended = true;
+                    }
+                } catch (const std::exception&) {
+                    // Trailing bytes were not a valid segOP payload; fall through and
+                    // treat extended decoding as failed.
+                }
+            }
         } catch (const std::exception&) {
             // Fall through.
         }
diff --git a/src/core_write.cpp b/src/core_write.cpp
index 14836f5148..05a58d5c70 100644
--- a/src/core_write.cpp
+++ b/src/core_write.cpp
@@ -174,6 +174,9 @@ void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry
 
     entry.pushKV("txid", tx.GetHash().GetHex());
     entry.pushKV("hash", tx.GetWitnessHash().GetHex());
+    if (!tx.segop_payload.IsNull()) {
+    entry.pushKV("fullxid", tx.GetFullxid().ToString());
+    }
     entry.pushKV("version", tx.version);
     entry.pushKV("size", tx.GetTotalSize());
     entry.pushKV("vsize", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);
@@ -260,11 +263,22 @@ void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry
         entry.pushKV("fee", ValueFromAmount(fee));
     }
 
+    // --- segOP: expose payload in JSON when present ---
+    if (!tx.segop_payload.IsNull()) {
+        UniValue seg(UniValue::VOBJ);
+        seg.pushKV("version", (int64_t)tx.segop_payload.version);
+        seg.pushKV("size", (uint64_t)tx.segop_payload.data.size());
+        seg.pushKV("hex", HexStr(tx.segop_payload.data));
+        entry.pushKV("segop", std::move(seg));
+    }
+    // --- end segOP JSON section ---
+
     if (!block_hash.IsNull()) {
         entry.pushKV("blockhash", block_hash.GetHex());
     }
 
     if (include_hex) {
-        entry.pushKV("hex", EncodeHexTx(tx)); // The hex-encoded transaction. Used the name "hex" to be consistent with the verbose output of "getrawtransaction".
+        // The hex-encoded transaction. Used the name "hex" to be consistent with the verbose output of "getrawtransaction".
+        entry.pushKV("hex", EncodeHexTx(tx));
     }
 }
diff --git a/src/primitives/transaction.cpp b/src/primitives/transaction.cpp
index e80ab60fcd..fdf7706960 100644
--- a/src/primitives/transaction.cpp
+++ b/src/primitives/transaction.cpp
@@ -1,3 +1,4 @@
+// Copyright (c) 2025 Defenwycke - segOP
 // Copyright (c) 2009-2010 Satoshi Nakamoto
 // Copyright (c) 2009-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
@@ -18,11 +19,15 @@
 #include <cassert>
 #include <stdexcept>
 
+/** COutPoint *****************************************************************/
+
 std::string COutPoint::ToString() const
 {
-    return strprintf("COutPoint(%s, %u)", hash.ToString().substr(0,10), n);
+    return strprintf("COutPoint(%s, %u)", hash.ToString().substr(0, 10), n);
 }
 
+/** CTxIn *********************************************************************/
+
 CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)
 {
     prevout = prevoutIn;
@@ -42,16 +47,20 @@ std::string CTxIn::ToString() const
     std::string str;
     str += "CTxIn(";
     str += prevout.ToString();
-    if (prevout.IsNull())
+    if (prevout.IsNull()) {
         str += strprintf(", coinbase %s", HexStr(scriptSig));
-    else
+    } else {
         str += strprintf(", scriptSig=%s", HexStr(scriptSig).substr(0, 24));
-    if (nSequence != SEQUENCE_FINAL)
+    }
+    if (nSequence != SEQUENCE_FINAL) {
         str += strprintf(", nSequence=%u", nSequence);
+    }
     str += ")";
     return str;
 }
 
+/** CTxOut ********************************************************************/
+
 CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)
 {
     nValue = nValueIn;
@@ -60,47 +69,132 @@ CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)
 
 std::string CTxOut::ToString() const
 {
-    return strprintf("CTxOut(nValue=%d.%08d, scriptPubKey=%s)", nValue / COIN, nValue % COIN, HexStr(scriptPubKey).substr(0, 30));
+    return strprintf(
+        "CTxOut(nValue=%d.%08d, scriptPubKey=%s)",
+        nValue / COIN,
+        nValue % COIN,
+        HexStr(scriptPubKey).substr(0, 30)
+    );
+}
+
+/** CMutableTransaction *******************************************************/
+
+CMutableTransaction::CMutableTransaction()
+    : vin(),
+      vout(),
+      version{CTransaction::CURRENT_VERSION},
+      nLockTime{0},
+      segop_payload() // segOP: default-constructed (null)
+{
 }
 
-CMutableTransaction::CMutableTransaction() : version{CTransaction::CURRENT_VERSION}, nLockTime{0} {}
-CMutableTransaction::CMutableTransaction(const CTransaction& tx) : vin(tx.vin), vout(tx.vout), version{tx.version}, nLockTime{tx.nLockTime} {}
+CMutableTransaction::CMutableTransaction(const CTransaction& tx)
+    : vin(tx.vin),
+      vout(tx.vout),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(tx.segop_payload) // segOP: carry payload across
+{
+}
 
 Txid CMutableTransaction::GetHash() const
 {
+    // Hash of the transaction without witness (and without segwit discount).
+    // This helper is used internally by the wallet; consensus txid is defined
+    // by CTransaction::ComputeHash().
     return Txid::FromUint256((HashWriter{} << TX_NO_WITNESS(*this)).GetHash());
 }
 
+/** CTransaction (internal helpers) *******************************************/
+
 bool CTransaction::ComputeHasWitness() const
 {
-    return std::any_of(vin.begin(), vin.end(), [](const auto& input) {
+    return std::any_of(vin.begin(), vin.end(), [](const CTxIn& input) {
         return !input.scriptWitness.IsNull();
     });
 }
 
 Txid CTransaction::ComputeHash() const
 {
-    return Txid::FromUint256((HashWriter{} << TX_NO_WITNESS(*this)).GetHash());
+    // Spec §7.2.1: txid is the legacy non-witness serialization that ignores
+    // marker, flag, witness *and segOP*. To preserve that behaviour, hash a
+    // copy of the transaction with segOP stripped.
+    CMutableTransaction tx_legacy{*this};
+    tx_legacy.segop_payload.SetNull();
+
+    return Txid::FromUint256((HashWriter{} << TX_NO_WITNESS(tx_legacy)).GetHash());
 }
 
 Wtxid CTransaction::ComputeWitnessHash() const
 {
+    // Spec §7.2.2 and BIP141: if there is no witness, wtxid == txid.
     if (!HasWitness()) {
         return Wtxid::FromUint256(hash.ToUint256());
     }
 
-    return Wtxid::FromUint256((HashWriter{} << TX_WITH_WITNESS(*this)).GetHash());
+    // With witness: wtxid is computed over the extended-with-witness
+    // serialization *excluding segOP*. So we hash a copy with segOP stripped.
+    CMutableTransaction tx_extended{*this};
+    tx_extended.segop_payload.SetNull();
+
+    return Wtxid::FromUint256((HashWriter{} << TX_WITH_WITNESS(tx_extended)).GetHash());
 }
 
-CTransaction::CTransaction(const CMutableTransaction& tx) : vin(tx.vin), vout(tx.vout), version{tx.version}, nLockTime{tx.nLockTime}, m_has_witness{ComputeHasWitness()}, hash{ComputeHash()}, m_witness_hash{ComputeWitnessHash()} {}
-CTransaction::CTransaction(CMutableTransaction&& tx) : vin(std::move(tx.vin)), vout(std::move(tx.vout)), version{tx.version}, nLockTime{tx.nLockTime}, m_has_witness{ComputeHasWitness()}, hash{ComputeHash()}, m_witness_hash{ComputeWitnessHash()} {}
+Fullxid CTransaction::ComputeFullxid() const
+{
+    // Spec §7.2.3: fullxid = TAGGED_HASH("segop:fullxid", extended_serialization)
+    // where extended_serialization is the full extended wire format:
+    //
+    //   nVersion || marker || flag || vin || vout ||
+    //   [witness data, if present] ||
+    //   [segOP section, if present] ||
+    //   nLockTime
+    //
+    // TX_WITH_WITNESS(*this) is defined to emit exactly that extended
+    // serialization for segOP-aware nodes, so we feed it straight into
+    // a tagged HashWriter.
+
+    HashWriter hw = TaggedHash("segop:fullxid");
+    hw << TX_WITH_WITNESS(*this);
+
+    return Fullxid::FromUint256(hw.GetHash());
+}
+
+/** CTransaction (public) *****************************************************/
+
+CTransaction::CTransaction(const CMutableTransaction& tx)
+    : vin(tx.vin),
+      vout(tx.vout),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(tx.segop_payload),
+      m_has_witness{ComputeHasWitness()},
+      hash{ComputeHash()},
+      m_witness_hash{ComputeWitnessHash()},
+      m_full_hash{ComputeFullxid()}
+{
+}
+
+CTransaction::CTransaction(CMutableTransaction&& tx)
+    : vin(std::move(tx.vin)),
+      vout(std::move(tx.vout)),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(std::move(tx.segop_payload)),
+      m_has_witness{ComputeHasWitness()},
+      hash{ComputeHash()},
+      m_witness_hash{ComputeWitnessHash()},
+      m_full_hash{ComputeFullxid()}
+{
+}
 
 CAmount CTransaction::GetValueOut() const
 {
     CAmount nValueOut = 0;
     for (const auto& tx_out : vout) {
-        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut + tx_out.nValue))
+        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut + tx_out.nValue)) {
             throw std::runtime_error(std::string(__func__) + ": value out of range");
+        }
         nValueOut += tx_out.nValue;
     }
     assert(MoneyRange(nValueOut));
@@ -109,23 +203,41 @@ CAmount CTransaction::GetValueOut() const
 
 unsigned int CTransaction::GetTotalSize() const
 {
+    // Full serialized size in extended-with-witness form, which for segOP-aware
+    // nodes includes the segOP section between witness (if any) and nLockTime.
     return ::GetSerializeSize(TX_WITH_WITNESS(*this));
 }
 
 std::string CTransaction::ToString() const
 {
     std::string str;
-    str += strprintf("CTransaction(hash=%s, ver=%u, vin.size=%u, vout.size=%u, nLockTime=%u)\n",
-        GetHash().ToString().substr(0,10),
+    str += strprintf(
+        "CTransaction(hash=%s, ver=%u, vin.size=%u, vout.size=%u, nLockTime=%u)\n",
+        GetHash().ToString().substr(0, 10),
         version,
         vin.size(),
         vout.size(),
-        nLockTime);
-    for (const auto& tx_in : vin)
+        nLockTime
+    );
+
+    for (const auto& tx_in : vin) {
         str += "    " + tx_in.ToString() + "\n";
-    for (const auto& tx_in : vin)
+    }
+    for (const auto& tx_in : vin) {
         str += "    " + tx_in.scriptWitness.ToString() + "\n";
-    for (const auto& tx_out : vout)
+    }
+    for (const auto& tx_out : vout) {
         str += "    " + tx_out.ToString() + "\n";
+    }
+
+    // segOP debugging: show presence and size, but not full payload hex
+    if (!segop_payload.IsNull()) {
+        str += strprintf(
+            "    segOP(version=%u, size=%u bytes)\n",
+            segop_payload.version,
+            static_cast<unsigned int>(segop_payload.data.size())
+        );
+    }
+
     return str;
 }
diff --git a/src/primitives/transaction.h b/src/primitives/transaction.h
index 295bce61b9..dd9959edc9 100644
--- a/src/primitives/transaction.h
+++ b/src/primitives/transaction.h
@@ -1,3 +1,4 @@
+// Copyright (c) Defenwycke - segOP
 // Copyright (c) 2009-2010 Satoshi Nakamoto
 // Copyright (c) 2009-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
@@ -12,6 +13,7 @@
 #include <script/script.h>
 #include <serialize.h>
 #include <uint256.h>
+#include <segop/segop.h>   // segOP payload
 
 #include <cstddef>
 #include <cstdint>
@@ -202,14 +204,19 @@ static constexpr TransactionSerParams TX_NO_WITNESS{.allow_witness = false};
  * - std::vector<CTxOut> vout
  * - uint32_t nLockTime
  *
- * Extended transaction serialization format:
+ * Extended transaction serialization format (SegWit + segOP):
  * - uint32_t version
  * - unsigned char dummy = 0x00
  * - unsigned char flags (!= 0)
+ *   bit0 (0x01): witness data present
+ *   bit1 (0x02): segOP payload present
  * - std::vector<CTxIn> vin
  * - std::vector<CTxOut> vout
  * - if (flags & 1):
  *   - CScriptWitness scriptWitness; (deserialized into CTxIn)
+ * - if (flags & 2):
+ *   - uint8_t segop_marker = 0x53 ('S')
+ *   - CSegopPayload segop_payload;   // version + [len + bytes]
  * - uint32_t nLockTime
  */
 template<typename Stream, typename TxType>
@@ -234,6 +241,8 @@ void UnserializeTransaction(TxType& tx, Stream& s, const TransactionSerParams& p
         /* We read a non-empty vin. Assume a normal vout follows. */
         s >> tx.vout;
     }
+
+    // Witness (bit 0) – unchanged SegWit behaviour
     if ((flags & 1) && fAllowWitness) {
         /* The witness flag is present, and we support witnesses. */
         flags ^= 1;
@@ -245,6 +254,22 @@ void UnserializeTransaction(TxType& tx, Stream& s, const TransactionSerParams& p
             throw std::ios_base::failure("Superfluous witness record");
         }
     }
+
+    // segOP payload (bit 1)
+    if (flags & 2) {
+        flags ^= 2;
+
+        // Read and validate segOP marker 0x53 ('S')
+        unsigned char segop_marker = 0;
+        s >> segop_marker;
+        if (segop_marker != 0x53) {
+            throw std::ios_base::failure("Invalid segOP marker");
+        }
+
+        // Then deserialize version + len + bytes from CSegopPayload
+        s >> tx.segop_payload;
+    }
+
     if (flags) {
         /* Unknown flag in the serialization */
         throw std::ios_base::failure("Unknown transaction optional data");
@@ -259,26 +284,39 @@ void SerializeTransaction(const TxType& tx, Stream& s, const TransactionSerParam
 
     s << tx.version;
     unsigned char flags = 0;
-    // Consistency check
-    if (fAllowWitness) {
-        /* Check whether witnesses need to be serialized. */
-        if (tx.HasWitness()) {
-            flags |= 1;
-        }
+
+    // Witness flag (bit 0)
+    if (fAllowWitness && tx.HasWitness()) {
+        flags |= 1;
+    }
+    // segOP flag (bit 1)
+    if (!tx.segop_payload.IsNull()) {
+        flags |= 2;
     }
+
     if (flags) {
-        /* Use extended format in case witnesses are to be serialized. */
+        /* Use extended format in case any optional sections are to be serialized. */
         std::vector<CTxIn> vinDummy;
         s << vinDummy;
         s << flags;
     }
+
     s << tx.vin;
     s << tx.vout;
-    if (flags & 1) {
+
+    if ((flags & 1) && fAllowWitness) {
         for (size_t i = 0; i < tx.vin.size(); i++) {
             s << tx.vin[i].scriptWitness.stack;
         }
     }
+
+    if (flags & 2) {
+        // segOP marker 0x53 ('S') followed by payload (version + len + bytes)
+        unsigned char segop_marker = 0x53;
+        s << segop_marker;
+        s << tx.segop_payload;
+    }
+
     s << tx.nLockTime;
 }
 
@@ -308,14 +346,19 @@ public:
     const uint32_t version;
     const uint32_t nLockTime;
 
+    // segOP: attached payload
+    const CSegopPayload segop_payload;
+
 private:
     /** Memory only. */
     const bool m_has_witness;
     const Txid hash;
     const Wtxid m_witness_hash;
+    const Fullxid m_full_hash; //!< Hash of full extended tx (incl. segOP)
 
     Txid ComputeHash() const;
     Wtxid ComputeWitnessHash() const;
+    Fullxid ComputeFullxid() const; //segOP
 
     bool ComputeHasWitness() const;
 
@@ -342,13 +385,14 @@ public:
 
     const Txid& GetHash() const LIFETIMEBOUND { return hash; }
     const Wtxid& GetWitnessHash() const LIFETIMEBOUND { return m_witness_hash; };
+    const Fullxid& GetFullxid() const LIFETIMEBOUND { return m_full_hash; } //segOP
 
     // Return sum of txouts.
     CAmount GetValueOut() const;
 
     /**
-     * Get the total transaction size in bytes, including witness data.
-     * "Total Size" defined in BIP141 and BIP144.
+     * Get the total transaction size in bytes, including witness data and segOP.
+     * "Total Size" defined in BIP141 and BIP144 plus segOP section.
      * @return Total transaction size in bytes
      */
     unsigned int GetTotalSize() const;
@@ -381,6 +425,9 @@ struct CMutableTransaction
     uint32_t version;
     uint32_t nLockTime;
 
+    // segOP: mutable payload
+    CSegopPayload segop_payload;
+
     explicit CMutableTransaction();
     explicit CMutableTransaction(const CTransaction& tx);
 
diff --git a/src/primitives/transaction_identifier.h b/src/primitives/transaction_identifier.h
index b753c1df39..c38c6c9ac3 100644
--- a/src/primitives/transaction_identifier.h
+++ b/src/primitives/transaction_identifier.h
@@ -68,6 +68,8 @@ public:
 using Txid = transaction_identifier<false>;
 /** Wtxid commits to all transaction fields including the witness. */
 using Wtxid = transaction_identifier<true>;
+/** Fullxid commits to all transaction fields including the segOP. */
+using Fullxid = transaction_identifier<true>; // full extended tx id (witness + segOP)cd /root/bitcoin-segop
 
 template <typename T>
 concept TxidOrWtxid = std::is_same_v<T, Txid> || std::is_same_v<T, Wtxid>;
diff --git a/src/rpc/client.cpp b/src/rpc/client.cpp
index 1fbe62d3d3..62ec83c34a 100644
--- a/src/rpc/client.cpp
+++ b/src/rpc/client.cpp
@@ -195,6 +195,7 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "lockunspent", 0, "unlock" },
     { "lockunspent", 1, "transactions" },
     { "lockunspent", 2, "persistent" },
+    { "segopsend", 3, "options" },// segOP
     { "send", 0, "outputs" },
     { "send", 1, "conf_target" },
     { "send", 3, "fee_rate"},
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 1a8edc594f..b24707f465 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1,3 +1,4 @@
+// Copyright (c) 2025 Defenwycke - segOP
 // Copyright (c) 2010 Satoshi Nakamoto
 // Copyright (c) 2009-present The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
@@ -32,6 +33,7 @@
 #include <script/sign.h>
 #include <script/signingprovider.h>
 #include <script/solver.h>
+#include <span.h>
 #include <uint256.h>
 #include <undo.h>
 #include <util/bip32.h>
@@ -47,6 +49,9 @@
 
 #include <univalue.h>
 
+#include <crypto/sha256.h> // segOP: for P2SOP commitment hashing
+#include <segop/segop.h>          // CSegopPayload
+
 using node::AnalyzePSBT;
 using node::FindCoins;
 using node::GetTransaction;
@@ -488,6 +493,295 @@ static RPCHelpMan decoderawtransaction()
     };
 }
 
+//////////////////
+// segOP: best-effort TLV decoder for RPC.
+//
+// This is *not* consensus; consensus validation of the raw payload
+// (including canonical CompactSize) lives in segop.h / tx_check.cpp.
+//
+// TLV layout (spec §5.2 / §6):
+//   [ type (1 byte) ]
+//   [ length (CompactSize) ]
+//   [ value (length bytes) ]
+// repeated back-to-back with no extra header.
+//
+// Known types (v1):
+//   0x01 = TEXT_UTF8    → kind: "text", plus "text" field
+//   0x02 = JSON_UTF8    → kind: "json", "text" (raw JSON), optional "parsed"
+//   0x03 = BINARY_BLOB  → kind: "blob"
+//
+// Unknown types are surfaced as opaque records with:
+//   type / length / value_hex / kind: "unknown".
+
+static UniValue DecodeSegopTlv(const CSegopPayload& segop)
+{
+    UniValue out(UniValue::VARR);
+
+    const std::vector<unsigned char>& d = segop.data;
+    const size_t n = d.size();
+    size_t i = 0;
+
+    while (i < n) {
+        // Need at least a type byte
+        if (n - i < 1) break;
+
+        const uint8_t t = d[i++];
+
+        // Read CompactSize length (same rules as SegopIsValidTLV)
+        uint64_t len64 = 0;
+        if (!SegopReadCompactSize(d, i, len64)) {
+            // Malformed length – consensus would have rejected already.
+            // For RPC, stop decoding gracefully.
+            break;
+        }
+
+        // Bounds check: not enough bytes for the value
+        if (len64 > (n - i)) {
+            break;
+        }
+        const size_t len = static_cast<size_t>(len64);
+
+        // Base record
+        UniValue rec(UniValue::VOBJ);
+        rec.pushKV("type", strprintf("0x%02x", t));
+        rec.pushKV("length", static_cast<uint64_t>(len));
+
+        // Raw value in hex for all types.
+        auto span_val = MakeUCharSpan(d).subspan(i, len);
+        rec.pushKV("value_hex", HexStr(span_val));
+
+        // Default kind is "unknown" – overridden for known types below.
+        std::string kind = "unknown";
+
+        // 0x01 = TEXT_UTF8
+        if (t == SegopTlvType::TEXT_UTF8 || t == 0x01) {
+            kind = "text";
+            std::string text(reinterpret_cast<const char*>(&d[i]),
+                             reinterpret_cast<const char*>(&d[i]) + len);
+            rec.pushKV("text", text);
+        }
+
+        // 0x02 = JSON_UTF8
+        if (t == SegopTlvType::JSON_UTF8 || t == 0x02) {
+            kind = "json";
+            std::string json_str(reinterpret_cast<const char*>(&d[i]),
+                                 reinterpret_cast<const char*>(&d[i]) + len);
+
+            // Always expose the raw JSON string as "text"
+            rec.pushKV("text", json_str);
+
+            UniValue json_val;
+            if (json_val.read(json_str)) {
+                // Parsed JSON object/array/etc
+                rec.pushKV("parsed", json_val);
+            } else {
+                // Not valid JSON, but still useful to see raw
+                rec.pushKV("json_raw", json_str);
+            }
+        }
+
+        // 0x03 = BINARY_BLOB: we don't add text, just mark kind=blob.
+        if (t == SegopTlvType::BINARY_BLOB || t == 0x03) {
+            kind = "blob";
+        }
+
+        rec.pushKV("kind", kind);
+
+        out.push_back(std::move(rec));
+
+        // Advance over the value bytes to the next TLV record
+        i += len;
+    }
+
+    return out;
+}
+
+RPCHelpMan decodesegop()
+{
+    return RPCHelpMan{
+        "decodesegop",
+        "Decode the segOP payload from a raw transaction hex.\n"
+        "Returns basic information about the segOP lane, and a TLV view\n"
+        "for segOP payloads encoded as [type(1)][len(varint)][value].\n",
+        {
+            {"hexstring", RPCArg::Type::STR, RPCArg::Optional::NO,
+             "The raw transaction hex string."},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::BOOL, "has_segop", "Whether the transaction contains a segOP payload."},
+                {RPCResult::Type::NUM,  "version",   "segOP version (if present)."},
+                {RPCResult::Type::NUM,  "size",      "segOP payload size in bytes."},
+                {RPCResult::Type::STR_HEX, "hex",    "segOP payload bytes as hex."},
+                {RPCResult::Type::ARR, "tlv",        "Parsed TLV view of the payload (if present).",
+                    {
+                        {RPCResult::Type::OBJ, "", "",
+                            {
+                                {RPCResult::Type::STR,      "type",      "TLV type (e.g. \"0x01\")."},
+                                {RPCResult::Type::NUM,      "length",    "TLV value length in bytes."},
+                                {RPCResult::Type::STR_HEX,  "value_hex", "Raw value bytes as hex."},
+                                {RPCResult::Type::STR,      "text",      "Decoded UTF-8 text (for type 0x01, when printable)."},
+                            }
+                        },
+                    }
+                },
+            }
+        },
+        RPCExamples{
+            HelpExampleCli("segopsend",
+                "\"bcrt1qdest...\" 0.001 \"segOP TLV test payload\"") +
+            "\nThen decode the segOP lane from the raw tx hex:\n"
+            "> bitcoin-cli getrawtransaction <txid> false\n"
+            "> bitcoin-cli decodesegop \"<rawtxhex>\"\n"
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            const std::string hex = request.params[0].get_str();
+
+            CMutableTransaction mtx;
+            if (!DecodeHexTx(mtx, hex, /*try_no_witness=*/true, /*try_witness=*/true)) {
+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+            }
+
+            UniValue result(UniValue::VOBJ);
+
+            if (mtx.segop_payload.IsNull()) {
+                // Plain transaction: just signal absence.
+                result.pushKV("has_segop", false);
+                return result;
+            }
+
+            // segOP present: expose header + TLV breakdown
+            result.pushKV("has_segop", true);
+            result.pushKV("version", (int)mtx.segop_payload.version);
+            result.pushKV("size", (uint64_t)mtx.segop_payload.data.size());
+            result.pushKV("hex", HexStr(mtx.segop_payload.data));
+
+            UniValue tlv = DecodeSegopTlv(mtx.segop_payload);
+            if (!tlv.isNull() && tlv.size() > 0) {
+                result.pushKV("tlv", tlv);
+            }
+
+            return result;
+        }
+    };
+}
+
+
+//////////////////
+static RPCHelpMan createsegoptx()
+{
+    return RPCHelpMan{
+        "createsegoptx",
+        "Attach a segOP payload to an existing raw transaction.\n"
+        "Takes a standard raw transaction hex string, sets segOP version=1 and the given payload,\n"
+        "and returns the re-serialized transaction hex (using the extended segOP-aware format).\n",
+        {
+            {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO,
+             "The transaction hex string (non-segOP or segOP-neutral)"},
+            {"payload",   RPCArg::Type::STR_HEX, RPCArg::Optional::NO,
+             "Hex-encoded segOP payload bytes"},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR_HEX, "hex",
+                 "The hex-encoded transaction with segOP payload attached"},
+            }
+        },
+        RPCExamples{
+            HelpExampleCli("createsegoptx", "\"0200000001...\" \"01020304\"") +
+            HelpExampleRpc("createsegoptx", "\"0200000001...\", \"01020304\"")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            // Decode the input tx using the normal heuristics (witness or not)
+            CMutableTransaction mtx;
+            if (!DecodeHexTx(mtx,
+                             request.params[0].get_str(),
+                             /*try_no_witness=*/true,
+                             /*try_witness=*/true)) {
+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+            }
+
+            const std::string payload_hex = request.params[1].get_str();
+            if (!IsHex(payload_hex)) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER,
+                                   "Payload must be hex string");
+            }
+            std::vector<unsigned char> payload = ParseHex(payload_hex);
+
+            // Attach segOP payload; version 1 for now
+            mtx.segop_payload.version = 1;
+            mtx.segop_payload.data = std::move(payload);
+
+            // Serialize using the extended (witness+segOP-aware) format
+            DataStream ssTx{};
+            ssTx << TX_WITH_WITNESS(mtx);
+
+            UniValue result(UniValue::VOBJ);
+            result.pushKV("hex", HexStr(ssTx));
+            return result;
+        }
+    };
+}
+
+
+static RPCHelpMan segopbuildp2sop()
+{
+    return RPCHelpMan{
+        "segopbuildp2sop",
+        "Given a segOP payload (hex), compute the P2SOP commitment data.\n"
+        "The returned hex is \"534f50 || SHA256(payload)\" and is intended to be used\n"
+        "as the `data` field in an OP_RETURN output via createrawtransaction.\n",
+        {
+            {"payload", RPCArg::Type::STR_HEX, RPCArg::Optional::NO,
+             "Hex-encoded segOP payload bytes"},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR_HEX, "data",
+                 "Hex string to use in a `{\"data\":\"...\"}` output for createrawtransaction"},
+            }
+        },
+        RPCExamples{
+            HelpExampleCli("segopbuildp2sop", "\"01020304\"") +
+            HelpExampleRpc("segopbuildp2sop", "\"01020304\"")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            const std::string payload_hex = request.params[0].get_str();
+            if (!IsHex(payload_hex)) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER,
+                                   "payload must be hex-encoded");
+            }
+
+            // segOP payload bytes
+            const std::vector<unsigned char> payload = ParseHex(payload_hex);
+
+            // SHA256(payload)
+            unsigned char hash[CSHA256::OUTPUT_SIZE];
+            CSHA256()
+                .Write(payload.data(), payload.size())
+                .Finalize(hash);
+
+            // Build SOP || hash (53 4f 50 + 32-byte hash)
+            std::vector<unsigned char> data;
+            data.reserve(3 + CSHA256::OUTPUT_SIZE);
+            data.push_back(0x53); // 'S'
+            data.push_back(0x4f); // 'O'
+            data.push_back(0x50); // 'P'
+            data.insert(data.end(), hash, hash + CSHA256::OUTPUT_SIZE);
+
+            UniValue result(UniValue::VOBJ);
+            result.pushKV("data", HexStr(data));
+            return result;
+        }
+    };
+}
+
 static RPCHelpMan decodescript()
 {
     return RPCHelpMan{
@@ -2121,6 +2415,9 @@ void RegisterRawTransactionRPCCommands(CRPCTable& t)
         {"rawtransactions", &getrawtransaction},
         {"rawtransactions", &createrawtransaction},
         {"rawtransactions", &decoderawtransaction},
+        { "rawtransactions", &decodesegop}, //segOP
+        {"rawtransactions", &createsegoptx},  //segOP
+        {"rawtransactions", &segopbuildp2sop}, //segOP
         {"rawtransactions", &decodescript},
         {"rawtransactions", &combinerawtransaction},
         {"rawtransactions", &signrawtransactionwithkey},
diff --git a/src/segop/CMakeLists.txt b/src/segop/CMakeLists.txt
new file mode 100644
index 0000000000..25c26fd8f0
--- /dev/null
+++ b/src/segop/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SegOP module
+add_library(segop STATIC segop.cpp)
+
+# Ensure it’s compiled as C++
+set_target_properties(segop PROPERTIES LINKER_LANGUAGE CXX)
+
+# Make headers visible to the rest of the project
+target_include_directories(segop PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)
diff --git a/src/segop/segop.cpp b/src/segop/segop.cpp
new file mode 100644
index 0000000000..6d1e5adb88
--- /dev/null
+++ b/src/segop/segop.cpp
@@ -0,0 +1,5 @@
+// Copyright (c) 2025 segOP Authors
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <segop/segop.h>
diff --git a/src/segop/segop.h b/src/segop/segop.h
new file mode 100644
index 0000000000..0208708d1a
--- /dev/null
+++ b/src/segop/segop.h
@@ -0,0 +1,427 @@
+// Copyright (c) 2025 - Defenwycke - segOP
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_SEGOP_SEGOP_H
+#define BITCOIN_SEGOP_SEGOP_H
+
+#include <serialize.h>
+
+#include <cstdint>
+#include <cstddef>
+#include <string>
+#include <vector>
+#include <limits>
+
+#include <crypto/sha256.h>
+#include <hash.h>
+#include <span.h>   // MakeUCharSpan
+#include <span>     // std::span, std::as_bytes
+
+/**
+ * SegOP payload carried in the extended transaction serialization.
+ *
+ * Wire layout of the SegOP section (when enabled by the tx flag):
+ *
+ *   [ segop_marker (1) = 0x53 ]       // ASCII 'S'  (handled in tx serialization)
+ *   [ segop_flag   (1) = version ]    // segOP version / feature bits
+ *   [ segop_len    (varint) ]         // length of payload
+ *   [ segop_payload (segop_len bytes) ]
+ *
+ * This struct models everything *after* the marker:
+ *   - `version`  → segop_flag
+ *   - `data`     → segop_payload bytes (TLV, Merkle root, etc.)
+ */
+struct CSegopPayload
+{
+    // segOP v1 version byte.
+    static constexpr uint8_t SEGOP_VERSION = 0x01;
+
+    // Hard cap from the spec: maximum segOP payload size in bytes.
+    // Enforced as a consensus rule in tx_check.
+    static constexpr std::size_t MAX_SEGOP_PAYLOAD_SIZE = 64'000;
+
+    uint8_t version;
+    std::vector<unsigned char> data;
+
+    CSegopPayload() { SetNull(); }
+
+    void SetNull()
+    {
+        version = 0;
+        data.clear();
+    }
+
+    bool IsNull() const
+    {
+        return version == 0 && data.empty();
+    }
+
+    // Convenience helper used by consensus checks.
+    bool TooLarge() const
+    {
+        return data.size() > MAX_SEGOP_PAYLOAD_SIZE;
+    }
+
+    SERIALIZE_METHODS(CSegopPayload, obj)
+    {
+        // NOTE:
+        //  - The 0x53 marker byte is *not* handled here; it is emitted/checked
+        //    by the transaction serializer when the segOP flag bit is set.
+        //  - std::vector<unsigned char> uses CompactSize/varint length encoding
+        //    automatically, so this matches: [segop_len][segop_payload bytes].
+        READWRITE(obj.version);
+        READWRITE(obj.data);
+    }
+};
+
+// ---------------------------------------------------------------------------
+// segOP TLV type registry (v1)
+// ---------------------------------------------------------------------------
+/*
+ * TLV type ranges (documented, non-consensus registry):
+ *
+ *   0x01 = TEXT_UTF8    (human-readable UTF-8 string)
+ *   0x02 = JSON_UTF8    (UTF-8 JSON document)
+ *   0x03 = BINARY_BLOB  (opaque binary blob)
+ *
+ *   0x04–0x1f : reserved for future consensus-defined types
+ *   0x20–0x7f : generic / open-use, non-consensus types
+ *   0x80–0xff : application / L2-specific namespaces
+ *
+ * Unknown types are treated as opaque TLVs by consensus, and surfaced
+ * as "kind": "unknown" in RPC decoding.
+ */
+namespace SegopTlvType {
+    static constexpr uint8_t TEXT_UTF8   = 0x01; // human-readable UTF-8
+    static constexpr uint8_t JSON_UTF8   = 0x02; // structured JSON (UTF-8)
+    static constexpr uint8_t BINARY_BLOB = 0x03; // opaque bytes
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ * segOP helper utilities (wallet / tools side)
+ * ---------------------------------------------------------------------------
+ *
+ * NOTE: These helpers do *not* change consensus on their own. They just
+ * construct payloads and commitment blobs that match what consensus already
+ * enforces in src/consensus/tx_check.cpp.
+ */
+
+/**
+ * segOP TLV helper: read a Bitcoin CompactSize (varint) from a byte vector.
+ *
+ * Returns false on overrun or non-canonical encoding.
+ *
+ * This mirrors the CompactSize rules used by Bitcoin's serialization:
+ *  - < 253       : 1 byte
+ *  - 253         : 0xfd + uint16 (little endian, >= 253)
+ *  - 254         : 0xfe + uint32 (little endian, >= 0x10000)
+ *  - 255         : 0xff + uint64 (little endian, >= 0x100000000)
+ */
+inline bool SegopReadCompactSize(const std::vector<unsigned char>& bytes,
+                                 size_t&                           i,
+                                 uint64_t&                         size_out)
+{
+    const size_t n = bytes.size();
+    if (i >= n) return false;
+
+    unsigned char chSize = bytes[i++];
+
+    if (chSize < 253) {
+        size_out = chSize;
+        return true;
+    }
+
+    if (chSize == 253) {
+        if (n - i < 2) return false;
+        uint16_t v = static_cast<uint16_t>(bytes[i])
+                   | (static_cast<uint16_t>(bytes[i + 1]) << 8);
+        i += 2;
+        if (v < 253) return false; // non-canonical
+        size_out = v;
+        return true;
+    }
+
+    if (chSize == 254) {
+        if (n - i < 4) return false;
+        uint32_t v =  static_cast<uint32_t>(bytes[i])
+                    | (static_cast<uint32_t>(bytes[i + 1]) << 8)
+                    | (static_cast<uint32_t>(bytes[i + 2]) << 16)
+                    | (static_cast<uint32_t>(bytes[i + 3]) << 24);
+        i += 4;
+        if (v < 0x10000U) return false; // non-canonical
+        size_out = v;
+        return true;
+    }
+
+    // chSize == 255
+    if (n - i < 8) return false;
+    uint64_t v =  static_cast<uint64_t>(bytes[i])
+                | (static_cast<uint64_t>(bytes[i + 1]) << 8)
+                | (static_cast<uint64_t>(bytes[i + 2]) << 16)
+                | (static_cast<uint64_t>(bytes[i + 3]) << 24)
+                | (static_cast<uint64_t>(bytes[i + 4]) << 32)
+                | (static_cast<uint64_t>(bytes[i + 5]) << 40)
+                | (static_cast<uint64_t>(bytes[i + 6]) << 48)
+                | (static_cast<uint64_t>(bytes[i + 7]) << 56);
+    i += 8;
+    if (v < 0x100000000ULL) return false; // non-canonical
+    size_out = v;
+    return true;
+}
+
+/**
+ * segOP TLV helper: write a Bitcoin CompactSize (varint) into a byte vector.
+ */
+inline void SegopWriteCompactSize(std::vector<unsigned char>& out, uint64_t size)
+{
+    if (size < 253) {
+        out.push_back(static_cast<unsigned char>(size));
+    } else if (size <= 0xFFFFULL) {
+        out.push_back(253);
+        out.push_back(static_cast<unsigned char>(size & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 8) & 0xFF));
+    } else if (size <= 0xFFFFFFFFULL) {
+        out.push_back(254);
+        out.push_back(static_cast<unsigned char>(size & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 8) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 16) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 24) & 0xFF));
+    } else {
+        out.push_back(255);
+        out.push_back(static_cast<unsigned char>(size & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 8) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 16) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 24) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 32) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 40) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 48) & 0xFF));
+        out.push_back(static_cast<unsigned char>((size >> 56) & 0xFF));
+    }
+}
+
+/**
+ * Non-consensus segOP TLV helper struct.
+ *
+ * One logical TLV record:
+ *   [type (1 byte)] [length (CompactSize)] [value bytes...]
+ *
+ * This is purely a construction helper; consensus only sees the
+ * final byte vector and validates it with SegopIsValidTLV().
+ */
+struct SegopTlv
+{
+    uint8_t type;
+    std::vector<unsigned char> value;
+};
+
+/**
+ * Build a raw segOP TLV payload from a sequence of SegopTlv items.
+ *
+ * For each item:
+ *   out += type (1 byte)
+ *   out += CompactSize(value.size())
+ *   out += value bytes...
+ */
+inline std::vector<unsigned char> BuildSegopTlvSequence(const std::vector<SegopTlv>& items)
+{
+    std::vector<unsigned char> out;
+    out.reserve(16); // will grow as needed
+
+    for (const auto& item : items) {
+        // 1) type
+        out.push_back(item.type);
+
+        // 2) length as CompactSize
+        SegopWriteCompactSize(out, static_cast<uint64_t>(item.value.size()));
+
+        // 3) value bytes
+        out.insert(out.end(), item.value.begin(), item.value.end());
+    }
+
+    return out;
+}
+
+/**
+ * Validate that a raw segOP payload is a sequence of well-formed TLV
+ * records with 1-byte type, CompactSize length and len bytes of data,
+ * and that we end exactly at the boundary (no trailing slack).
+ *
+ * This enforces canonical CompactSize encoding, so malformed or
+ * non-canonical encodings are rejected at consensus with
+ * bad-txns-segop-tlv.
+ */
+inline bool SegopIsValidTLV(const std::vector<unsigned char>& bytes)
+{
+    size_t i = 0;
+    const size_t n = bytes.size();
+
+    while (i < n) {
+        // Need at least a type byte
+        if (n - i < 1) return false;
+
+        uint8_t t = bytes[i++];
+        (void)t;
+
+        // Read CompactSize length
+        uint64_t len = 0;
+        if (!SegopReadCompactSize(bytes, i, len)) {
+            return false;
+        }
+
+        // Guard against insane lengths / overflow
+        if (len > static_cast<uint64_t>(std::numeric_limits<size_t>::max())) {
+            return false;
+        }
+
+        if (n - i < static_cast<size_t>(len)) {
+            return false; // overrun
+        }
+
+        // Skip value
+        i += static_cast<size_t>(len);
+    }
+
+    // Must end exactly at boundary, no slack
+    return i == n;
+}
+
+/**
+ * Build a basic TLV payload for a UTF-8 text string.
+ *
+ * Layout (spec §6):
+ *   [0x01 = type TEXT_UTF8] [len as CompactSize] [UTF-8 bytes...]
+ *
+ * Implemented in terms of BuildSegopTlvSequence so that single and
+ * multi-TLV payloads use the same encoding logic.
+ */
+inline std::vector<unsigned char> BuildSegopTextTlv(const std::string& text)
+{
+    // Clamp to something safely within the global segOP cap.
+    uint64_t len = text.size();
+    if (len > CSegopPayload::MAX_SEGOP_PAYLOAD_SIZE) {
+        len = CSegopPayload::MAX_SEGOP_PAYLOAD_SIZE;
+    }
+
+    SegopTlv item;
+    item.type = SegopTlvType::TEXT_UTF8;
+    item.value.assign(text.begin(),
+                      text.begin() + static_cast<std::ptrdiff_t>(len));
+
+    std::vector<SegopTlv> items;
+    items.reserve(1);
+    items.push_back(std::move(item));
+
+    return BuildSegopTlvSequence(items);
+}
+
+/**
+ * Convenience helper: build a segOP payload containing multiple
+ * TEXT TLVs (all type 0x01).
+ *
+ * Each entry in `texts` becomes:
+ *   [0x01][len(varint)][UTF-8 bytes...]
+ *
+ * The resulting payload is just their concatenation, which
+ * SegopIsValidTLV() already accepts as a valid TLV sequence.
+ */
+inline std::vector<unsigned char> BuildSegopTextTlvMulti(const std::vector<std::string>& texts)
+{
+    std::vector<SegopTlv> items;
+    items.reserve(texts.size());
+
+    for (const auto& s : texts) {
+        SegopTlv item;
+        item.type = SegopTlvType::TEXT_UTF8;
+        item.value.assign(s.begin(), s.end());
+        items.push_back(std::move(item));
+    }
+
+    return BuildSegopTlvSequence(items);
+}
+
+/**
+ * Build a TLV payload for a UTF-8 JSON string.
+ *
+ * Layout:
+ *   [0x02 = JSON_UTF8] [len as CompactSize] [UTF-8 JSON bytes...]
+ *
+ * Consensus does not validate JSON; this is wallet / tooling sugar.
+ */
+inline std::vector<unsigned char> BuildSegopJsonTlv(const std::string& json_utf8)
+{
+    SegopTlv item;
+    item.type = SegopTlvType::JSON_UTF8;
+    item.value.assign(json_utf8.begin(), json_utf8.end());
+
+    std::vector<SegopTlv> items;
+    items.reserve(1);
+    items.push_back(std::move(item));
+
+    return BuildSegopTlvSequence(items);
+}
+
+/**
+ * Build a TLV payload for an opaque binary blob.
+ *
+ * Layout:
+ *   [0x03 = BINARY_BLOB] [len as CompactSize] [raw bytes...]
+ *
+ * Hex parsing / validation is done at the RPC layer; this helper
+ * expects already-sanitised bytes.
+ */
+inline std::vector<unsigned char> BuildSegopBlobTlv(const std::vector<unsigned char>& blob)
+{
+    SegopTlv item;
+    item.type = SegopTlvType::BINARY_BLOB;
+    item.value = blob; // copy
+
+    std::vector<SegopTlv> items;
+    items.reserve(1);
+    items.push_back(std::move(item));
+
+    return BuildSegopTlvSequence(items);
+}
+
+/**
+ * Build the P2SOP blob used by the segOP commitment output.
+ *
+ * Spec layout:
+ *
+ *   segop_commitment = TAGGED_HASH("segop:commitment", segop_payload_bytes)
+ *   P2SOP_blob       = "P2SOP" || segop_commitment
+ *
+ * The script then is:
+ *
+ *   scriptPubKey = OP_RETURN <len = P2SOP_blob.size()> <P2SOP_blob bytes>
+ */
+inline std::vector<unsigned char> BuildSegopCommitmentBlob(const std::vector<unsigned char>& segop_payload)
+{
+    // BIP340-style tagged hash writer seeded with "segop:commitment".
+    HashWriter hw = TaggedHash("segop:commitment");
+
+    // HashWriter::write expects std::span<const std::byte>.
+    // Convert the vector<unsigned char> to that via MakeUCharSpan + std::as_bytes.
+    hw.write(std::as_bytes(MakeUCharSpan(segop_payload)));
+
+    const uint256 segop_commitment = hw.GetHash();
+
+    // Assemble "P2SOP" || segop_commitment
+    std::vector<unsigned char> blob;
+    blob.reserve(5 + segop_commitment.size());
+
+    blob.push_back('P');
+    blob.push_back('2');
+    blob.push_back('S');
+    blob.push_back('O');
+    blob.push_back('P');
+
+    blob.insert(blob.end(),
+                segop_commitment.begin(),
+                segop_commitment.end());
+
+    return blob;
+}
+
+#endif // BITCOIN_SEGOP_SEGOP_H
diff --git a/src/wallet/rpc/spend.cpp b/src/wallet/rpc/spend.cpp
index d00547a897..1f1bc7d74b 100644
--- a/src/wallet/rpc/spend.cpp
+++ b/src/wallet/rpc/spend.cpp
@@ -1,3 +1,4 @@
+// Copyright (c) 2025 - Defwnwycke - segOP
 // Copyright (c) 2011-2022 The Bitcoin Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
@@ -13,6 +14,7 @@
 #include <rpc/util.h>
 #include <script/script.h>
 #include <util/rbf.h>
+#include <util/strencodings.h>
 #include <util/translation.h>
 #include <util/vector.h>
 #include <wallet/coincontrol.h>
@@ -24,6 +26,9 @@
 
 #include <univalue.h>
 
+#include <segop/segop.h> // segOP
+#include <crypto/sha256.h> //segOP
+
 using common::FeeModeFromString;
 using common::FeeModesDetail;
 using common::InvalidEstimateModeErrorMessage;
@@ -235,6 +240,169 @@ static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const Un
     }
 }
 
+static bool BuildSegopPayloadFromRequest(
+    const std::string& user_payload,
+    const UniValue& options,
+    CSegopPayload& out,
+    std::string& error_out)
+{
+    error_out.clear();
+
+    // 1. Determine segOP version
+    uint8_t version = CSegopPayload::SEGOP_VERSION; // default
+    if (options.exists("version")) {
+        const UniValue& v = options["version"];
+        if (!v.isNum()) {
+            error_out = "\"version\" must be a number in [1,255]";
+            return false;
+        }
+        const int vi = v.getInt<int>();
+        if (vi < 1 || vi > 255) {
+            error_out = "\"version\" must be in [1,255]";
+            return false;
+        }
+        version = static_cast<uint8_t>(vi);
+    }
+
+    // 2. Determine encoding
+    std::string encoding = "text";
+    if (options.exists("encoding")) {
+        const UniValue& e = options["encoding"];
+        if (!e.isStr()) {
+            error_out = "\"encoding\" must be a string";
+            return false;
+        }
+        encoding = e.get_str();
+    }
+
+    // 3. Build TLV payload bytes
+    std::vector<unsigned char> segop_data;
+
+    if (encoding == "text") {
+        // Single TEXT_UTF8 TLV
+        segop_data = BuildSegopTextTlv(user_payload);
+
+    } else if (encoding == "text_multi") {
+        // Multi-TLV TEXT sequence, source is options["texts"] array
+        if (!options.exists("texts")) {
+            error_out = "\"texts\" array is required when encoding=\\\"text_multi\\\"";
+            return false;
+        }
+        const UniValue& arr = options["texts"];
+        if (!arr.isArray()) {
+            error_out = "\"texts\" must be an array of strings";
+            return false;
+        }
+        if (arr.size() == 0) {
+            error_out = "\"texts\" array must not be empty";
+            return false;
+        }
+
+        std::vector<std::string> texts;
+        texts.reserve(arr.size());
+        for (unsigned int i = 0; i < arr.size(); ++i) {
+            const UniValue& v = arr[i];
+            if (!v.isStr()) {
+                error_out = "\"texts\" array entries must all be strings";
+                return false;
+            }
+            texts.push_back(v.get_str());
+        }
+
+        segop_data = BuildSegopTextTlvMulti(texts);
+
+    } else if (encoding == "json") {
+        // JSON_UTF8 TLV (no consensus-level JSON validation)
+        std::string json_str;
+
+        if (options.exists("data")) {
+            const UniValue& d = options["data"];
+            if (d.isStr()) {
+                // Caller gave us a raw JSON string
+                json_str = d.get_str();
+            } else {
+                // Any other UniValue → compact JSON string
+                json_str = d.write();
+            }
+        } else {
+            // Fallback: use the user_payload (3rd arg) as JSON text
+            json_str = user_payload;
+        }
+
+        if (json_str.empty()) {
+            error_out = "JSON encoding requires non-empty \"data\" or payload string";
+            return false;
+        }
+
+        segop_data = BuildSegopJsonTlv(json_str);
+
+    } else if (encoding == "blob") {
+        // BINARY_BLOB TLV from options["data_hex"]
+        if (!options.exists("data_hex")) {
+            error_out = "\"data_hex\" is required when encoding=\\\"blob\\\"";
+            return false;
+        }
+        const UniValue& d = options["data_hex"];
+        if (!d.isStr()) {
+            error_out = "\"data_hex\" must be a hex string";
+            return false;
+        }
+
+        const std::string hex = d.get_str();
+        if (!IsHex(hex)) {
+            error_out = "\"data_hex\" is not valid hex";
+            return false;
+        }
+
+        std::vector<unsigned char> raw = ParseHex(hex);
+        segop_data = BuildSegopBlobTlv(raw);
+
+    } else if (encoding == "hex") {
+        // Backwards-compatible: use the payload string as hex
+        if (!IsHex(user_payload)) {
+            error_out = "Payload is not valid hex";
+            return false;
+        }
+        std::vector<unsigned char> raw = ParseHex(user_payload);
+        segop_data = BuildSegopBlobTlv(raw);
+
+    } else {
+        error_out = "Unsupported segOP encoding";
+        return false;
+    }
+
+
+    // 4. Populate CSegopPayload
+    out.SetNull();
+    out.version = version;
+    out.data    = std::move(segop_data);
+
+    // 5. Size + TLV sanity checks (match consensus helpers)
+    if (out.TooLarge()) {
+        error_out = "segOP payload too large";
+        return false;
+    }
+    if (!SegopIsValidTLV(out.data)) {
+        error_out = "segOP TLV payload is not well-formed";
+        return false;
+    }
+
+    return true;
+}
+
+// Build the P2SOP OP_RETURN script that commits to segOP payload.
+// This must match the consensus expectations in tx_check.cpp:
+//   OP_RETURN 0x23 "SOP" [32-byte commitment]
+static CScript BuildP2SopScript(const CSegopPayload& segop)
+{
+    // Get "SOP" + SHA256(payload) as 35-byte blob
+    std::vector<unsigned char> sop_blob = BuildSegopCommitmentBlob(segop.data);
+
+    CScript script;
+    script << OP_RETURN << sop_blob;
+    return script;
+}
+
 RPCHelpMan sendtoaddress()
 {
     return RPCHelpMan{
@@ -332,7 +500,209 @@ RPCHelpMan sendtoaddress()
 },
     };
 }
+/////////////
+
+RPCHelpMan segopsend()
+{
+    return RPCHelpMan{
+        "segopsend",
+        "Send an amount to a given address with an attached segOP payload.\n"
+        "This is an *experimental* helper for the segOP prototype.\n"
+        "The transaction is fully valid on normal Bitcoin nodes, but only segOP-aware\n"
+        "nodes will recognize and interpret the segOP lane and the P2SOP commitment.\n"
+        + HELP_REQUIRING_PASSPHRASE,
+        {
+            {"address", RPCArg::Type::STR,    RPCArg::Optional::NO,
+             "The bitcoin address to send to."},
+            {"amount",  RPCArg::Type::AMOUNT, RPCArg::Optional::NO,
+             "The amount in " + CURRENCY_UNIT + " to send. eg 0.1"},
+            {"payload", RPCArg::Type::STR,    RPCArg::Optional::NO,
+             "segOP payload as a string. Interpretation is controlled by \"options.encoding\"."},
+            {"options", RPCArg::Type::OBJ,    RPCArg::Optional::OMITTED,
+             "Optional JSON object to modify segOP behaviour:\n"
+             "  \"encoding\" (string): \"text\" (default), \"text_multi\", \"json\" or \"hex\".\n"
+             "  \"version\"  (number): segOP version 1-255 (default 1).\n"
+             "  \"p2sop\"    (bool):   Attach P2SOP commitment output (default true).\n"
+             "  \"texts\"    (array):  For encoding=\"text_multi\", array of strings → multiple 0x01 TLVs.\n"
+             "  \"subtractfeefromamount\" (bool): Subtract fee from the send amount.\n"
+             "  \"replaceable\" (bool): Make the transaction BIP125 replaceable.",
+             {
+                 {"encoding", RPCArg::Type::STR, RPCArg::Optional::OMITTED,
+                  "Payload encoding: \"text\" (default), \"text_multi\", \"json\" or \"hex\"."},
+                 {"version", RPCArg::Type::NUM, RPCArg::Optional::OMITTED,
+                  "segOP version 1-255 (default 1)."},
+                 {"p2sop", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Attach a P2SOP commitment output (default true)."},
+                 {"texts", RPCArg::Type::ARR, RPCArg::Optional::OMITTED,
+                  "For encoding=\"text_multi\": array of UTF-8 strings (each becomes a 0x01 TLV).",
+                  {
+                      {"", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "UTF-8 string element"},
+                  }},
+                 {"subtractfeefromamount", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Subtract the fee from the send amount."},
+                 {"replaceable", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Mark the transaction BIP125 replaceable."},
+             },
+            },
+        },
+        {
+            RPCResult{
+                RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "txid",   "The transaction id."},
+                    {RPCResult::Type::STR_HEX, "hex",    "The raw transaction hex including the segOP lane."},
+                    {RPCResult::Type::NUM,     "amount", "The amount sent in " + CURRENCY_UNIT},
+                    {RPCResult::Type::NUM,     "fee",    "The fee paid in " + CURRENCY_UNIT},
+                    {RPCResult::Type::BOOL,    "complete", "Whether the transaction was fully signed."},
+                }
+            },
+        },
+        RPCExamples{
+            "\nSend 0.1 BTC with a simple text segOP payload (defaults: encoding=\"text\", version=1, p2sop=true):\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"segOP TLV test payload\"") +
+            "\nSend 0.1 BTC with explicit options (text payload, version 1, P2SOP enabled):\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"segOP TLV test payload\" "
+                "'{\"encoding\":\"text\",\"version\":1,\"p2sop\":true}'") +
+            "\nSend 0.1 BTC with multiple TEXT TLVs in one segOP payload:\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"ignored\" "
+                "'{\"encoding\":\"text_multi\",\"texts\":[\"first\",\"second\"],\"version\":1,\"p2sop\":true}'") +
+            "\nSend 0.1 BTC with a hex-encoded segOP blob payload, BIP125-replaceable:\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"534754455354\" "
+                "'{\"encoding\":\"hex\",\"replaceable\":true}'")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+            if (!pwallet) return UniValue::VNULL;
+
+            // Match sendtoaddress: make sure wallet is in sync and unlocked
+            pwallet->BlockUntilSyncedToCurrentChain();
+            EnsureWalletIsUnlocked(*pwallet);
+
+            const std::string dest_str = request.params[0].get_str();
+            const CAmount amount       = AmountFromValue(request.params[1]);
+            const std::string payload  = request.params[2].get_str();
+
+            // Optional 4th param: options object
+            const UniValue options = (request.params.size() > 3 && request.params[3].isObject())
+                ? request.params[3].get_obj()
+                : UniValue(UniValue::VOBJ);
+
+            // Whether to subtract fee from the recipient amount
+            bool subtract_fee = false;
+            if (options.exists("subtractfeefromamount")) {
+                subtract_fee = options["subtractfeefromamount"].get_bool();
+            }
+
+            if (amount <= 0) {
+                throw JSONRPCError(RPC_TYPE_ERROR, "Amount must be positive");
+            }
+
+            const CTxDestination dest = DecodeDestination(dest_str);
+            if (!IsValidDestination(dest)) {
+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address: " + dest_str);
+            }
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+             // Build and validate segOP payload (version + TLVs) via the shared helper.
+            CSegopPayload segop_payload;
+            std::string segop_error;
+            if (!BuildSegopPayloadFromRequest(payload, options, segop_payload, segop_error)) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, segop_error);
+            }
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+            // p2sop flag – must be true in segOP v1
+            bool use_p2sop = true;
+            if (options.exists("p2sop")) {
+                use_p2sop = options["p2sop"].get_bool();
+            }
+            if (!use_p2sop) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER,
+                    "segOP v1 requires a P2SOP commitment output; set \"p2sop\": true");
+            }
+
+            LOCK(pwallet->cs_wallet);
+
+            // Template transaction: MUST have empty vout for FundTransaction
+            CMutableTransaction mtx;
+            mtx.version   = CTransaction::CURRENT_VERSION;
+            mtx.nLockTime = 0;
+
+            CCoinControl coin_control;
+            if (options.exists("replaceable")) {
+                coin_control.m_signal_bip125_rbf = options["replaceable"].get_bool();
+            }
+
+            // Build recipients vector (addresses + amounts) using the same machinery
+            // as sendtoaddress, so FundTransaction can calculate the fee correctly.
+            UniValue address_amounts(UniValue::VOBJ);
+            address_amounts.pushKV(dest_str, request.params[1]); // same JSON amount we already parsed
+
+            std::set<int> sffo_set;
+            if (subtract_fee) {
+                // Subtract fee from the single recipient (index 0)
+                sffo_set.insert(0);
+            }
+
+            std::vector<CRecipient> recipients{CreateRecipients(ParseOutputs(address_amounts), sffo_set)};
+
+            // Fund the transaction using the shared helper. mtx.vout is still empty here,
+            // which matches FundTransaction's assertion requirements.
+            auto res = FundTransaction(*pwallet, mtx, recipients,
+                                       /*change_pos=*/std::nullopt,
+                                       /*lockUnspents=*/false,
+                                       coin_control);
+
+            if (!res) {
+                throw JSONRPCError(RPC_WALLET_ERROR, util::ErrorString(res).original);
+            }
+
+            const wallet::CreatedTransactionResult& txr = *res;
+
+            // Start from the funded (but unsigned) transaction
+            CMutableTransaction mtx_signed(*txr.tx);
+
+            // Append P2SOP OP_RETURN output (0-value) AFTER funding
+            if (use_p2sop) {
+                CScript p2sop_script = BuildP2SopScript(segop_payload);
+                mtx_signed.vout.emplace_back(CAmount{0}, std::move(p2sop_script));
+            }
+
+            // Attach segOP lane AFTER funding so we don't break FundTransaction's assumptions
+            mtx_signed.segop_payload = segop_payload;
+
+            // Sign the transaction in-place
+            if (!pwallet->SignTransaction(mtx_signed)) {
+                throw JSONRPCError(RPC_WALLET_ERROR, "Failed to sign segOP transaction");
+            }
+
+            CTransactionRef tx_ref = MakeTransactionRef(mtx_signed);
+            const CAmount fee_out = txr.fee;
+
+            // Hex of the final transaction (including segOP lane)
+            const std::string hex = EncodeHexTx(*tx_ref);
+
+            // Commit & broadcast
+            mapValue_t map_value;
+            std::vector<std::pair<std::string, std::string>> orderForm;
+            pwallet->CommitTransaction(tx_ref, map_value, orderForm);
+
+            UniValue result(UniValue::VOBJ);
+            result.pushKV("txid", tx_ref->GetHash().GetHex());
+            result.pushKV("hex", hex);
+            result.pushKV("amount", ValueFromAmount(amount));
+            result.pushKV("fee", ValueFromAmount(fee_out));
+            result.pushKV("complete", true);
+            return result;
+        }
+    };
+}
+
 
+////////////////
 RPCHelpMan sendmany()
 {
     return RPCHelpMan{"sendmany",
diff --git a/src/wallet/rpc/spend.cpp.save b/src/wallet/rpc/spend.cpp.save
new file mode 100644
index 0000000000..72b6d1ac60
--- /dev/null
+++ b/src/wallet/rpc/spend.cpp.save
@@ -0,0 +1,2102 @@
+// Copyright (c) 2011-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <common/messages.h>
+#include <consensus/validation.h>
+#include <core_io.h>
+#include <key_io.h>
+#include <node/types.h>
+#include <policy/policy.h>
+#include <policy/truc_policy.h>
+#include <rpc/rawtransaction_util.h>
+#include <rpc/util.h>
+#include <script/script.h>
+#include <util/rbf.h>
+#include <util/strencodings.h>
+#include <util/translation.h>
+#include <util/vector.h>
+#include <wallet/coincontrol.h>
+#include <wallet/feebumper.h>
+#include <wallet/fees.h>
+#include <wallet/rpc/util.h>
+#include <wallet/spend.h>
+#include <wallet/wallet.h>
+
+#include <univalue.h>
+
+#include <segop/segop.h> // segOP
+#include <crypto/sha256.h> //segOP
+
+using common::FeeModeFromString;
+using common::FeeModesDetail;
+using common::InvalidEstimateModeErrorMessage;
+using common::StringForFeeReason;
+using common::TransactionErrorString;
+using node::TransactionError;
+
+namespace wallet {
+std::vector<CRecipient> CreateRecipients(const std::vector<std::pair<CTxDestination, CAmount>>& outputs, const std::set<int>& subtract_fee_outputs)
+{
+    std::vector<CRecipient> recipients;
+    for (size_t i = 0; i < outputs.size(); ++i) {
+        const auto& [destination, amount] = outputs.at(i);
+        CRecipient recipient{destination, amount, subtract_fee_outputs.contains(i)};
+        recipients.push_back(recipient);
+    }
+    return recipients;
+}
+
+static void InterpretFeeEstimationInstructions(const UniValue& conf_target, const UniValue& estimate_mode, const UniValue& fee_rate, UniValue& options)
+{
+    if (options.exists("conf_target") || options.exists("estimate_mode")) {
+        if (!conf_target.isNull() || !estimate_mode.isNull()) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Pass conf_target and estimate_mode either as arguments or in the options object, but not both");
+        }
+    } else {
+        options.pushKV("conf_target", conf_target);
+        options.pushKV("estimate_mode", estimate_mode);
+    }
+    if (options.exists("fee_rate")) {
+        if (!fee_rate.isNull()) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Pass the fee_rate either as an argument, or in the options object, but not both");
+        }
+    } else {
+        options.pushKV("fee_rate", fee_rate);
+    }
+    if (!options["conf_target"].isNull() && (options["estimate_mode"].isNull() || (options["estimate_mode"].get_str() == "unset"))) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Specify estimate_mode");
+    }
+}
+
+std::set<int> InterpretSubtractFeeFromOutputInstructions(const UniValue& sffo_instructions, const std::vector<std::string>& destinations)
+{
+    std::set<int> sffo_set;
+    if (sffo_instructions.isNull()) return sffo_set;
+
+    for (const auto& sffo : sffo_instructions.getValues()) {
+        int pos{-1};
+        if (sffo.isStr()) {
+            auto it = find(destinations.begin(), destinations.end(), sffo.get_str());
+            if (it == destinations.end()) throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter 'subtract fee from output', destination %s not found in tx outputs", sffo.get_str()));
+            pos = it - destinations.begin();
+        } else if (sffo.isNum()) {
+            pos = sffo.getInt<int>();
+        } else {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter 'subtract fee from output', invalid value type: %s", uvTypeName(sffo.type())));
+        }
+
+        if (sffo_set.contains(pos))
+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter 'subtract fee from output', duplicated position: %d", pos));
+        if (pos < 0)
+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter 'subtract fee from output', negative position: %d", pos));
+        if (pos >= int(destinations.size()))
+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter 'subtract fee from output', position too large: %d", pos));
+        sffo_set.insert(pos);
+    }
+    return sffo_set;
+}
+
+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, CMutableTransaction& rawTx)
+{
+    bool can_anti_fee_snipe = !options.exists("locktime");
+
+    for (const CTxIn& tx_in : rawTx.vin) {
+        // Checks sequence values consistent with DiscourageFeeSniping
+        can_anti_fee_snipe = can_anti_fee_snipe && (tx_in.nSequence == CTxIn::MAX_SEQUENCE_NONFINAL || tx_in.nSequence == MAX_BIP125_RBF_SEQUENCE);
+    }
+
+    if (can_anti_fee_snipe) {
+        LOCK(pwallet->cs_wallet);
+        FastRandomContext rng_fast;
+        DiscourageFeeSniping(rawTx, rng_fast, pwallet->chain(), pwallet->GetLastBlockHash(), pwallet->GetLastBlockHeight());
+    }
+
+    // Make a blank psbt
+    PartiallySignedTransaction psbtx(rawTx);
+
+    // First fill transaction with our data without signing,
+    // so external signers are not asked to sign more than once.
+    bool complete;
+    pwallet->FillPSBT(psbtx, complete, std::nullopt, /*sign=*/false, /*bip32derivs=*/true);
+    const auto err{pwallet->FillPSBT(psbtx, complete, std::nullopt, /*sign=*/true, /*bip32derivs=*/false)};
+    if (err) {
+        throw JSONRPCPSBTError(*err);
+    }
+
+    CMutableTransaction mtx;
+    complete = FinalizeAndExtractPSBT(psbtx, mtx);
+
+    UniValue result(UniValue::VOBJ);
+
+    const bool psbt_opt_in{options.exists("psbt") && options["psbt"].get_bool()};
+    bool add_to_wallet{options.exists("add_to_wallet") ? options["add_to_wallet"].get_bool() : true};
+    if (psbt_opt_in || !complete || !add_to_wallet) {
+        // Serialize the PSBT
+        DataStream ssTx{};
+        ssTx << psbtx;
+        result.pushKV("psbt", EncodeBase64(ssTx.str()));
+    }
+
+    if (complete) {
+        std::string hex{EncodeHexTx(CTransaction(mtx))};
+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));
+        result.pushKV("txid", tx->GetHash().GetHex());
+        if (add_to_wallet && !psbt_opt_in) {
+            pwallet->CommitTransaction(tx, {}, /*orderForm=*/{});
+        } else {
+            result.pushKV("hex", hex);
+        }
+    }
+    result.pushKV("complete", complete);
+
+    return result;
+}
+
+static void PreventOutdatedOptions(const UniValue& options)
+{
+    if (options.exists("feeRate")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Use fee_rate (" + CURRENCY_ATOM + "/vB) instead of feeRate");
+    }
+    if (options.exists("changeAddress")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Use change_address instead of changeAddress");
+    }
+    if (options.exists("changePosition")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Use change_position instead of changePosition");
+    }
+    if (options.exists("lockUnspents")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Use lock_unspents instead of lockUnspents");
+    }
+    if (options.exists("subtractFeeFromOutputs")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Use subtract_fee_from_outputs instead of subtractFeeFromOutputs");
+    }
+}
+
+UniValue SendMoney(CWallet& wallet, const CCoinControl &coin_control, std::vector<CRecipient> &recipients, mapValue_t map_value, bool verbose)
+{
+    EnsureWalletIsUnlocked(wallet);
+
+    // This function is only used by sendtoaddress and sendmany.
+    // This should always try to sign, if we don't have private keys, don't try to do anything here.
+    if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {
+        throw JSONRPCError(RPC_WALLET_ERROR, "Error: Private keys are disabled for this wallet");
+    }
+
+    // Shuffle recipient list
+    std::shuffle(recipients.begin(), recipients.end(), FastRandomContext());
+
+    // Send
+    auto res = CreateTransaction(wallet, recipients, /*change_pos=*/std::nullopt, coin_control, true);
+    if (!res) {
+        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, util::ErrorString(res).original);
+    }
+    const CTransactionRef& tx = res->tx;
+    wallet.CommitTransaction(tx, std::move(map_value), /*orderForm=*/{});
+    if (verbose) {
+        UniValue entry(UniValue::VOBJ);
+        entry.pushKV("txid", tx->GetHash().GetHex());
+        entry.pushKV("fee_reason", StringForFeeReason(res->fee_calc.reason));
+        return entry;
+    }
+    return tx->GetHash().GetHex();
+}
+
+
+/**
+ * Update coin control with fee estimation based on the given parameters
+ *
+ * @param[in]     wallet            Wallet reference
+ * @param[in,out] cc                Coin control to be updated
+ * @param[in]     conf_target       UniValue integer; confirmation target in blocks, values between 1 and 1008 are valid per policy/fees.h;
+ * @param[in]     estimate_mode     UniValue string; fee estimation mode, valid values are "unset", "economical" or "conservative";
+ * @param[in]     fee_rate          UniValue real; fee rate in sat/vB;
+ *                                      if present, both conf_target and estimate_mode must either be null, or "unset"
+ * @param[in]     override_min_fee  bool; whether to set fOverrideFeeRate to true to disable minimum fee rate checks and instead
+ *                                      verify only that fee_rate is greater than 0
+ * @throws a JSONRPCError if conf_target, estimate_mode, or fee_rate contain invalid values or are in conflict
+ */
+static void SetFeeEstimateMode(const CWallet& wallet, CCoinControl& cc, const UniValue& conf_target, const UniValue& estimate_mode, const UniValue& fee_rate, bool override_min_fee)
+{
+    if (!fee_rate.isNull()) {
+        if (!conf_target.isNull()) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both conf_target and fee_rate. Please provide either a confirmation target in blocks for automatic fee estimation, or an explicit fee rate.");
+        }
+        if (!estimate_mode.isNull() && estimate_mode.get_str() != "unset") {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both estimate_mode and fee_rate");
+        }
+        // Fee rates in sat/vB cannot represent more than 3 significant digits.
+        cc.m_feerate = CFeeRate{AmountFromValue(fee_rate, /*decimals=*/3)};
+        if (override_min_fee) cc.fOverrideFeeRate = true;
+        // Default RBF to true for explicit fee_rate, if unset.
+        if (!cc.m_signal_bip125_rbf) cc.m_signal_bip125_rbf = true;
+        return;
+    }
+    if (!estimate_mode.isNull() && !FeeModeFromString(estimate_mode.get_str(), cc.m_fee_mode)) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, InvalidEstimateModeErrorMessage());
+    }
+    if (!conf_target.isNull()) {
+        cc.m_confirm_target = ParseConfirmTarget(conf_target, wallet.chain().estimateMaxBlocks());
+    }
+}
+
+// Build a CSegopPayload from the RPC "payload" string and "options" object.
+static bool BuildSegopPayloadFromRequest(const std::string& user_payload,
+                                         const UniValue& options,
+                                         CSegopPayload& out_segop,
+                                         std::string& out_error)
+{
+    out_error.clear();
+    out_segop.SetNull();
+
+    // encoding: "text" (default) or "hex"
+    std::string encoding = "text";
+    if (options.exists("encoding")) {
+        encoding = options["encoding"].get_str();
+    }
+
+    // version: default 1
+    uint8_t version = 1;
+    if (options.exists("version")) {
+        const int v = options["version"].getInt<int>();
+        if (v < 0 || v > 255) {
+            out_error = "segOP version must be between 0 and 255";
+            return false;
+        }
+        version = static_cast<uint8_t>(v);
+    }
+
+    std::vector<unsigned char> data;
+
+    if (encoding == "text") {
+        // Simple TLV encoding for text (see segop.cpp)
+        data = BuildSegopTextTlv(user_payload);
+    } else if (encoding == "hex") {
+        if (!IsHex(user_payload)) {
+            out_error = "segOP payload is not valid hex";
+            return false;
+        }
+        data = ParseHex(user_payload);
+    } else {
+        out_error = "Unsupported segOP encoding: " + encoding;
+        return false;
+    }
+
+    // Size bound must match consensus rule in tx_check.cpp
+    if (data.size() > CSegopPayload::MAX_SEGOP_PAYLOAD_SIZE) {
+        out_error = strprintf("segOP payload too large (%u bytes, max %u)",
+                              static_cast<unsigned int>(data.size()),
+                              static_cast<unsigned int>(CSegopPayload::MAX_SEGOP_PAYLOAD_SIZE));
+        return false;
+    }
+
+    out_segop.version = version;
+    out_segop.data    = std::move(data);
+    return true;
+}
+
+// Build the P2SOP OP_RETURN script that commits to segOP payload.
+// This must match the consensus expectations in tx_check.cpp:
+//   OP_RETURN 0x23 "SOP" [32-byte commitment]
+static CScript BuildP2SopScript(const CSegopPayload& segop)
+{
+    // Get "SOP" + SHA256(payload) as 35-byte blob
+    std::vector<unsigned char> sop_blob = BuildSegopCommitmentBlob(segop.data);
+
+    CScript script;
+    script << OP_RETURN << sop_blob;
+    return script;
+}
+
+RPCHelpMan sendtoaddress()
+{
+    return RPCHelpMan{
+        "sendtoaddress",
+        "Send an amount to a given address." +
+        HELP_REQUIRING_PASSPHRASE,
+                {
+                    {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "The bitcoin address to send to."},
+                    {"amount", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "The amount in " + CURRENCY_UNIT + " to send. eg 0.1"},
+                    {"comment", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A comment used to store what the transaction is for.\n"
+                                         "This is not part of the transaction, just kept in your wallet."},
+                    {"comment_to", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A comment to store the name of the person or organization\n"
+                                         "to which you're sending the transaction. This is not part of the \n"
+                                         "transaction, just kept in your wallet."},
+                    {"subtractfeefromamount", RPCArg::Type::BOOL, RPCArg::Default{false}, "The fee will be deducted from the amount being sent.\n"
+                                         "The recipient will receive less bitcoins than you enter in the amount field."},
+                    {"replaceable", RPCArg::Type::BOOL, RPCArg::DefaultHint{"wallet default"}, "Signal that this transaction can be replaced by a transaction (BIP 125)"},
+                    {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks"},
+                    {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+                      + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used"))},
+                    {"avoid_reuse", RPCArg::Type::BOOL, RPCArg::Default{true}, "(only available if avoid_reuse wallet flag is set) Avoid spending from dirty addresses; addresses are considered\n"
+                                         "dirty if they have previously been used in a transaction. If true, this also activates avoidpartialspends, grouping outputs by their addresses."},
+                    {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+                    {"verbose", RPCArg::Type::BOOL, RPCArg::Default{false}, "If true, return extra information about the transaction."},
+                },
+                {
+                    RPCResult{"if verbose is not set or set to false",
+                        RPCResult::Type::STR_HEX, "txid", "The transaction id."
+                    },
+                    RPCResult{"if verbose is set to true",
+                        RPCResult::Type::OBJ, "", "",
+                        {
+                            {RPCResult::Type::STR_HEX, "txid", "The transaction id."},
+                            {RPCResult::Type::STR, "fee_reason", "The transaction fee reason."}
+                        },
+                    },
+                },
+                RPCExamples{
+                    "\nSend 0.1 BTC\n"
+                    + HelpExampleCli("sendtoaddress", "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1") +
+                    "\nSend 0.1 BTC with a confirmation target of 6 blocks in economical fee estimate mode using positional arguments\n"
+                    + HelpExampleCli("sendtoaddress", "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"donation\" \"sean's outpost\" false true 6 economical") +
+                    "\nSend 0.1 BTC with a fee rate of 1.1 " + CURRENCY_ATOM + "/vB, subtract fee from amount, BIP125-replaceable, using positional arguments\n"
+                    + HelpExampleCli("sendtoaddress", "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"drinks\" \"room77\" true true null \"unset\" null 1.1") +
+                    "\nSend 0.2 BTC with a confirmation target of 6 blocks in economical fee estimate mode using named arguments\n"
+                    + HelpExampleCli("-named sendtoaddress", "address=\"" + EXAMPLE_ADDRESS[0] + "\" amount=0.2 conf_target=6 estimate_mode=\"economical\"") +
+                    "\nSend 0.5 BTC with a fee rate of 25 " + CURRENCY_ATOM + "/vB using named arguments\n"
+                    + HelpExampleCli("-named sendtoaddress", "address=\"" + EXAMPLE_ADDRESS[0] + "\" amount=0.5 fee_rate=25")
+                    + HelpExampleCli("-named sendtoaddress", "address=\"" + EXAMPLE_ADDRESS[0] + "\" amount=0.5 fee_rate=25 subtractfeefromamount=false replaceable=true avoid_reuse=true comment=\"2 pizzas\" comment_to=\"jeremy\" verbose=true")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    pwallet->BlockUntilSyncedToCurrentChain();
+
+    LOCK(pwallet->cs_wallet);
+
+    // Wallet comments
+    mapValue_t mapValue;
+    if (!request.params[2].isNull() && !request.params[2].get_str().empty())
+        mapValue["comment"] = request.params[2].get_str();
+    if (!request.params[3].isNull() && !request.params[3].get_str().empty())
+        mapValue["to"] = request.params[3].get_str();
+
+    CCoinControl coin_control;
+    if (!request.params[5].isNull()) {
+        coin_control.m_signal_bip125_rbf = request.params[5].get_bool();
+    }
+
+    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(*pwallet, request.params[8]);
+    // We also enable partial spend avoidance if reuse avoidance is set.
+    coin_control.m_avoid_partial_spends |= coin_control.m_avoid_address_reuse;
+
+    SetFeeEstimateMode(*pwallet, coin_control, /*conf_target=*/request.params[6], /*estimate_mode=*/request.params[7], /*fee_rate=*/request.params[9], /*override_min_fee=*/false);
+
+    EnsureWalletIsUnlocked(*pwallet);
+
+    UniValue address_amounts(UniValue::VOBJ);
+    const std::string address = request.params[0].get_str();
+    address_amounts.pushKV(address, request.params[1]);
+
+    std::set<int> sffo_set;
+    if (!request.params[4].isNull() && request.params[4].get_bool()) {
+        sffo_set.insert(0);
+    }
+
+    std::vector<CRecipient> recipients{CreateRecipients(ParseOutputs(address_amounts), sffo_set)};
+    const bool verbose{request.params[10].isNull() ? false : request.params[10].get_bool()};
+
+    return SendMoney(*pwallet, coin_control, recipients, mapValue, verbose);
+},
+    };
+}
+/////////////
+RPCHelpMan segopsend()
+{
+    return RPCHelpMan{
+        "segopsend",
+        "Send an amount to a given address with an attached segOP payload.\n"
+        "This is an *experimental* helper for the segOP prototype.\n"
+        "The transaction is fully valid on normal Bitcoin nodes, but only segOP-aware\n"
+        "nodes will recognize and interpret the segOP lane and the P2SOP commitment.\n"
+        + HELP_REQUIRING_PASSPHRASE,
+        {
+            {"address", RPCArg::Type::STR,    RPCArg::Optional::NO,
+             "The bitcoin address to send to."},
+            {"amount",  RPCArg::Type::AMOUNT, RPCArg::Optional::NO,
+             "The amount in " + CURRENCY_UNIT + " to send. eg 0.1"},
+            {"payload", RPCArg::Type::STR,    RPCArg::Optional::NO,
+             "segOP payload as a string. Interpretation is controlled by \"options.encoding\"."},
+                        {"options", RPCArg::Type::OBJ,    RPCArg::Optional::OMITTED,
+             "Optional JSON object to modify segOP behaviour:\n"
+             "  \"encoding\" (string): \"text\" (default) or \"hex\".\n"
+             "  \"version\"  (number): segOP version 1-255 (default 1).\n"
+             "  \"p2sop\"    (bool):   Attach P2SOP commitment output (default true).\n"
+             "  \"subtractfeefromamount\" (bool): Subtract fee from the send amount.\n"
+             "  \"replaceable\" (bool): Make the transaction BIP125 replaceable.",
+             {
+                 {"encoding", RPCArg::Type::STR, RPCArg::Optional::OMITTED,
+                  "Payload encoding: \"text\" (default) or \"hex\"."},
+                 {"version", RPCArg::Type::NUM, RPCArg::Optional::OMITTED,
+                  "segOP version 1-255 (default 1)."},
+                 {"p2sop", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Attach a P2SOP commitment output (default true)."},
+                 {"subtractfeefromamount", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Subtract the fee from the send amount."},
+                 {"replaceable", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED,
+                  "Mark the transaction BIP125 replaceable."},
+             },
+            },
+        },
+        {
+            RPCResult{
+                RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "txid",   "The transaction id."},
+                    {RPCResult::Type::STR_HEX, "hex",    "The raw transaction hex including the segOP lane."},
+                    {RPCResult::Type::NUM,     "amount", "The amount sent in " + CURRENCY_UNIT},
+                    {RPCResult::Type::NUM,     "fee",    "The fee paid in " + CURRENCY_UNIT},
+                    {RPCResult::Type::BOOL,    "complete", "Whether the transaction was fully signed."},
+                }
+            },
+        },
+        RPCExamples{
+            "\nSend 0.1 BTC with a simple text segOP payload (defaults: encoding=\"text\", version=1, p2sop=true):\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"segOP TLV test payload\"") +
+            "\nSend 0.1 BTC with explicit options (text payload, version 1, P2SOP enabled):\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"segOP TLV test payload\" "
+                "'{\"encoding\":\"text\",\"version\":1,\"p2sop\":true}'") +
+            "\nSend 0.1 BTC with a hex-encoded segOP payload, BIP125-replaceable:\n"
+            + HelpExampleCli("segopsend",
+                "\"" + EXAMPLE_ADDRESS[0] + "\" 0.1 \"534754455354\" "
+                "'{\"encoding\":\"hex\",\"replaceable\":true}'")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+            if (!pwallet) return UniValue::VNULL;
+
+            // Match sendtoaddress: make sure wallet is in sync and unlocked
+            pwallet->BlockUntilSyncedToCurrentChain();
+            EnsureWalletIsUnlocked(*pwallet);
+
+            const std::string dest_str = request.params[0].get_str();
+            const CAmount amount       = AmountFromValue(request.params[1]);
+            const std::string payload  = request.params[2].get_str();
+
+            // Optional 4th param: options object
+            const UniValue options = (request.params.size() > 3 && request.params[3].isObject())
+                ? request.params[3].get_obj()
+                : UniValue(UniValue::VOBJ);
+
+            // Whether to subtract fee from the recipient amount
+            bool subtract_fee = false;
+            if (options.exists("subtractfeefromamount")) {
+                subtract_fee = options["subtractfeefromamount"].get_bool();
+            }
+
+            if (amount <= 0) {
+                throw JSONRPCError(RPC_TYPE_ERROR, "Amount must be positive");
+            }
+
+            const CTxDestination dest = DecodeDestination(dest_str);
+            if (!IsValidDestination(dest)) {
+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address: " + dest_str);
+            }
+
+            // Build segOP payload from user string + options
+            CSegopPayload segop_payload;
+            std::string segop_error;
+            if (!BuildSegopPayloadFromRequest(payload, options, segop_payload, segop_error)) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, segop_error);
+            }
+
+            // p2sop flag – must be true in segOP v1
+            bool use_p2sop = true;
+            if (options.exists("p2sop")) {
+                use_p2sop = options["p2sop"].get_bool();
+            }
+            if (!use_p2sop) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER,
+                    "segOP v1 requires a P2SOP commitment output; set \"p2sop\": true");
+            }
+
+            LOCK(pwallet->cs_wallet);
+
+            // Template transaction: MUST have empty vout for FundTransaction
+            CMutableTransaction mtx;
+            mtx.version   = CTransaction::CURRENT_VERSION;
+            mtx.nLockTime = 0;
+
+            CCoinControl coin_control;
+            if (options.exists("replaceable")) {
+                coin_control.m_signal_bip125_rbf = options["replaceable"].get_bool();
+            }
+
+            // Build recipients vector (addresses + amounts) using the same machinery
+            // as sendtoaddress, so FundTransaction can calculate the fee correctly.
+            UniValue address_amounts(UniValue::VOBJ);
+            address_amounts.pushKV(dest_str, request.params[1]); // same amount we already parsed
+
+            std::set<int> sffo_set;
+            if (subtract_fee) {
+                // Subtract fee from the single recipient (index 0)
+                sffo_set.insert(0);
+            }
+
+            std::vector<CRecipient> recipients{CreateRecipients(ParseOutputs(address_amounts), sffo_set)};
+
+            // Fund the transaction using the shared helper. mtx.vout is still empty here,
+            // which matches FundTransaction's assertion requirements.
+            auto res = FundTransaction(*pwallet, mtx, recipients,
+                                       /*change_pos=*/std::nullopt,
+                                       /*lockUnspents=*/false,
+                                       coin_control);
+
+            if (!res) {
+                throw JSONRPCError(RPC_WALLET_ERROR, util::ErrorString(res).original);
+            }
+
+            const wallet::CreatedTransactionResult& txr = *res;
+
+            // Start from the funded (but unsigned) transaction
+            CMutableTransaction mtx_signed(*txr.tx);
+
+            // Append P2SOP OP_RETURN output (0-value) AFTER funding
+            if (use_p2sop) {
+                CScript p2sop_script = BuildP2SopScript(segop_payload);
+                mtx_signed.vout.emplace_back(CAmount{0}, std::move(p2sop_script));
+            }
+
+            // Attach segOP lane AFTER funding so we don't break FundTransaction's assumptions
+            mtx_signed.segop_payload = segop_payload;
+
+            // Sign the transaction in-place
+            if (!pwallet->SignTransaction(mtx_signed)) {
+                throw JSONRPCError(RPC_WALLET_ERROR, "Failed to sign segOP transaction");
+            }
+
+            CTransactionRef tx_ref = MakeTransactionRef(mtx_signed);
+            const CAmount fee_out = txr.fee;
+
+            // Hex of the final transaction (including segOP lane)
+            const std::string hex = EncodeHexTx(*tx_ref);
+
+            // Commit & broadcast
+            mapValue_t map_value;
+            std::vector<std::pair<std::string, std::string>> orderForm;
+            pwallet->CommitTransaction(tx_ref, map_value, orderForm);
+
+            UniValue result(UniValue::VOBJ);
+            result.pushKV("txid", tx_ref->GetHash().GetHex());
+            result.pushKV("hex", hex);
+            result.pushKV("amount", ValueFromAmount(amount));
+            result.pushKV("fee", ValueFromAmount(fee_out));
+            result.pushKV("complete", true);
+            return result;
+        }
+    };
+}
+
+////////////////
+RPCHelpMan sendmany()
+{
+    return RPCHelpMan{"sendmany",
+        "Send multiple times. Amounts are double-precision floating point numbers." +
+        HELP_REQUIRING_PASSPHRASE,
+                {
+                    {"dummy", RPCArg::Type::STR, RPCArg::Default{"\"\""}, "Must be set to \"\" for backwards compatibility.",
+                     RPCArgOptions{
+                         .oneline_description = "\"\"",
+                     }},
+                    {"amounts", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::NO, "The addresses and amounts",
+                        {
+                            {"address", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "The bitcoin address is the key, the numeric amount (can be string) in " + CURRENCY_UNIT + " is the value"},
+                        },
+                    },
+                    {"minconf", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "Ignored dummy value"},
+                    {"comment", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A comment"},
+                    {"subtractfeefrom", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "The addresses.\n"
+                                       "The fee will be equally deducted from the amount of each selected address.\n"
+                                       "Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
+                                       "If no addresses are specified here, the sender pays the fee.",
+                        {
+                            {"address", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "Subtract fee from this address"},
+                        },
+                    },
+                    {"replaceable", RPCArg::Type::BOOL, RPCArg::DefaultHint{"wallet default"}, "Signal that this transaction can be replaced by a transaction (BIP 125)"},
+                    {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks"},
+                    {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+                      + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used"))},
+                    {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+                    {"verbose", RPCArg::Type::BOOL, RPCArg::Default{false}, "If true, return extra information about the transaction."},
+                },
+                {
+                    RPCResult{"if verbose is not set or set to false",
+                        RPCResult::Type::STR_HEX, "txid", "The transaction id for the send. Only 1 transaction is created regardless of\n"
+                "the number of addresses."
+                    },
+                    RPCResult{"if verbose is set to true",
+                        RPCResult::Type::OBJ, "", "",
+                        {
+                            {RPCResult::Type::STR_HEX, "txid", "The transaction id for the send. Only 1 transaction is created regardless of\n"
+                "the number of addresses."},
+                            {RPCResult::Type::STR, "fee_reason", "The transaction fee reason."}
+                        },
+                    },
+                },
+                RPCExamples{
+            "\nSend two amounts to two different addresses:\n"
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.01,\\\"" + EXAMPLE_ADDRESS[1] + "\\\":0.02}\"") +
+            "\nSend two amounts to two different addresses setting the confirmation and comment:\n"
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.01,\\\"" + EXAMPLE_ADDRESS[1] + "\\\":0.02}\" 6 \"testing\"") +
+            "\nSend two amounts to two different addresses, subtract fee from amount:\n"
+            + HelpExampleCli("sendmany", "\"\" \"{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.01,\\\"" + EXAMPLE_ADDRESS[1] + "\\\":0.02}\" 1 \"\" \"[\\\"" + EXAMPLE_ADDRESS[0] + "\\\",\\\"" + EXAMPLE_ADDRESS[1] + "\\\"]\"") +
+            "\nAs a JSON-RPC call\n"
+            + HelpExampleRpc("sendmany", "\"\", {\"" + EXAMPLE_ADDRESS[0] + "\":0.01,\"" + EXAMPLE_ADDRESS[1] + "\":0.02}, 6, \"testing\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    pwallet->BlockUntilSyncedToCurrentChain();
+
+    LOCK(pwallet->cs_wallet);
+
+    if (!request.params[0].isNull() && !request.params[0].get_str().empty()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Dummy value must be set to \"\"");
+    }
+    UniValue sendTo = request.params[1].get_obj();
+
+    mapValue_t mapValue;
+    if (!request.params[3].isNull() && !request.params[3].get_str().empty())
+        mapValue["comment"] = request.params[3].get_str();
+
+    CCoinControl coin_control;
+    if (!request.params[5].isNull()) {
+        coin_control.m_signal_bip125_rbf = request.params[5].get_bool();
+    }
+
+    SetFeeEstimateMode(*pwallet, coin_control, /*conf_target=*/request.params[6], /*estimate_mode=*/request.params[7], /*fee_rate=*/request.params[8], /*override_min_fee=*/false);
+
+    std::vector<CRecipient> recipients = CreateRecipients(
+            ParseOutputs(sendTo),
+            InterpretSubtractFeeFromOutputInstructions(request.params[4], sendTo.getKeys())
+    );
+    const bool verbose{request.params[9].isNull() ? false : request.params[9].get_bool()};
+
+    return SendMoney(*pwallet, coin_control, recipients, std::move(mapValue), verbose);
+},
+    };
+}
+
+RPCHelpMan settxfee()
+{
+    return RPCHelpMan{
+        "settxfee",
+        "(DEPRECATED) Set the transaction fee rate in " + CURRENCY_UNIT + "/kvB for this wallet. Overrides the global -paytxfee command line parameter.\n"
+                "Can be deactivated by passing 0 as the fee. In that case automatic fee selection will be used by default.\n",
+                {
+                    {"amount", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "The transaction fee rate in " + CURRENCY_UNIT + "/kvB"},
+                },
+                RPCResult{
+                    RPCResult::Type::BOOL, "", "Returns true if successful"
+                },
+                RPCExamples{
+                    HelpExampleCli("settxfee", "0.00001")
+            + HelpExampleRpc("settxfee", "0.00001")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    LOCK(pwallet->cs_wallet);
+
+    if (!pwallet->chain().rpcEnableDeprecated("settxfee")) {
+        throw JSONRPCError(RPC_METHOD_DEPRECATED, "settxfee is deprecated and will be fully removed in v31.0."
+        "\nTo use settxfee restart bitcoind with -deprecatedrpc=settxfee.");
+    }
+
+    CAmount nAmount = AmountFromValue(request.params[0]);
+    CFeeRate tx_fee_rate(nAmount, 1000);
+    CFeeRate max_tx_fee_rate(pwallet->m_default_max_tx_fee, 1000);
+    if (tx_fee_rate == CFeeRate(0)) {
+        // automatic selection
+    } else if (tx_fee_rate < pwallet->chain().relayMinFee()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("txfee cannot be less than min relay tx fee (%s)", pwallet->chain().relayMinFee().ToString()));
+    } else if (tx_fee_rate < pwallet->m_min_fee) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("txfee cannot be less than wallet min fee (%s)", pwallet->m_min_fee.ToString()));
+    } else if (tx_fee_rate > max_tx_fee_rate) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("txfee cannot be more than wallet max tx fee (%s)", max_tx_fee_rate.ToString()));
+    }
+
+    pwallet->m_pay_tx_fee = tx_fee_rate;
+    return true;
+},
+    };
+}
+
+
+// Only includes key documentation where the key is snake_case in all RPC methods. MixedCase keys can be added later.
+static std::vector<RPCArg> FundTxDoc(bool solving_data = true)
+{
+    std::vector<RPCArg> args = {
+        {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks", RPCArgOptions{.also_positional = true}},
+        {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+          + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used")), RPCArgOptions{.also_positional = true}},
+        {
+            "replaceable", RPCArg::Type::BOOL, RPCArg::DefaultHint{"wallet default"}, "Marks this transaction as BIP125-replaceable.\n"
+            "Allows this transaction to be replaced by a transaction with higher fees"
+        },
+    };
+    if (solving_data) {
+        args.push_back({"solving_data", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "Keys and scripts needed for producing a final transaction with a dummy signature.\n"
+        "Used for fee estimation during coin selection.",
+            {
+                {
+                    "pubkeys", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Public keys involved in this transaction.",
+                    {
+                        {"pubkey", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "A public key"},
+                    }
+                },
+                {
+                    "scripts", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Scripts involved in this transaction.",
+                    {
+                        {"script", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "A script"},
+                    }
+                },
+                {
+                    "descriptors", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Descriptors that provide solving data for this transaction.",
+                    {
+                        {"descriptor", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A descriptor"},
+                    }
+                },
+            }
+        });
+    }
+    return args;
+}
+
+CreatedTransactionResult FundTransaction(CWallet& wallet, const CMutableTransaction& tx, const std::vector<CRecipient>& recipients, const UniValue& options, CCoinControl& coinControl, bool override_min_fee)
+{
+    // We want to make sure tx.vout is not used now that we are passing outputs as a vector of recipients.
+    // This sets us up to remove tx completely in a future PR in favor of passing the inputs directly.
+    CHECK_NONFATAL(tx.vout.empty());
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    wallet.BlockUntilSyncedToCurrentChain();
+
+    std::optional<unsigned int> change_position;
+    bool lockUnspents = false;
+    if (!options.isNull()) {
+        if (options.type() == UniValue::VBOOL) {
+            // backward compatibility bool only fallback, does nothing
+        } else {
+            RPCTypeCheckObj(options,
+                {
+                    {"add_inputs", UniValueType(UniValue::VBOOL)},
+                    {"include_unsafe", UniValueType(UniValue::VBOOL)},
+                    {"add_to_wallet", UniValueType(UniValue::VBOOL)},
+                    {"changeAddress", UniValueType(UniValue::VSTR)},
+                    {"change_address", UniValueType(UniValue::VSTR)},
+                    {"changePosition", UniValueType(UniValue::VNUM)},
+                    {"change_position", UniValueType(UniValue::VNUM)},
+                    {"change_type", UniValueType(UniValue::VSTR)},
+                    {"includeWatching", UniValueType(UniValue::VBOOL)},
+                    {"include_watching", UniValueType(UniValue::VBOOL)},
+                    {"inputs", UniValueType(UniValue::VARR)},
+                    {"lockUnspents", UniValueType(UniValue::VBOOL)},
+                    {"lock_unspents", UniValueType(UniValue::VBOOL)},
+                    {"locktime", UniValueType(UniValue::VNUM)},
+                    {"fee_rate", UniValueType()}, // will be checked by AmountFromValue() in SetFeeEstimateMode()
+                    {"feeRate", UniValueType()}, // will be checked by AmountFromValue() below
+                    {"psbt", UniValueType(UniValue::VBOOL)},
+                    {"solving_data", UniValueType(UniValue::VOBJ)},
+                    {"subtractFeeFromOutputs", UniValueType(UniValue::VARR)},
+                    {"subtract_fee_from_outputs", UniValueType(UniValue::VARR)},
+                    {"replaceable", UniValueType(UniValue::VBOOL)},
+                    {"conf_target", UniValueType(UniValue::VNUM)},
+                    {"estimate_mode", UniValueType(UniValue::VSTR)},
+                    {"minconf", UniValueType(UniValue::VNUM)},
+                    {"maxconf", UniValueType(UniValue::VNUM)},
+                    {"input_weights", UniValueType(UniValue::VARR)},
+                    {"max_tx_weight", UniValueType(UniValue::VNUM)},
+                },
+                true, true);
+
+            if (options.exists("add_inputs")) {
+                coinControl.m_allow_other_inputs = options["add_inputs"].get_bool();
+            }
+
+            if (options.exists("changeAddress") || options.exists("change_address")) {
+                const std::string change_address_str = (options.exists("change_address") ? options["change_address"] : options["changeAddress"]).get_str();
+                CTxDestination dest = DecodeDestination(change_address_str);
+
+                if (!IsValidDestination(dest)) {
+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Change address must be a valid bitcoin address");
+                }
+
+                coinControl.destChange = dest;
+            }
+
+            if (options.exists("changePosition") || options.exists("change_position")) {
+                int pos = (options.exists("change_position") ? options["change_position"] : options["changePosition"]).getInt<int>();
+                if (pos < 0 || (unsigned int)pos > recipients.size()) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "changePosition out of bounds");
+                }
+                change_position = (unsigned int)pos;
+            }
+
+            if (options.exists("change_type")) {
+                if (options.exists("changeAddress") || options.exists("change_address")) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both change address and address type options");
+                }
+                if (std::optional<OutputType> parsed = ParseOutputType(options["change_type"].get_str())) {
+                    coinControl.m_change_type.emplace(parsed.value());
+                } else {
+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Unknown change type '%s'", options["change_type"].get_str()));
+                }
+            }
+
+            if (options.exists("lockUnspents") || options.exists("lock_unspents")) {
+                lockUnspents = (options.exists("lock_unspents") ? options["lock_unspents"] : options["lockUnspents"]).get_bool();
+            }
+
+            if (options.exists("include_unsafe")) {
+                coinControl.m_include_unsafe_inputs = options["include_unsafe"].get_bool();
+            }
+
+            if (options.exists("feeRate")) {
+                if (options.exists("fee_rate")) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both fee_rate (" + CURRENCY_ATOM + "/vB) and feeRate (" + CURRENCY_UNIT + "/kvB)");
+                }
+                if (options.exists("conf_target")) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both conf_target and feeRate. Please provide either a confirmation target in blocks for automatic fee estimation, or an explicit fee rate.");
+                }
+                if (options.exists("estimate_mode")) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot specify both estimate_mode and feeRate");
+                }
+                coinControl.m_feerate = CFeeRate(AmountFromValue(options["feeRate"]));
+                coinControl.fOverrideFeeRate = true;
+            }
+
+            if (options.exists("replaceable")) {
+                coinControl.m_signal_bip125_rbf = options["replaceable"].get_bool();
+            }
+
+            if (options.exists("minconf")) {
+                coinControl.m_min_depth = options["minconf"].getInt<int>();
+
+                if (coinControl.m_min_depth < 0) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Negative minconf");
+                }
+            }
+
+            if (options.exists("maxconf")) {
+                coinControl.m_max_depth = options["maxconf"].getInt<int>();
+
+                if (coinControl.m_max_depth < coinControl.m_min_depth) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("maxconf can't be lower than minconf: %d < %d", coinControl.m_max_depth, coinControl.m_min_depth));
+                }
+            }
+            SetFeeEstimateMode(wallet, coinControl, options["conf_target"], options["estimate_mode"], options["fee_rate"], override_min_fee);
+        }
+    }
+
+    if (options.exists("solving_data")) {
+        const UniValue solving_data = options["solving_data"].get_obj();
+        if (solving_data.exists("pubkeys")) {
+            for (const UniValue& pk_univ : solving_data["pubkeys"].get_array().getValues()) {
+                const CPubKey pubkey = HexToPubKey(pk_univ.get_str());
+                coinControl.m_external_provider.pubkeys.emplace(pubkey.GetID(), pubkey);
+                // Add witness script for pubkeys
+                const CScript wit_script = GetScriptForDestination(WitnessV0KeyHash(pubkey));
+                coinControl.m_external_provider.scripts.emplace(CScriptID(wit_script), wit_script);
+            }
+        }
+
+        if (solving_data.exists("scripts")) {
+            for (const UniValue& script_univ : solving_data["scripts"].get_array().getValues()) {
+                const std::string& script_str = script_univ.get_str();
+                if (!IsHex(script_str)) {
+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("'%s' is not hex", script_str));
+                }
+                std::vector<unsigned char> script_data(ParseHex(script_str));
+                const CScript script(script_data.begin(), script_data.end());
+                coinControl.m_external_provider.scripts.emplace(CScriptID(script), script);
+            }
+        }
+
+        if (solving_data.exists("descriptors")) {
+            for (const UniValue& desc_univ : solving_data["descriptors"].get_array().getValues()) {
+                const std::string& desc_str  = desc_univ.get_str();
+                FlatSigningProvider desc_out;
+                std::string error;
+                std::vector<CScript> scripts_temp;
+                auto descs = Parse(desc_str, desc_out, error, true);
+                if (descs.empty()) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Unable to parse descriptor '%s': %s", desc_str, error));
+                }
+                for (auto& desc : descs) {
+                    desc->Expand(0, desc_out, scripts_temp, desc_out);
+                }
+                coinControl.m_external_provider.Merge(std::move(desc_out));
+            }
+        }
+    }
+
+    if (options.exists("input_weights")) {
+        for (const UniValue& input : options["input_weights"].get_array().getValues()) {
+            Txid txid = Txid::FromUint256(ParseHashO(input, "txid"));
+
+            const UniValue& vout_v = input.find_value("vout");
+            if (!vout_v.isNum()) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing vout key");
+            }
+            int vout = vout_v.getInt<int>();
+            if (vout < 0) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, vout cannot be negative");
+            }
+
+            const UniValue& weight_v = input.find_value("weight");
+            if (!weight_v.isNum()) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, missing weight key");
+            }
+            int64_t weight = weight_v.getInt<int64_t>();
+            const int64_t min_input_weight = GetTransactionInputWeight(CTxIn());
+            CHECK_NONFATAL(min_input_weight == 165);
+            if (weight < min_input_weight) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, weight cannot be less than 165 (41 bytes (size of outpoint + sequence + empty scriptSig) * 4 (witness scaling factor)) + 1 (empty witness)");
+            }
+            if (weight > MAX_STANDARD_TX_WEIGHT) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid parameter, weight cannot be greater than the maximum standard tx weight of %d", MAX_STANDARD_TX_WEIGHT));
+            }
+
+            coinControl.SetInputWeight(COutPoint(txid, vout), weight);
+        }
+    }
+
+    if (options.exists("max_tx_weight")) {
+        coinControl.m_max_tx_weight = options["max_tx_weight"].getInt<int>();
+    }
+
+    if (tx.version == TRUC_VERSION) {
+        if (!coinControl.m_max_tx_weight.has_value() || coinControl.m_max_tx_weight.value() > TRUC_MAX_WEIGHT) {
+            coinControl.m_max_tx_weight = TRUC_MAX_WEIGHT;
+        }
+    }
+
+    if (recipients.empty())
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "TX must have at least one output");
+
+    auto txr = FundTransaction(wallet, tx, recipients, change_position, lockUnspents, coinControl);
+    if (!txr) {
+        throw JSONRPCError(RPC_WALLET_ERROR, ErrorString(txr).original);
+    }
+    return *txr;
+}
+
+static void SetOptionsInputWeights(const UniValue& inputs, UniValue& options)
+{
+    if (options.exists("input_weights")) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Input weights should be specified in inputs rather than in options.");
+    }
+    if (inputs.size() == 0) {
+        return;
+    }
+    UniValue weights(UniValue::VARR);
+    for (const UniValue& input : inputs.getValues()) {
+        if (input.exists("weight")) {
+            weights.push_back(input);
+        }
+    }
+    options.pushKV("input_weights", std::move(weights));
+}
+
+RPCHelpMan fundrawtransaction()
+{
+    return RPCHelpMan{
+        "fundrawtransaction",
+        "If the transaction has no inputs, they will be automatically selected to meet its out value.\n"
+                "It will add at most one change output to the outputs.\n"
+                "No existing outputs will be modified unless \"subtractFeeFromOutputs\" is specified.\n"
+                "Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\n"
+                "The inputs added will not be signed, use signrawtransactionwithkey\n"
+                "or signrawtransactionwithwallet for that.\n"
+                "All existing inputs must either have their previous output transaction be in the wallet\n"
+                "or be in the UTXO set. Solving data must be provided for non-wallet inputs.\n"
+                "Note that all inputs selected must be of standard form and P2SH scripts must be\n"
+                "in the wallet using importdescriptors (to calculate fees).\n"
+                "You can see whether this is the case by checking the \"solvable\" field in the listunspent output.\n"
+                "Note that if specifying an exact fee rate, the resulting transaction may have a higher fee rate\n"
+                "if the transaction has unconfirmed inputs. This is because the wallet will attempt to make the\n"
+                "entire package have the given fee rate, not the resulting transaction.\n",
+                {
+                    {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The hex string of the raw transaction"},
+                    {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
+                        Cat<std::vector<RPCArg>>(
+                        {
+                            {"add_inputs", RPCArg::Type::BOOL, RPCArg::Default{true}, "For a transaction with existing inputs, automatically include more if they are not enough."},
+                            {"include_unsafe", RPCArg::Type::BOOL, RPCArg::Default{false}, "Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).\n"
+                                                          "Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.\n"
+                                                          "If that happens, you will need to fund the transaction with different inputs and republish it."},
+                            {"minconf", RPCArg::Type::NUM, RPCArg::Default{0}, "If add_inputs is specified, require inputs with at least this many confirmations."},
+                            {"maxconf", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "If add_inputs is specified, require inputs with at most this many confirmations."},
+                            {"changeAddress", RPCArg::Type::STR, RPCArg::DefaultHint{"automatic"}, "The bitcoin address to receive the change"},
+                            {"changePosition", RPCArg::Type::NUM, RPCArg::DefaultHint{"random"}, "The index of the change output"},
+                            {"change_type", RPCArg::Type::STR, RPCArg::DefaultHint{"set by -changetype"}, "The output type to use. Only valid if changeAddress is not specified. Options are " + FormatAllOutputTypes() + "."},
+                            {"includeWatching", RPCArg::Type::BOOL, RPCArg::Default{false}, "(DEPRECATED) No longer used"},
+                            {"lockUnspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
+                            {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+                            {"feeRate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_UNIT + "/kvB."},
+                            {"subtractFeeFromOutputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "The integers.\n"
+                                                          "The fee will be equally deducted from the amount of each specified output.\n"
+                                                          "Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
+                                                          "If no outputs are specified here, the sender pays the fee.",
+                                {
+                                    {"vout_index", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "The zero-based output index, before a change output is added."},
+                                },
+                            },
+                            {"input_weights", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "Inputs and their corresponding weights",
+                                {
+                                    {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                                        {
+                                            {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                                            {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output index"},
+                                            {"weight", RPCArg::Type::NUM, RPCArg::Optional::NO, "The maximum weight for this input, "
+                                                "including the weight of the outpoint and sequence number. "
+                                                "Note that serialized signature sizes are not guaranteed to be consistent, "
+                                                "so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures."
+                                                "Remember to convert serialized sizes to weight units when necessary."},
+                                        },
+                                    },
+                                },
+                             },
+                            {"max_tx_weight", RPCArg::Type::NUM, RPCArg::Default{MAX_STANDARD_TX_WEIGHT}, "The maximum acceptable transaction weight.\n"
+                                                          "Transaction building will fail if this can not be satisfied."},
+                        },
+                        FundTxDoc()),
+                        RPCArgOptions{
+                            .skip_type_check = true,
+                            .oneline_description = "options",
+                        }},
+                    {"iswitness", RPCArg::Type::BOOL, RPCArg::DefaultHint{"depends on heuristic tests"}, "Whether the transaction hex is a serialized witness transaction.\n"
+                        "If iswitness is not present, heuristic tests will be used in decoding.\n"
+                        "If true, only witness deserialization will be tried.\n"
+                        "If false, only non-witness deserialization will be tried.\n"
+                        "This boolean should reflect whether the transaction has inputs\n"
+                        "(e.g. fully valid, or on-chain transactions), if known by the caller."
+                    },
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR_HEX, "hex", "The resulting raw transaction (hex-encoded string)"},
+                        {RPCResult::Type::STR_AMOUNT, "fee", "Fee in " + CURRENCY_UNIT + " the resulting transaction pays"},
+                        {RPCResult::Type::NUM, "changepos", "The position of the added change output, or -1"},
+                    }
+                                },
+                                RPCExamples{
+                            "\nCreate a transaction with no inputs\n"
+                            + HelpExampleCli("createrawtransaction", "\"[]\" \"{\\\"myaddress\\\":0.01}\"") +
+                            "\nAdd sufficient unsigned inputs to meet the output value\n"
+                            + HelpExampleCli("fundrawtransaction", "\"rawtransactionhex\"") +
+                            "\nSign the transaction\n"
+                            + HelpExampleCli("signrawtransactionwithwallet", "\"fundedtransactionhex\"") +
+                            "\nSend the transaction\n"
+                            + HelpExampleCli("sendrawtransaction", "\"signedtransactionhex\"")
+                                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    // parse hex string from parameter
+    CMutableTransaction tx;
+    bool try_witness = request.params[2].isNull() ? true : request.params[2].get_bool();
+    bool try_no_witness = request.params[2].isNull() ? true : !request.params[2].get_bool();
+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+    }
+    UniValue options = request.params[1];
+    std::vector<std::pair<CTxDestination, CAmount>> destinations;
+    for (const auto& tx_out : tx.vout) {
+        CTxDestination dest;
+        ExtractDestination(tx_out.scriptPubKey, dest);
+        destinations.emplace_back(dest, tx_out.nValue);
+    }
+    std::vector<std::string> dummy(destinations.size(), "dummy");
+    std::vector<CRecipient> recipients = CreateRecipients(
+            destinations,
+            InterpretSubtractFeeFromOutputInstructions(options["subtractFeeFromOutputs"], dummy)
+    );
+    CCoinControl coin_control;
+    // Automatically select (additional) coins. Can be overridden by options.add_inputs.
+    coin_control.m_allow_other_inputs = true;
+    // Clear tx.vout since it is not meant to be used now that we are passing outputs directly.
+    // This sets us up for a future PR to completely remove tx from the function signature in favor of passing inputs directly
+    tx.vout.clear();
+    auto txr = FundTransaction(*pwallet, tx, recipients, options, coin_control, /*override_min_fee=*/true);
+
+    UniValue result(UniValue::VOBJ);
+    result.pushKV("hex", EncodeHexTx(*txr.tx));
+    result.pushKV("fee", ValueFromAmount(txr.fee));
+    result.pushKV("changepos", txr.change_pos ? (int)*txr.change_pos : -1);
+
+    return result;
+},
+    };
+}
+
+RPCHelpMan signrawtransactionwithwallet()
+{
+    return RPCHelpMan{
+        "signrawtransactionwithwallet",
+        "Sign inputs for raw transaction (serialized, hex-encoded).\n"
+                "The second optional argument (may be null) is an array of previous transaction outputs that\n"
+                "this transaction depends on but may not yet be in the block chain." +
+        HELP_REQUIRING_PASSPHRASE,
+                {
+                    {"hexstring", RPCArg::Type::STR, RPCArg::Optional::NO, "The transaction hex string"},
+                    {"prevtxs", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "The previous dependent transaction outputs",
+                        {
+                            {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                                {
+                                    {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                                    {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                                    {"scriptPubKey", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The output script"},
+                                    {"redeemScript", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "(required for P2SH) redeem script"},
+                                    {"witnessScript", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "(required for P2WSH or P2SH-P2WSH) witness script"},
+                                    {"amount", RPCArg::Type::AMOUNT, RPCArg::Optional::OMITTED, "(required for Segwit inputs) the amount spent"},
+                                },
+                            },
+                        },
+                    },
+                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type. Must be one of\n"
+            "       \"DEFAULT\"\n"
+            "       \"ALL\"\n"
+            "       \"NONE\"\n"
+            "       \"SINGLE\"\n"
+            "       \"ALL|ANYONECANPAY\"\n"
+            "       \"NONE|ANYONECANPAY\"\n"
+            "       \"SINGLE|ANYONECANPAY\""},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR_HEX, "hex", "The hex-encoded raw transaction with signature(s)"},
+                        {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                        {RPCResult::Type::ARR, "errors", /*optional=*/true, "Script verification errors (if there are any)",
+                        {
+                            {RPCResult::Type::OBJ, "", "",
+                            {
+                                {RPCResult::Type::STR_HEX, "txid", "The hash of the referenced, previous transaction"},
+                                {RPCResult::Type::NUM, "vout", "The index of the output to spent and used as input"},
+                                {RPCResult::Type::ARR, "witness", "",
+                                {
+                                    {RPCResult::Type::STR_HEX, "witness", ""},
+                                }},
+                                {RPCResult::Type::STR_HEX, "scriptSig", "The hex-encoded signature script"},
+                                {RPCResult::Type::NUM, "sequence", "Script sequence number"},
+                                {RPCResult::Type::STR, "error", "Verification or signing error related to the input"},
+                            }},
+                        }},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"")
+            + HelpExampleRpc("signrawtransactionwithwallet", "\"myhex\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    CMutableTransaction mtx;
+    if (!DecodeHexTx(mtx, request.params[0].get_str())) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed. Make sure the tx has at least one input.");
+    }
+
+    // Sign the transaction
+    LOCK(pwallet->cs_wallet);
+    EnsureWalletIsUnlocked(*pwallet);
+
+    // Fetch previous transactions (inputs):
+    std::map<COutPoint, Coin> coins;
+    for (const CTxIn& txin : mtx.vin) {
+        coins[txin.prevout]; // Create empty map entry keyed by prevout.
+    }
+    pwallet->chain().findCoins(coins);
+
+    // Parse the prevtxs array
+    ParsePrevouts(request.params[1], nullptr, coins);
+
+    std::optional<int> nHashType = ParseSighashString(request.params[2]);
+    if (!nHashType) {
+        nHashType = SIGHASH_DEFAULT;
+    }
+
+    // Script verification errors
+    std::map<int, bilingual_str> input_errors;
+
+    bool complete = pwallet->SignTransaction(mtx, coins, *nHashType, input_errors);
+    UniValue result(UniValue::VOBJ);
+    SignTransactionResultToJSON(mtx, complete, coins, input_errors, result);
+    return result;
+},
+    };
+}
+
+// Definition of allowed formats of specifying transaction outputs in
+// `bumpfee`, `psbtbumpfee`, `send` and `walletcreatefundedpsbt` RPCs.
+static std::vector<RPCArg> OutputsDoc()
+{
+    return
+    {
+        {"", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, "",
+            {
+                {"address", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "A key-value pair. The key (string) is the bitcoin address,\n"
+                         "the value (float or string) is the amount in " + CURRENCY_UNIT + ""},
+            },
+        },
+        {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+            {
+                {"data", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "A key-value pair. The key must be \"data\", the value is hex-encoded data that becomes a part of an OP_RETURN output"},
+            },
+        },
+    };
+}
+
+static RPCHelpMan bumpfee_helper(std::string method_name)
+{
+    const bool want_psbt = method_name == "psbtbumpfee";
+    const std::string incremental_fee{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE).ToString(FeeEstimateMode::SAT_VB)};
+
+    return RPCHelpMan{method_name,
+        "Bumps the fee of a transaction T, replacing it with a new transaction B.\n"
+        + std::string(want_psbt ? "Returns a PSBT instead of creating and signing a new transaction.\n" : "") +
+        "A transaction with the given txid must be in the wallet.\n"
+        "The command will pay the additional fee by reducing change outputs or adding inputs when necessary.\n"
+        "It may add a new change output if one does not already exist.\n"
+        "All inputs in the original transaction will be included in the replacement transaction.\n"
+        "The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\n"
+        "By default, the new fee will be calculated automatically using the estimatesmartfee RPC.\n"
+        "The user can specify a confirmation target for estimatesmartfee.\n"
+        "Alternatively, the user can specify a fee rate in " + CURRENCY_ATOM + "/vB for the new transaction.\n"
+        "At a minimum, the new fee rate must be high enough to pay an additional new relay fee (incrementalfee\n"
+        "returned by getnetworkinfo) to enter the node's mempool.\n"
+        "* WARNING: before version 0.21, fee_rate was in " + CURRENCY_UNIT + "/kvB. As of 0.21, fee_rate is in " + CURRENCY_ATOM + "/vB. *\n",
+        {
+            {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The txid to be bumped"},
+            {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
+                {
+                    {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks\n"},
+                    {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"},
+                             "\nSpecify a fee rate in " + CURRENCY_ATOM + "/vB instead of relying on the built-in fee estimator.\n"
+                             "Must be at least " + incremental_fee + " higher than the current transaction fee rate.\n"
+                             "WARNING: before version 0.21, fee_rate was in " + CURRENCY_UNIT + "/kvB. As of 0.21, fee_rate is in " + CURRENCY_ATOM + "/vB.\n"},
+                    {"replaceable", RPCArg::Type::BOOL, RPCArg::Default{true},
+                             "Whether the new transaction should be\n"
+                             "marked bip-125 replaceable. If true, the sequence numbers in the transaction will\n"
+                             "be set to 0xfffffffd. If false, any input sequence numbers in the\n"
+                             "transaction will be set to 0xfffffffe\n"
+                             "so the new transaction will not be explicitly bip-125 replaceable (though it may\n"
+                             "still be replaceable in practice, for example if it has unconfirmed ancestors which\n"
+                             "are replaceable).\n"},
+                    {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+                              + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used"))},
+                    {"outputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "The outputs specified as key-value pairs.\n"
+                             "Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.\n"
+                             "At least one output of either type must be specified.\n"
+                             "Cannot be provided if 'original_change_index' is specified.",
+                        OutputsDoc(),
+                        RPCArgOptions{.skip_type_check = true}},
+                    {"original_change_index", RPCArg::Type::NUM, RPCArg::DefaultHint{"not set, detect change automatically"}, "The 0-based index of the change output on the original transaction. "
+                                                                                                                            "The indicated output will be recycled into the new change output on the bumped transaction. "
+                                                                                                                            "The remainder after paying the recipients and fees will be sent to the output script of the "
+                                                                                                                            "original change output. The change output’s amount can increase if bumping the transaction "
+                                                                                                                            "adds new inputs, otherwise it will decrease. Cannot be used in combination with the 'outputs' option."},
+                },
+                RPCArgOptions{.oneline_description="options"}},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "", Cat(
+                want_psbt ?
+                std::vector<RPCResult>{{RPCResult::Type::STR, "psbt", "The base64-encoded unsigned PSBT of the new transaction."}} :
+                std::vector<RPCResult>{{RPCResult::Type::STR_HEX, "txid", "The id of the new transaction."}},
+            {
+                {RPCResult::Type::STR_AMOUNT, "origfee", "The fee of the replaced transaction."},
+                {RPCResult::Type::STR_AMOUNT, "fee", "The fee of the new transaction."},
+                {RPCResult::Type::ARR, "errors", "Errors encountered during processing (may be empty).",
+                {
+                    {RPCResult::Type::STR, "", ""},
+                }},
+            })
+        },
+        RPCExamples{
+    "\nBump the fee, get the new transaction\'s " + std::string(want_psbt ? "psbt" : "txid") + "\n" +
+            HelpExampleCli(method_name, "<txid>")
+        },
+        [want_psbt](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !pwallet->IsWalletFlagSet(WALLET_FLAG_EXTERNAL_SIGNER) && !want_psbt) {
+        throw JSONRPCError(RPC_WALLET_ERROR, "bumpfee is not available with wallets that have private keys disabled. Use psbtbumpfee instead.");
+    }
+
+    Txid hash{Txid::FromUint256(ParseHashV(request.params[0], "txid"))};
+
+    CCoinControl coin_control;
+    // optional parameters
+    coin_control.m_signal_bip125_rbf = true;
+    std::vector<CTxOut> outputs;
+
+    std::optional<uint32_t> original_change_index;
+
+    if (!request.params[1].isNull()) {
+        UniValue options = request.params[1];
+        RPCTypeCheckObj(options,
+            {
+                {"confTarget", UniValueType(UniValue::VNUM)},
+                {"conf_target", UniValueType(UniValue::VNUM)},
+                {"fee_rate", UniValueType()}, // will be checked by AmountFromValue() in SetFeeEstimateMode()
+                {"replaceable", UniValueType(UniValue::VBOOL)},
+                {"estimate_mode", UniValueType(UniValue::VSTR)},
+                {"outputs", UniValueType()}, // will be checked by AddOutputs()
+                {"original_change_index", UniValueType(UniValue::VNUM)},
+            },
+            true, true);
+
+        if (options.exists("confTarget") && options.exists("conf_target")) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "confTarget and conf_target options should not both be set. Use conf_target (confTarget is deprecated).");
+        }
+
+        auto conf_target = options.exists("confTarget") ? options["confTarget"] : options["conf_target"];
+
+        if (options.exists("replaceable")) {
+            coin_control.m_signal_bip125_rbf = options["replaceable"].get_bool();
+        }
+        SetFeeEstimateMode(*pwallet, coin_control, conf_target, options["estimate_mode"], options["fee_rate"], /*override_min_fee=*/false);
+
+        // Prepare new outputs by creating a temporary tx and calling AddOutputs().
+        if (!options["outputs"].isNull()) {
+            if (options["outputs"].isArray() && options["outputs"].empty()) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, output argument cannot be an empty array");
+            }
+            CMutableTransaction tempTx;
+            AddOutputs(tempTx, options["outputs"]);
+            outputs = tempTx.vout;
+        }
+
+        if (options.exists("original_change_index")) {
+            original_change_index = options["original_change_index"].getInt<uint32_t>();
+        }
+    }
+
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    pwallet->BlockUntilSyncedToCurrentChain();
+
+    LOCK(pwallet->cs_wallet);
+
+    EnsureWalletIsUnlocked(*pwallet);
+
+
+    std::vector<bilingual_str> errors;
+    CAmount old_fee;
+    CAmount new_fee;
+    CMutableTransaction mtx;
+    feebumper::Result res;
+    // Targeting feerate bump.
+    res = feebumper::CreateRateBumpTransaction(*pwallet, hash, coin_control, errors, old_fee, new_fee, mtx, /*require_mine=*/ !want_psbt, outputs, original_change_index);
+    if (res != feebumper::Result::OK) {
+        switch(res) {
+            case feebumper::Result::INVALID_ADDRESS_OR_KEY:
+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errors[0].original);
+                break;
+            case feebumper::Result::INVALID_REQUEST:
+                throw JSONRPCError(RPC_INVALID_REQUEST, errors[0].original);
+                break;
+            case feebumper::Result::INVALID_PARAMETER:
+                throw JSONRPCError(RPC_INVALID_PARAMETER, errors[0].original);
+                break;
+            case feebumper::Result::WALLET_ERROR:
+                throw JSONRPCError(RPC_WALLET_ERROR, errors[0].original);
+                break;
+            default:
+                throw JSONRPCError(RPC_MISC_ERROR, errors[0].original);
+                break;
+        }
+    }
+
+    UniValue result(UniValue::VOBJ);
+
+    // For bumpfee, return the new transaction id.
+    // For psbtbumpfee, return the base64-encoded unsigned PSBT of the new transaction.
+    if (!want_psbt) {
+        if (!feebumper::SignTransaction(*pwallet, mtx)) {
+            if (pwallet->IsWalletFlagSet(WALLET_FLAG_EXTERNAL_SIGNER)) {
+                throw JSONRPCError(RPC_WALLET_ERROR, "Transaction incomplete. Try psbtbumpfee instead.");
+            }
+            throw JSONRPCError(RPC_WALLET_ERROR, "Can't sign transaction.");
+        }
+
+        Txid txid;
+        if (feebumper::CommitTransaction(*pwallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {
+            throw JSONRPCError(RPC_WALLET_ERROR, errors[0].original);
+        }
+
+        result.pushKV("txid", txid.GetHex());
+    } else {
+        PartiallySignedTransaction psbtx(mtx);
+        bool complete = false;
+        const auto err{pwallet->FillPSBT(psbtx, complete, std::nullopt, /*sign=*/false, /*bip32derivs=*/true)};
+        CHECK_NONFATAL(!err);
+        CHECK_NONFATAL(!complete);
+        DataStream ssTx{};
+        ssTx << psbtx;
+        result.pushKV("psbt", EncodeBase64(ssTx.str()));
+    }
+
+    result.pushKV("origfee", ValueFromAmount(old_fee));
+    result.pushKV("fee", ValueFromAmount(new_fee));
+    UniValue result_errors(UniValue::VARR);
+    for (const bilingual_str& error : errors) {
+        result_errors.push_back(error.original);
+    }
+    result.pushKV("errors", std::move(result_errors));
+
+    return result;
+},
+    };
+}
+
+RPCHelpMan bumpfee() { return bumpfee_helper("bumpfee"); }
+RPCHelpMan psbtbumpfee() { return bumpfee_helper("psbtbumpfee"); }
+
+RPCHelpMan send()
+{
+    return RPCHelpMan{
+        "send",
+        "EXPERIMENTAL warning: this call may be changed in future releases.\n"
+        "\nSend a transaction.\n",
+        {
+            {"outputs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The outputs specified as key-value pairs.\n"
+                    "Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.\n"
+                    "At least one output of either type must be specified.\n"
+                    "For convenience, a dictionary, which holds the key-value pairs directly, is also accepted.",
+                OutputsDoc(),
+                RPCArgOptions{.skip_type_check = true}},
+            {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks"},
+            {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+              + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used"))},
+            {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+            {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
+                Cat<std::vector<RPCArg>>(
+                {
+                    {"add_inputs", RPCArg::Type::BOOL, RPCArg::DefaultHint{"false when \"inputs\" are specified, true otherwise"},"Automatically include coins from the wallet to cover the target amount.\n"},
+                    {"include_unsafe", RPCArg::Type::BOOL, RPCArg::Default{false}, "Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).\n"
+                                                          "Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.\n"
+                                                          "If that happens, you will need to fund the transaction with different inputs and republish it."},
+                    {"minconf", RPCArg::Type::NUM, RPCArg::Default{0}, "If add_inputs is specified, require inputs with at least this many confirmations."},
+                    {"maxconf", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "If add_inputs is specified, require inputs with at most this many confirmations."},
+                    {"add_to_wallet", RPCArg::Type::BOOL, RPCArg::Default{true}, "When false, returns a serialized transaction which will not be added to the wallet or broadcast"},
+                    {"change_address", RPCArg::Type::STR, RPCArg::DefaultHint{"automatic"}, "The bitcoin address to receive the change"},
+                    {"change_position", RPCArg::Type::NUM, RPCArg::DefaultHint{"random"}, "The index of the change output"},
+                    {"change_type", RPCArg::Type::STR, RPCArg::DefaultHint{"set by -changetype"}, "The output type to use. Only valid if change_address is not specified. Options are " + FormatAllOutputTypes() + "."},
+                    {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB.", RPCArgOptions{.also_positional = true}},
+                    {"include_watching", RPCArg::Type::BOOL, RPCArg::Default{"false"}, "(DEPRECATED) No longer used"},
+                    {"inputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Specify inputs instead of adding them automatically.",
+                        {
+                          {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "", {
+                            {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                            {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                            {"sequence", RPCArg::Type::NUM, RPCArg::DefaultHint{"depends on the value of the 'replaceable' and 'locktime' arguments"}, "The sequence number"},
+                            {"weight", RPCArg::Type::NUM, RPCArg::DefaultHint{"Calculated from wallet and solving data"}, "The maximum weight for this input, "
+                                        "including the weight of the outpoint and sequence number. "
+                                        "Note that signature sizes are not guaranteed to be consistent, "
+                                        "so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures."
+                                        "Remember to convert serialized sizes to weight units when necessary."},
+                          }},
+                        },
+                    },
+                    {"locktime", RPCArg::Type::NUM, RPCArg::DefaultHint{"locktime close to block height to prevent fee sniping"}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+                    {"lock_unspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
+                    {"psbt", RPCArg::Type::BOOL,  RPCArg::DefaultHint{"automatic"}, "Always return a PSBT, implies add_to_wallet=false."},
+                    {"subtract_fee_from_outputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Outputs to subtract the fee from, specified as integer indices.\n"
+                    "The fee will be equally deducted from the amount of each specified output.\n"
+                    "Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
+                    "If no outputs are specified here, the sender pays the fee.",
+                        {
+                            {"vout_index", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "The zero-based output index, before a change output is added."},
+                        },
+                    },
+                    {"max_tx_weight", RPCArg::Type::NUM, RPCArg::Default{MAX_STANDARD_TX_WEIGHT}, "The maximum acceptable transaction weight.\n"
+                                                  "Transaction building will fail if this can not be satisfied."},
+                },
+                FundTxDoc()),
+                RPCArgOptions{.oneline_description="options"}},
+                {"version", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_WALLET_TX_VERSION}, "Transaction version"},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                    {RPCResult::Type::STR_HEX, "txid", /*optional=*/true, "The transaction id for the send. Only 1 transaction is created regardless of the number of addresses."},
+                    {RPCResult::Type::STR_HEX, "hex", /*optional=*/true, "If add_to_wallet is false, the hex-encoded raw transaction with signature(s)"},
+                    {RPCResult::Type::STR, "psbt", /*optional=*/true, "If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction"}
+                }
+        },
+        RPCExamples{""
+        "\nSend 0.1 BTC with a confirmation target of 6 blocks in economical fee estimate mode\n"
+        + HelpExampleCli("send", "'{\"" + EXAMPLE_ADDRESS[0] + "\": 0.1}' 6 economical\n") +
+        "Send 0.2 BTC with a fee rate of 1.1 " + CURRENCY_ATOM + "/vB using positional arguments\n"
+        + HelpExampleCli("send", "'{\"" + EXAMPLE_ADDRESS[0] + "\": 0.2}' null \"unset\" 1.1\n") +
+        "Send 0.2 BTC with a fee rate of 1 " + CURRENCY_ATOM + "/vB using the options argument\n"
+        + HelpExampleCli("send", "'{\"" + EXAMPLE_ADDRESS[0] + "\": 0.2}' null \"unset\" null '{\"fee_rate\": 1}'\n") +
+        "Send 0.3 BTC with a fee rate of 25 " + CURRENCY_ATOM + "/vB using named arguments\n"
+        + HelpExampleCli("-named send", "outputs='{\"" + EXAMPLE_ADDRESS[0] + "\": 0.3}' fee_rate=25\n") +
+        "Create a transaction that should confirm the next block, with a specific input, and return result without adding to wallet or broadcasting to the network\n"
+        + HelpExampleCli("send", "'{\"" + EXAMPLE_ADDRESS[0] + "\": 0.1}' 1 economical '{\"add_to_wallet\": false, \"inputs\": [{\"txid\":\"a08e6907dbbd3d809776dbfc5d82e371b764ed838b5655e72f463568df1aadf0\", \"vout\":1}]}'")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+            if (!pwallet) return UniValue::VNULL;
+
+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};
+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);
+            PreventOutdatedOptions(options);
+
+
+            bool rbf{options.exists("replaceable") ? options["replaceable"].get_bool() : pwallet->m_signal_rbf};
+            UniValue outputs(UniValue::VOBJ);
+            outputs = NormalizeOutputs(request.params[0]);
+            std::vector<CRecipient> recipients = CreateRecipients(
+                    ParseOutputs(outputs),
+                    InterpretSubtractFeeFromOutputInstructions(options["subtract_fee_from_outputs"], outputs.getKeys())
+            );
+            CCoinControl coin_control;
+            coin_control.m_version = self.Arg<uint32_t>("version");
+            CMutableTransaction rawTx = ConstructTransaction(options["inputs"], request.params[0], options["locktime"], rbf, coin_control.m_version);
+            // Automatically select coins, unless at least one is manually selected. Can
+            // be overridden by options.add_inputs.
+            coin_control.m_allow_other_inputs = rawTx.vin.size() == 0;
+            if (options.exists("max_tx_weight")) {
+                coin_control.m_max_tx_weight = options["max_tx_weight"].getInt<int>();
+            }
+
+            SetOptionsInputWeights(options["inputs"], options);
+            // Clear tx.vout since it is not meant to be used now that we are passing outputs directly.
+            // This sets us up for a future PR to completely remove tx from the function signature in favor of passing inputs directly
+            rawTx.vout.clear();
+            auto txr = FundTransaction(*pwallet, rawTx, recipients, options, coin_control, /*override_min_fee=*/false);
+
+            CMutableTransaction tx = CMutableTransaction(*txr.tx);
+            return FinishTransaction(pwallet, options, tx);
+        }
+    };
+}
+
+RPCHelpMan sendall()
+{
+    return RPCHelpMan{"sendall",
+        "EXPERIMENTAL warning: this call may be changed in future releases.\n"
+        "\nSpend the value of all (or specific) confirmed UTXOs and unconfirmed change in the wallet to one or more recipients.\n"
+        "Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\n"
+        "If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\n",
+        {
+            {"recipients", RPCArg::Type::ARR, RPCArg::Optional::NO, "The sendall destinations. Each address may only appear once.\n"
+                "Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\n",
+                {
+                    {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "A bitcoin address which receives an equal share of the unspecified amount."},
+                    {"", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, "",
+                        {
+                            {"address", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in " + CURRENCY_UNIT + ""},
+                        },
+                    },
+                },
+            },
+            {"conf_target", RPCArg::Type::NUM, RPCArg::DefaultHint{"wallet -txconfirmtarget"}, "Confirmation target in blocks"},
+            {"estimate_mode", RPCArg::Type::STR, RPCArg::Default{"unset"}, "The fee estimate mode, must be one of (case insensitive):\n"
+              + FeeModesDetail(std::string("economical mode is used if the transaction is replaceable;\notherwise, conservative mode is used"))},
+            {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+            {
+                "options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
+                Cat<std::vector<RPCArg>>(
+                    {
+                        {"add_to_wallet", RPCArg::Type::BOOL, RPCArg::Default{true}, "When false, returns the serialized transaction without broadcasting or adding it to the wallet"},
+                        {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB.", RPCArgOptions{.also_positional = true}},
+                        {"include_watching", RPCArg::Type::BOOL, RPCArg::Default{false}, "(DEPRECATED) No longer used"},
+                        {"inputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with the send_max, minconf, and maxconf options.",
+                            {
+                                {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                                    {
+                                        {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                                        {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                                        {"sequence", RPCArg::Type::NUM, RPCArg::DefaultHint{"depends on the value of the 'replaceable' and 'locktime' arguments"}, "The sequence number"},
+                                    },
+                                },
+                            },
+                        },
+                        {"locktime", RPCArg::Type::NUM, RPCArg::DefaultHint{"locktime close to block height to prevent fee sniping"}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+                        {"lock_unspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
+                        {"psbt", RPCArg::Type::BOOL,  RPCArg::DefaultHint{"automatic"}, "Always return a PSBT, implies add_to_wallet=false."},
+                        {"send_max", RPCArg::Type::BOOL, RPCArg::Default{false}, "When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs."},
+                        {"minconf", RPCArg::Type::NUM, RPCArg::Default{0}, "Require inputs with at least this many confirmations."},
+                        {"maxconf", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "Require inputs with at most this many confirmations."},
+                        {"version", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_WALLET_TX_VERSION}, "Transaction version"},
+                    },
+                    FundTxDoc()
+                ),
+                RPCArgOptions{.oneline_description="options"}
+            },
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                    {RPCResult::Type::STR_HEX, "txid", /*optional=*/true, "The transaction id for the send. Only 1 transaction is created regardless of the number of addresses."},
+                    {RPCResult::Type::STR_HEX, "hex", /*optional=*/true, "If add_to_wallet is false, the hex-encoded raw transaction with signature(s)"},
+                    {RPCResult::Type::STR, "psbt", /*optional=*/true, "If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction"}
+                }
+        },
+        RPCExamples{""
+        "\nSpend all UTXOs from the wallet with a fee rate of 1 " + CURRENCY_ATOM + "/vB using named arguments\n"
+        + HelpExampleCli("-named sendall", "recipients='[\"" + EXAMPLE_ADDRESS[0] + "\"]' fee_rate=1\n") +
+        "Spend all UTXOs with a fee rate of 1.1 " + CURRENCY_ATOM + "/vB using positional arguments\n"
+        + HelpExampleCli("sendall", "'[\"" + EXAMPLE_ADDRESS[0] + "\"]' null \"unset\" 1.1\n") +
+        "Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 " + CURRENCY_ATOM + "/vB using the options argument\n"
+        + HelpExampleCli("sendall", "'[\"" + EXAMPLE_ADDRESS[0] + "\", \"" + EXAMPLE_ADDRESS[1] + "\"]' null \"unset\" null '{\"fee_rate\": 1.5}'\n") +
+        "Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 " + CURRENCY_ATOM + "/vB using the options argument\n"
+        + HelpExampleCli("sendall", "'[\"" + EXAMPLE_ADDRESS[0] + "\"]' null \"unset\" null '{\"fee_rate\": 10, \"send_max\": true}'\n") +
+        "Spend all UTXOs with a fee rate of 1.3 " + CURRENCY_ATOM + "/vB using named arguments and sending a 0.25 " + CURRENCY_UNIT + " to another recipient\n"
+        + HelpExampleCli("-named sendall", "recipients='[{\"" + EXAMPLE_ADDRESS[1] + "\": 0.25}, \""+ EXAMPLE_ADDRESS[0] + "\"]' fee_rate=1.3\n")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};
+            if (!pwallet) return UniValue::VNULL;
+            // Make sure the results are valid at least up to the most recent block
+            // the user could have gotten from another RPC command prior to now
+            pwallet->BlockUntilSyncedToCurrentChain();
+
+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};
+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);
+            PreventOutdatedOptions(options);
+
+
+            std::set<std::string> addresses_without_amount;
+            UniValue recipient_key_value_pairs(UniValue::VARR);
+            const UniValue& recipients{request.params[0]};
+            for (unsigned int i = 0; i < recipients.size(); ++i) {
+                const UniValue& recipient{recipients[i]};
+                if (recipient.isStr()) {
+                    UniValue rkvp(UniValue::VOBJ);
+                    rkvp.pushKV(recipient.get_str(), 0);
+                    recipient_key_value_pairs.push_back(std::move(rkvp));
+                    addresses_without_amount.insert(recipient.get_str());
+                } else {
+                    recipient_key_value_pairs.push_back(recipient);
+                }
+            }
+
+            if (addresses_without_amount.size() == 0) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Must provide at least one address without a specified amount");
+            }
+
+            CCoinControl coin_control;
+
+            SetFeeEstimateMode(*pwallet, coin_control, options["conf_target"], options["estimate_mode"], options["fee_rate"], /*override_min_fee=*/false);
+
+            if (options.exists("minconf")) {
+                if (options["minconf"].getInt<int>() < 0)
+                {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid minconf (minconf cannot be negative): %s", options["minconf"].getInt<int>()));
+                }
+
+                coin_control.m_min_depth = options["minconf"].getInt<int>();
+            }
+
+            if (options.exists("maxconf")) {
+                coin_control.m_max_depth = options["maxconf"].getInt<int>();
+
+                if (coin_control.m_max_depth < coin_control.m_min_depth) {
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("maxconf can't be lower than minconf: %d < %d", coin_control.m_max_depth, coin_control.m_min_depth));
+                }
+            }
+
+            if (options.exists("version")) {
+                coin_control.m_version = options["version"].getInt<int>();
+            }
+
+            if (coin_control.m_version == TRUC_VERSION) {
+                coin_control.m_max_tx_weight = TRUC_MAX_WEIGHT;
+            } else {
+                coin_control.m_max_tx_weight = MAX_STANDARD_TX_WEIGHT;
+            }
+
+            const bool rbf{options.exists("replaceable") ? options["replaceable"].get_bool() : pwallet->m_signal_rbf};
+
+            FeeCalculation fee_calc_out;
+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};
+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly
+            // provided one
+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {
+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Fee rate (%s) is lower than the minimum fee rate setting (%s)", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));
+            }
+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {
+                // eventually allow a fallback fee
+                throw JSONRPCError(RPC_WALLET_ERROR, "Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.");
+            }
+
+            CMutableTransaction rawTx{ConstructTransaction(options["inputs"], recipient_key_value_pairs, options["locktime"], rbf, coin_control.m_version)};
+            LOCK(pwallet->cs_wallet);
+
+            CAmount total_input_value(0);
+            bool send_max{options.exists("send_max") ? options["send_max"].get_bool() : false};
+            if (options.exists("inputs") && options.exists("send_max")) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot combine send_max with specific inputs.");
+            } else if (options.exists("inputs") && (options.exists("minconf") || options.exists("maxconf"))) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Cannot combine minconf or maxconf with specific inputs.");
+            } else if (options.exists("inputs")) {
+                for (const CTxIn& input : rawTx.vin) {
+                    if (pwallet->IsSpent(input.prevout)) {
+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input not available. UTXO (%s:%d) was already spent.", input.prevout.hash.ToString(), input.prevout.n));
+                    }
+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};
+                    if (!tx || input.prevout.n >= tx->tx->vout.size() || !pwallet->IsMine(tx->tx->vout[input.prevout.n])) {
+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input not found. UTXO (%s:%d) is not part of wallet.", input.prevout.hash.ToString(), input.prevout.n));
+                    }
+                    if (pwallet->GetTxDepthInMainChain(*tx) == 0) {
+                        if (tx->tx->version == TRUC_VERSION && coin_control.m_version != TRUC_VERSION) {
+                            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Can't spend unconfirmed version 3 pre-selected input with a version %d tx", coin_control.m_version));
+                        } else if (coin_control.m_version == TRUC_VERSION && tx->tx->version != TRUC_VERSION) {
+                            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Can't spend unconfirmed version %d pre-selected input with a version 3 tx", tx->tx->version));
+                        }
+                    }
+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;
+                }
+            } else {
+                CoinFilterParams coins_params;
+                coins_params.min_amount = 0;
+                for (const COutput& output : AvailableCoins(*pwallet, &coin_control, fee_rate, coins_params).All()) {
+                    if (send_max && fee_rate.GetFee(output.input_bytes) > output.txout.nValue) {
+                        continue;
+                    }
+                    // we are spending an unconfirmed TRUC transaction, so lower max weight
+                    if (output.depth == 0 && coin_control.m_version == TRUC_VERSION) {
+                        coin_control.m_max_tx_weight = TRUC_CHILD_MAX_WEIGHT;
+                    }
+                    CTxIn input(output.outpoint.hash, output.outpoint.n, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);
+                    rawTx.vin.push_back(input);
+                    total_input_value += output.txout.nValue;
+                }
+            }
+
+            std::vector<COutPoint> outpoints_spent;
+            outpoints_spent.reserve(rawTx.vin.size());
+
+            for (const CTxIn& tx_in : rawTx.vin) {
+                outpoints_spent.push_back(tx_in.prevout);
+            }
+
+            // estimate final size of tx
+            const TxSize tx_size{CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get())};
+            if (tx_size.vsize == -1) {
+                throw JSONRPCError(RPC_WALLET_ERROR, "Unable to determine the size of the transaction, the wallet contains unsolvable descriptors");
+            }
+            const CAmount fee_from_size{fee_rate.GetFee(tx_size.vsize)};
+            const std::optional<CAmount> total_bump_fees{pwallet->chain().calculateCombinedBumpFee(outpoints_spent, fee_rate)};
+            CAmount effective_value = total_input_value - fee_from_size - total_bump_fees.value_or(0);
+
+            if (fee_from_size > pwallet->m_default_max_tx_fee) {
+                throw JSONRPCError(RPC_WALLET_ERROR, TransactionErrorString(TransactionError::MAX_FEE_EXCEEDED).original);
+            }
+
+            if (effective_value <= 0) {
+                if (send_max) {
+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Total value of UTXO pool too low to pay for transaction, try using lower feerate.");
+                } else {
+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.");
+                }
+            }
+
+            // If this transaction is too large, e.g. because the wallet has many UTXOs, it will be rejected by the node's mempool.
+            if (tx_size.weight > coin_control.m_max_tx_weight) {
+                throw JSONRPCError(RPC_WALLET_ERROR, "Transaction too large.");
+            }
+
+            CAmount output_amounts_claimed{0};
+            for (const CTxOut& out : rawTx.vout) {
+                output_amounts_claimed += out.nValue;
+            }
+
+            if (output_amounts_claimed > total_input_value) {
+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Assigned more value to outputs than available funds.");
+            }
+
+            const CAmount remainder{effective_value - output_amounts_claimed};
+            if (remainder < 0) {
+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Insufficient funds for fees after creating specified outputs.");
+            }
+
+            const CAmount per_output_without_amount{remainder / (long)addresses_without_amount.size()};
+
+            bool gave_remaining_to_first{false};
+            for (CTxOut& out : rawTx.vout) {
+                CTxDestination dest;
+                ExtractDestination(out.scriptPubKey, dest);
+                std::string addr{EncodeDestination(dest)};
+                if (addresses_without_amount.count(addr) > 0) {
+                    out.nValue = per_output_without_amount;
+                    if (!gave_remaining_to_first) {
+                        out.nValue += remainder % addresses_without_amount.size();
+                        gave_remaining_to_first = true;
+                    }
+                    if (IsDust(out, pwallet->chain().relayDustFee())) {
+                        // Dynamically generated output amount is dust
+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Dynamically assigned remainder results in dust output.");
+                    }
+                } else {
+                    if (IsDust(out, pwallet->chain().relayDustFee())) {
+                        // Specified output amount is dust
+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Specified output amount to %s is below dust threshold.", addr));
+                    }
+                }
+            }
+
+            const bool lock_unspents{options.exists("lock_unspents") ? options["lock_unspents"].get_bool() : false};
+            if (lock_unspents) {
+                for (const CTxIn& txin : rawTx.vin) {
+                    pwallet->LockCoin(txin.prevout, /*persist=*/false);
+                }
+            }
+
+            return FinishTransaction(pwallet, options, rawTx);
+        }
+    };
+}
+
+RPCHelpMan walletprocesspsbt()
+{
+    return RPCHelpMan{
+        "walletprocesspsbt",
+        "Update a PSBT with input information from our wallet and then sign inputs\n"
+                "that we can sign for." +
+        HELP_REQUIRING_PASSPHRASE,
+                {
+                    {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "The transaction base64 string"},
+                    {"sign", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also sign the transaction when updating (requires wallet to be unlocked)"},
+                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type to sign with if not specified by the PSBT. Must be one of\n"
+            "       \"DEFAULT\"\n"
+            "       \"ALL\"\n"
+            "       \"NONE\"\n"
+            "       \"SINGLE\"\n"
+            "       \"ALL|ANYONECANPAY\"\n"
+            "       \"NONE|ANYONECANPAY\"\n"
+            "       \"SINGLE|ANYONECANPAY\""},
+                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible"},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR, "psbt", "The base64-encoded partially signed transaction"},
+                        {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                        {RPCResult::Type::STR_HEX, "hex", /*optional=*/true, "The hex-encoded network transaction if complete"},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("walletprocesspsbt", "\"psbt\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    const CWallet& wallet{*pwallet};
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    wallet.BlockUntilSyncedToCurrentChain();
+
+    // Unserialize the transaction
+    PartiallySignedTransaction psbtx;
+    std::string error;
+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+    }
+
+    // Get the sighash type
+    std::optional<int> nHashType = ParseSighashString(request.params[2]);
+
+    // Fill transaction with our data and also sign
+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();
+    bool bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
+    bool finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
+    bool complete = true;
+
+    if (sign) EnsureWalletIsUnlocked(*pwallet);
+
+    const auto err{wallet.FillPSBT(psbtx, complete, nHashType, sign, bip32derivs, nullptr, finalize)};
+    if (err) {
+        throw JSONRPCPSBTError(*err);
+    }
+
+    UniValue result(UniValue::VOBJ);
+    DataStream ssTx{};
+    ssTx << psbtx;
+    result.pushKV("psbt", EncodeBase64(ssTx.str()));
+    result.pushKV("complete", complete);
+    if (complete) {
+        CMutableTransaction mtx;
+        // Returns true if complete, which we already think it is.
+        CHECK_NONFATAL(FinalizeAndExtractPSBT(psbtx, mtx));
+        DataStream ssTx_final;
+        ssTx_final << TX_WITH_WITNESS(mtx);
+        result.pushKV("hex", HexStr(ssTx_final));
+    }
+
+    return result;
+},
+    };
+}
+
+RPCHelpMan walletcreatefundedpsbt()
+{
+    return RPCHelpMan{
+        "walletcreatefundedpsbt",
+        "Creates and funds a transaction in the Partially Signed Transaction format.\n"
+                "Implements the Creator and Updater roles.\n"
+                "All existing inputs must either have their previous output transaction be in the wallet\n"
+                "or be in the UTXO set. Solving data must be provided for non-wallet inputs.\n",
+                {
+                    {"inputs", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "Leave empty to add inputs automatically. See add_inputs option.",
+                        {
+                            {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                                {
+                                    {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                                    {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                                    {"sequence", RPCArg::Type::NUM, RPCArg::DefaultHint{"depends on the value of the 'locktime' and 'options.replaceable' arguments"}, "The sequence number"},
+                                    {"weight", RPCArg::Type::NUM, RPCArg::DefaultHint{"Calculated from wallet and solving data"}, "The maximum weight for this input, "
+                                        "including the weight of the outpoint and sequence number. "
+                                        "Note that signature sizes are not guaranteed to be consistent, "
+                                        "so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures."
+                                        "Remember to convert serialized sizes to weight units when necessary."},
+                                },
+                            },
+                        },
+                        },
+                    {"outputs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The outputs specified as key-value pairs.\n"
+                            "Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.\n"
+                            "At least one output of either type must be specified.\n"
+                            "For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n"
+                            "accepted as second parameter.",
+                        OutputsDoc(),
+                        RPCArgOptions{.skip_type_check = true}},
+                    {"locktime", RPCArg::Type::NUM, RPCArg::Default{0}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+                    {"options", RPCArg::Type::OBJ_NAMED_PARAMS, RPCArg::Optional::OMITTED, "",
+                        Cat<std::vector<RPCArg>>(
+                        {
+                            {"add_inputs", RPCArg::Type::BOOL, RPCArg::DefaultHint{"false when \"inputs\" are specified, true otherwise"}, "Automatically include coins from the wallet to cover the target amount.\n"},
+                            {"include_unsafe", RPCArg::Type::BOOL, RPCArg::Default{false}, "Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).\n"
+                                                          "Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.\n"
+                                                          "If that happens, you will need to fund the transaction with different inputs and republish it."},
+                            {"minconf", RPCArg::Type::NUM, RPCArg::Default{0}, "If add_inputs is specified, require inputs with at least this many confirmations."},
+                            {"maxconf", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "If add_inputs is specified, require inputs with at most this many confirmations."},
+                            {"changeAddress", RPCArg::Type::STR, RPCArg::DefaultHint{"automatic"}, "The bitcoin address to receive the change"},
+                            {"changePosition", RPCArg::Type::NUM, RPCArg::DefaultHint{"random"}, "The index of the change output"},
+                            {"change_type", RPCArg::Type::STR, RPCArg::DefaultHint{"set by -changetype"}, "The output type to use. Only valid if changeAddress is not specified. Options are " + FormatAllOutputTypes() + "."},
+                            {"includeWatching", RPCArg::Type::BOOL, RPCArg::Default{false}, "(DEPRECATED) No longer used"},
+                            {"lockUnspents", RPCArg::Type::BOOL, RPCArg::Default{false}, "Lock selected unspent outputs"},
+                            {"fee_rate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_ATOM + "/vB."},
+                            {"feeRate", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{"not set, fall back to wallet fee estimation"}, "Specify a fee rate in " + CURRENCY_UNIT + "/kvB."},
+                            {"subtractFeeFromOutputs", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, "The outputs to subtract the fee from.\n"
+                                                          "The fee will be equally deducted from the amount of each specified output.\n"
+                                                          "Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
+                                                          "If no outputs are specified here, the sender pays the fee.",
+                                {
+                                    {"vout_index", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, "The zero-based output index, before a change output is added."},
+                                },
+                            },
+                            {"max_tx_weight", RPCArg::Type::NUM, RPCArg::Default{MAX_STANDARD_TX_WEIGHT}, "The maximum acceptable transaction weight.\n"
+                                                          "Transaction building will fail if this can not be satisfied."},
+                        },
+                        FundTxDoc()),
+                        RPCArgOptions{.oneline_description="options"}},
+                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"version", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_WALLET_TX_VERSION}, "Transaction version"},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR, "psbt", "The resulting raw transaction (base64-encoded string)"},
+                        {RPCResult::Type::STR_AMOUNT, "fee", "Fee in " + CURRENCY_UNIT + " the resulting transaction pays"},
+                        {RPCResult::Type::NUM, "changepos", "The position of the added change output, or -1"},
+                    }
+                                },
+                                RPCExamples{
+                            "\nCreate a PSBT with automatically picked inputs that sends 0.5 BTC to an address and has a fee rate of 2 sat/vB:\n"
+                            + HelpExampleCli("walletcreatefundedpsbt", "\"[]\" \"[{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.5}]\" 0 \"{\\\"add_inputs\\\":true,\\\"fee_rate\\\":2}\"")
+                            + "\nCreate the same PSBT as the above one instead using named arguments:\n"
+                            + HelpExampleCli("-named walletcreatefundedpsbt", "outputs=\"[{\\\"" + EXAMPLE_ADDRESS[0] + "\\\":0.5}]\" add_inputs=true fee_rate=2")
+                                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);
+    if (!pwallet) return UniValue::VNULL;
+
+    CWallet& wallet{*pwallet};
+    // Make sure the results are valid at least up to the most recent block
+    // the user could have gotten from another RPC command prior to now
+    wallet.BlockUntilSyncedToCurrentChain();
+
+    UniValue options{request.params[3].isNull() ? UniValue::VOBJ : request.params[3]};
+
+    CCoinControl coin_control;
+    coin_control.m_version = self.Arg<uint32_t>("version");
+
+    const UniValue &replaceable_arg = options["replaceable"];
+    const bool rbf{replaceable_arg.isNull() ? wallet.m_signal_rbf : replaceable_arg.get_bool()};
+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf, coin_control.m_version);
+    UniValue outputs(UniValue::VOBJ);
+    outputs = NormalizeOutputs(request.params[1]);
+    std::vector<CRecipient> recipients = CreateRecipients(
+            ParseOutputs(outputs),
+            InterpretSubtractFeeFromOutputInstructions(options["subtractFeeFromOutputs"], outputs.getKeys())
+    );
+    // Automatically select coins, unless at least one is manually selected. Can
+    // be overridden by options.add_inputs.
+    coin_control.m_allow_other_inputs = rawTx.vin.size() == 0;
+    SetOptionsInputWeights(request.params[0], options);
+    // Clear tx.vout since it is not meant to be used now that we are passing outputs directly.
+    // This sets us up for a future PR to completely remove tx from the function signature in favor of passing inputs directly
+    rawTx.vout.clear();
+    auto txr = FundTransaction(wallet, rawTx, recipients, options, coin_control, /*override_min_fee=*/true);
+
+    // Make a blank psbt
+    PartiallySignedTransaction psbtx(CMutableTransaction(*txr.tx));
+
+    // Fill transaction with out data but don't sign
+    bool bip32derivs = request.params[4].isNull() ? true : request.params[4].get_bool();
+    bool complete = true;
+    const auto err{wallet.FillPSBT(psbtx, complete, std::nullopt, /*sign=*/false, /*bip32derivs=*/bip32derivs)};
+    if (err) {
+        throw JSONRPCPSBTError(*err);
+    }
+
+    // Serialize the PSBT
+    DataStream ssTx{};
+    ssTx << psbtx;
+
+    UniValue result(UniValue::VOBJ);
+    result.pushKV("psbt", EncodeBase64(ssTx.str()));
+    result.pushKV("fee", ValueFromAmount(txr.fee));
+    result.pushKV("changepos", txr.change_pos ? (int)*txr.change_pos : -1);
+    return result;
+},
+    };
+}
+} // namespace wallet
diff --git a/src/wallet/rpc/wallet.cpp b/src/wallet/rpc/wallet.cpp
index 8e1cec5565..860257d820 100644
--- a/src/wallet/rpc/wallet.cpp
+++ b/src/wallet/rpc/wallet.cpp
@@ -882,6 +882,7 @@ RPCHelpMan encryptwallet();
 
 // spend
 RPCHelpMan sendtoaddress();
+RPCHelpMan segopsend();
 RPCHelpMan sendmany();
 RPCHelpMan settxfee();
 RPCHelpMan fundrawtransaction();
@@ -952,6 +953,7 @@ std::span<const CRPCCommand> GetWalletRPCCommands()
         {"wallet", &send},
         {"wallet", &sendmany},
         {"wallet", &sendtoaddress},
+        {"wallet", &segopsend},
         {"wallet", &setlabel},
         {"wallet", &settxfee},
         {"wallet", &setwalletflag},
diff --git a/src_v1/filelist.txt b/src_v1/filelist.txt
new file mode 100644
index 0000000000..fae17e4ae5
--- /dev/null
+++ b/src_v1/filelist.txt
@@ -0,0 +1,11 @@
+src/CMakeLists.txt
+src/consensus/consensus.h
+src/consensus/tx_check.cpp
+src/core_read.cpp
+src/core_write.cpp
+src/primitives/transaction.cpp
+src/primitives/transaction.h
+src/rpc/rawtransaction.cpp
+src/segop/CMakeLists.txt
+src/segop/segop.cpp
+src/segop/segop.h
diff --git a/src_v1/filelist_tracked.txt b/src_v1/filelist_tracked.txt
new file mode 100644
index 0000000000..40a36c4b6b
--- /dev/null
+++ b/src_v1/filelist_tracked.txt
@@ -0,0 +1,8 @@
+src/CMakeLists.txt
+src/consensus/consensus.h
+src/consensus/tx_check.cpp
+src/core_read.cpp
+src/core_write.cpp
+src/primitives/transaction.cpp
+src/primitives/transaction.h
+src/rpc/rawtransaction.cpp
diff --git a/src_v1/filelist_untracked.txt b/src_v1/filelist_untracked.txt
new file mode 100644
index 0000000000..44696dd177
--- /dev/null
+++ b/src_v1/filelist_untracked.txt
@@ -0,0 +1,6 @@
+src/segop/CMakeLists.txt
+src/segop/segop.cpp
+src/segop/segop.h
+src_v1/filelist.txt
+src_v1/filelist_tracked.txt
+src_v1/filelist_untracked.txt
diff --git a/src_v1/src/CMakeLists.txt b/src_v1/src/CMakeLists.txt
new file mode 100644
index 0000000000..3d6cb15293
--- /dev/null
+++ b/src_v1/src/CMakeLists.txt
@@ -0,0 +1,443 @@
+# Copyright (c) 2023-present The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or https://opensource.org/license/mit/.
+
+include(AddWindowsResources)
+
+configure_file(${PROJECT_SOURCE_DIR}/cmake/bitcoin-build-config.h.in bitcoin-build-config.h USE_SOURCE_PERMISSIONS @ONLY)
+include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
+
+#=============================
+# Subprojects
+#=============================
+# Subprojects include subdirectories that do or could have tests
+# and/or benchmark binaries, such as all subtrees and univalue.
+# These need to be included before CMAKE_*_OUTPUT_DIRECTORY variables
+# are set, so output locations of subproject tests and libraries are
+# not overridden.
+include(../cmake/crc32c.cmake)
+include(../cmake/leveldb.cmake)
+include(../cmake/minisketch.cmake)
+add_subdirectory(univalue)
+if (ENABLE_IPC AND NOT WITH_EXTERNAL_LIBMULTIPROCESS)
+  include(../cmake/libmultiprocess.cmake)
+  add_libmultiprocess(ipc/libmultiprocess)
+endif()
+include(../cmake/secp256k1.cmake)
+add_secp256k1(secp256k1)
+
+# Set top-level target output locations.
+if(NOT CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
+endif()
+if(NOT CMAKE_LIBRARY_OUTPUT_DIRECTORY)
+  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+endif()
+if(NOT CMAKE_ARCHIVE_OUTPUT_DIRECTORY)
+  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+endif()
+
+add_custom_target(generate_build_info
+  BYPRODUCTS ${PROJECT_BINARY_DIR}/src/bitcoin-build-info.h
+  COMMAND ${CMAKE_COMMAND} -DBUILD_INFO_HEADER_PATH=${PROJECT_BINARY_DIR}/src/bitcoin-build-info.h -DSOURCE_DIR=${PROJECT_SOURCE_DIR} -P ${PROJECT_SOURCE_DIR}/cmake/script/GenerateBuildInfo.cmake
+  COMMENT "Generating bitcoin-build-info.h"
+  VERBATIM
+)
+add_library(bitcoin_clientversion STATIC EXCLUDE_FROM_ALL
+  clientversion.cpp
+)
+target_link_libraries(bitcoin_clientversion
+  PRIVATE
+    core_interface
+)
+add_dependencies(bitcoin_clientversion generate_build_info)
+
+add_subdirectory(crypto)
+add_subdirectory(util)
+if(ENABLE_IPC)
+  add_subdirectory(ipc)
+endif()
+
+add_library(bitcoin_consensus STATIC EXCLUDE_FROM_ALL
+  arith_uint256.cpp
+  consensus/merkle.cpp
+  consensus/tx_check.cpp
+  hash.cpp
+  primitives/block.cpp
+  primitives/transaction.cpp
+  pubkey.cpp
+  script/interpreter.cpp
+  script/script.cpp
+  script/script_error.cpp
+  uint256.cpp
+)
+target_link_libraries(bitcoin_consensus
+  PRIVATE
+    core_interface
+    bitcoin_crypto
+    secp256k1
+)
+
+if(WITH_ZMQ)
+  add_subdirectory(zmq)
+endif()
+
+# Home for common functionality shared by different executables and libraries.
+# Similar to `bitcoin_util` library, but higher-level.
+add_library(bitcoin_common STATIC EXCLUDE_FROM_ALL
+  addresstype.cpp
+  base58.cpp
+  bech32.cpp
+  chain.cpp
+  chainparams.cpp
+  chainparamsbase.cpp
+  coins.cpp
+  common/args.cpp
+  common/bloom.cpp
+  common/config.cpp
+  common/init.cpp
+  common/interfaces.cpp
+  common/messages.cpp
+  common/netif.cpp
+  common/pcp.cpp
+  common/run_command.cpp
+  common/settings.cpp
+  common/signmessage.cpp
+  common/system.cpp
+  common/url.cpp
+  compressor.cpp
+  core_read.cpp
+  core_write.cpp
+  deploymentinfo.cpp
+  external_signer.cpp
+  init/common.cpp
+  kernel/chainparams.cpp
+  key.cpp
+  key_io.cpp
+  merkleblock.cpp
+  musig.cpp
+  net_permissions.cpp
+  net_types.cpp
+  netaddress.cpp
+  netbase.cpp
+  outputtype.cpp
+  policy/feerate.cpp
+  policy/policy.cpp
+  pow.cpp
+  protocol.cpp
+  psbt.cpp
+  rpc/rawtransaction_util.cpp
+  rpc/request.cpp
+  rpc/util.cpp
+  scheduler.cpp
+  script/descriptor.cpp
+  script/miniscript.cpp
+  script/parsing.cpp
+  script/sign.cpp
+  script/signingprovider.cpp
+  script/solver.cpp
+)
+target_link_libraries(bitcoin_common
+  PRIVATE
+    core_interface
+    bitcoin_consensus
+    bitcoin_util
+    univalue
+    secp256k1
+    Boost::headers
+    $<TARGET_NAME_IF_EXISTS:USDT::headers>
+    $<$<PLATFORM_ID:Windows>:ws2_32>
+)
+
+include(InstallBinaryComponent)
+
+if(ENABLE_WALLET)
+  add_subdirectory(wallet)
+
+  if(BUILD_WALLET_TOOL)
+    add_executable(bitcoin-wallet
+      bitcoin-wallet.cpp
+      init/bitcoin-wallet.cpp
+      wallet/wallettool.cpp
+    )
+    add_windows_resources(bitcoin-wallet bitcoin-wallet-res.rc)
+    add_windows_application_manifest(bitcoin-wallet)
+    target_link_libraries(bitcoin-wallet
+      core_interface
+      bitcoin_wallet
+      bitcoin_common
+      bitcoin_util
+      Boost::headers
+    )
+    install_binary_component(bitcoin-wallet HAS_MANPAGE)
+  endif()
+endif()
+
+
+# P2P and RPC server functionality used by `bitcoind` and `bitcoin-qt` executables.
+add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL
+  addrdb.cpp
+  addrman.cpp
+  banman.cpp
+  bip324.cpp
+  blockencodings.cpp
+  blockfilter.cpp
+  consensus/tx_verify.cpp
+  dbwrapper.cpp
+  deploymentstatus.cpp
+  flatfile.cpp
+  headerssync.cpp
+  httprpc.cpp
+  httpserver.cpp
+  i2p.cpp
+  index/base.cpp
+  index/blockfilterindex.cpp
+  index/coinstatsindex.cpp
+  index/txindex.cpp
+  init.cpp
+  kernel/chain.cpp
+  kernel/checks.cpp
+  kernel/coinstats.cpp
+  kernel/context.cpp
+  kernel/cs_main.cpp
+  kernel/disconnected_transactions.cpp
+  kernel/mempool_removal_reason.cpp
+  mapport.cpp
+  net.cpp
+  net_processing.cpp
+  netgroup.cpp
+  node/abort.cpp
+  node/blockmanager_args.cpp
+  node/blockstorage.cpp
+  node/caches.cpp
+  node/chainstate.cpp
+  node/chainstatemanager_args.cpp
+  node/coin.cpp
+  node/coins_view_args.cpp
+  node/connection_types.cpp
+  node/context.cpp
+  node/database_args.cpp
+  node/eviction.cpp
+  node/interface_ui.cpp
+  node/interfaces.cpp
+  node/kernel_notifications.cpp
+  node/mempool_args.cpp
+  node/mempool_persist.cpp
+  node/mempool_persist_args.cpp
+  node/miner.cpp
+  node/mini_miner.cpp
+  node/minisketchwrapper.cpp
+  node/peerman_args.cpp
+  node/psbt.cpp
+  node/timeoffsets.cpp
+  node/transaction.cpp
+  node/txdownloadman_impl.cpp
+  node/txorphanage.cpp
+  node/txreconciliation.cpp
+  node/utxo_snapshot.cpp
+  node/warnings.cpp
+  noui.cpp
+  policy/ephemeral_policy.cpp
+  policy/fees.cpp
+  policy/fees_args.cpp
+  policy/packages.cpp
+  policy/rbf.cpp
+  policy/settings.cpp
+  policy/truc_policy.cpp
+  rest.cpp
+  rpc/blockchain.cpp
+  rpc/external_signer.cpp
+  rpc/fees.cpp
+  rpc/mempool.cpp
+  rpc/mining.cpp
+  rpc/net.cpp
+  rpc/node.cpp
+  rpc/output_script.cpp
+  rpc/rawtransaction.cpp
+  rpc/server.cpp
+  rpc/server_util.cpp
+  rpc/signmessage.cpp
+  rpc/txoutproof.cpp
+  script/sigcache.cpp
+  signet.cpp
+  torcontrol.cpp
+  txdb.cpp
+  txgraph.cpp
+  txmempool.cpp
+  txrequest.cpp
+  validation.cpp
+  validationinterface.cpp
+  versionbits.cpp
+  $<$<TARGET_EXISTS:bitcoin_wallet>:wallet/init.cpp>
+  $<$<NOT:$<TARGET_EXISTS:bitcoin_wallet>>:dummywallet.cpp>
+)
+target_link_libraries(bitcoin_node
+  PRIVATE
+    core_interface
+    bitcoin_common
+    bitcoin_util
+    $<TARGET_NAME_IF_EXISTS:bitcoin_zmq>
+    leveldb
+    minisketch
+    univalue
+    Boost::headers
+    $<TARGET_NAME_IF_EXISTS:libevent::core>
+    $<TARGET_NAME_IF_EXISTS:libevent::extra>
+    $<TARGET_NAME_IF_EXISTS:libevent::pthreads>
+    $<TARGET_NAME_IF_EXISTS:USDT::headers>
+)
+
+# Bitcoin wrapper executable that can call other executables.
+if(BUILD_BITCOIN_BIN)
+  add_executable(bitcoin bitcoin.cpp)
+  add_windows_resources(bitcoin bitcoin-res.rc)
+  add_windows_application_manifest(bitcoin)
+  target_link_libraries(bitcoin core_interface bitcoin_util)
+  install_binary_component(bitcoin HAS_MANPAGE)
+endif()
+
+# Bitcoin Core bitcoind.
+if(BUILD_DAEMON)
+  add_executable(bitcoind
+    bitcoind.cpp
+    init/bitcoind.cpp
+  )
+  add_windows_resources(bitcoind bitcoind-res.rc)
+  add_windows_application_manifest(bitcoind)
+  target_link_libraries(bitcoind
+    core_interface
+    bitcoin_node
+    $<TARGET_NAME_IF_EXISTS:bitcoin_wallet>
+  )
+  install_binary_component(bitcoind HAS_MANPAGE)
+endif()
+if(ENABLE_IPC AND BUILD_DAEMON)
+  add_executable(bitcoin-node
+    bitcoind.cpp
+    init/bitcoin-node.cpp
+  )
+  target_link_libraries(bitcoin-node
+    core_interface
+    bitcoin_node
+    bitcoin_ipc
+    $<TARGET_NAME_IF_EXISTS:bitcoin_wallet>
+  )
+  install_binary_component(bitcoin-node INTERNAL)
+endif()
+
+if(ENABLE_IPC AND BUILD_TESTS)
+    # bitcoin_ipc_test library target is defined here in src/CMakeLists.txt
+    # instead of src/test/CMakeLists.txt so capnp files in src/test/ are able to
+    # reference capnp files in src/ipc/capnp/ by relative path. The Cap'n Proto
+    # compiler only allows importing by relative path when the importing and
+    # imported files are underneath the same compilation source prefix, so the
+    # source prefix must be src/, not src/test/
+    add_library(bitcoin_ipc_test STATIC EXCLUDE_FROM_ALL
+      test/ipc_test.cpp
+    )
+    target_capnp_sources(bitcoin_ipc_test ${PROJECT_SOURCE_DIR}
+      test/ipc_test.capnp
+    )
+    add_dependencies(bitcoin_ipc_test bitcoin_ipc_headers)
+endif()
+
+
+add_library(bitcoin_cli STATIC EXCLUDE_FROM_ALL
+  compat/stdin.cpp
+  rpc/client.cpp
+)
+target_link_libraries(bitcoin_cli
+  PUBLIC
+    core_interface
+    univalue
+)
+
+
+# Bitcoin Core RPC client
+if(BUILD_CLI)
+  add_executable(bitcoin-cli bitcoin-cli.cpp)
+  add_windows_resources(bitcoin-cli bitcoin-cli-res.rc)
+  add_windows_application_manifest(bitcoin-cli)
+  target_link_libraries(bitcoin-cli
+    core_interface
+    bitcoin_cli
+    bitcoin_common
+    bitcoin_util
+    libevent::core
+    libevent::extra
+  )
+  install_binary_component(bitcoin-cli HAS_MANPAGE)
+endif()
+
+
+if(BUILD_TX)
+  add_executable(bitcoin-tx bitcoin-tx.cpp)
+  add_windows_resources(bitcoin-tx bitcoin-tx-res.rc)
+  add_windows_application_manifest(bitcoin-tx)
+  target_link_libraries(bitcoin-tx
+    core_interface
+    bitcoin_common
+    bitcoin_util
+    univalue
+  )
+  install_binary_component(bitcoin-tx HAS_MANPAGE)
+endif()
+
+
+if(BUILD_UTIL)
+  add_executable(bitcoin-util bitcoin-util.cpp)
+  add_windows_resources(bitcoin-util bitcoin-util-res.rc)
+  add_windows_application_manifest(bitcoin-util)
+  target_link_libraries(bitcoin-util
+    core_interface
+    bitcoin_common
+    bitcoin_util
+  )
+  install_binary_component(bitcoin-util HAS_MANPAGE)
+endif()
+
+
+if(BUILD_GUI)
+  add_subdirectory(qt)
+endif()
+
+
+if(BUILD_KERNEL_LIB)
+  add_subdirectory(kernel)
+endif()
+
+if(BUILD_UTIL_CHAINSTATE)
+  add_executable(bitcoin-chainstate
+    bitcoin-chainstate.cpp
+  )
+  # TODO: The `SKIP_BUILD_RPATH` property setting can be deleted
+  #       in the future after reordering Guix script commands to
+  #       perform binary checks after the installation step.
+  # Relevant discussions:
+  # - https://github.com/hebasto/bitcoin/pull/236#issuecomment-2183120953
+  # - https://github.com/bitcoin/bitcoin/pull/30312#issuecomment-2191235833
+  set_target_properties(bitcoin-chainstate PROPERTIES
+    SKIP_BUILD_RPATH OFF
+  )
+  target_link_libraries(bitcoin-chainstate
+    PRIVATE
+      core_interface
+      bitcoinkernel
+  )
+  install_binary_component(bitcoin-chainstate INTERNAL)
+endif()
+
+
+add_subdirectory(test/util)
+if(BUILD_BENCH)
+  add_subdirectory(bench)
+endif()
+
+if(BUILD_TESTS)
+  add_subdirectory(test)
+endif()
+
+if(BUILD_FUZZ_BINARY)
+  add_subdirectory(test/fuzz)
+endif()
+add_subdirectory(segop)
diff --git a/src_v1/src/consensus/consensus.h b/src_v1/src/consensus/consensus.h
new file mode 100644
index 0000000000..7bb8fe60fa
--- /dev/null
+++ b/src_v1/src/consensus/consensus.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-present The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_CONSENSUS_CONSENSUS_H
+#define BITCOIN_CONSENSUS_CONSENSUS_H
+
+#include <cstdint>
+#include <cstdlib>
+
+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */
+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;
+/** The maximum allowed weight for a block, see BIP 141 (network rule) */
+static const unsigned int MAX_BLOCK_WEIGHT = 4000000;
+/** The maximum allowed number of signature check operations in a block (network rule) */
+static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;
+/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */
+static const int COINBASE_MATURITY = 100;
+
+/** Maximum size of the coinbase scriptSig (network rule). */
+static const unsigned int MAX_COINBASE_SCRIPTSIG_SIZE = 100;
+
+static const int WITNESS_SCALE_FACTOR = 4;
+
+static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction
+static const size_t MIN_SERIALIZABLE_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 10; // 10 is the lower bound for the size of a serialized CTransaction
+
+/** Flags for nSequence and nLockTime locks */
+/** Interpret sequence numbers as relative lock-time constraints. */
+static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);
+
+/**
+ * Maximum number of seconds that the timestamp of the first
+ * block of a difficulty adjustment period is allowed to
+ * be earlier than the last block of the previous period (BIP94).
+ */
+static constexpr int64_t MAX_TIMEWARP = 600;
+
+#endif // BITCOIN_CONSENSUS_CONSENSUS_H
diff --git a/src_v1/src/consensus/tx_check.cpp b/src_v1/src/consensus/tx_check.cpp
new file mode 100644
index 0000000000..8b8213badb
--- /dev/null
+++ b/src_v1/src/consensus/tx_check.cpp
@@ -0,0 +1,158 @@
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <consensus/tx_check.h>
+
+#include <consensus/amount.h>
+#include <consensus/consensus.h>
+#include <consensus/validation.h>
+#include <crypto/sha256.h>
+#include <primitives/transaction.h>
+
+#include <algorithm>
+#include <set>
+
+// segOP: P2SOP script pattern
+//
+// P2SOP output script (from spec):
+//   OP_RETURN 0x23 "SOP" <32-byte commitment>
+//
+// Hex layout:
+//   6a          OP_RETURN
+//   23          PUSHDATA(35)
+//   53 4f 50    'S' 'O' 'P'
+//   <32 bytes>  commitment = SHA256(segop_payload)
+//
+// Total script length = 1 + 1 + 3 + 32 = 37 bytes.
+static constexpr unsigned int P2SOP_SCRIPT_SIZE = 37;
+static constexpr unsigned int P2SOP_PUSH_LEN    = 0x23;
+
+// Helper: Try to find exactly one P2SOP output in tx.vout and extract its
+// 32-byte commitment into `out_commitment`. Returns true if found, false if
+// none or malformed. If more than one matching P2SOP is found, also returns
+// false (we require exactly one).
+static bool ExtractSegopCommitment(const CTransaction& tx, unsigned char (&out_commitment)[CSHA256::OUTPUT_SIZE])
+{
+    bool found = false;
+
+    for (const auto& txout : tx.vout) {
+        const CScript& script = txout.scriptPubKey;
+
+        // Quick length check
+        if (script.size() != P2SOP_SCRIPT_SIZE) continue;
+
+        // Raw bytes: [0] = OP_RETURN, [1] = 0x23, [2..4] = "SOP"
+        if (script[0] != OP_RETURN) continue;
+        if (static_cast<unsigned char>(script[1]) != P2SOP_PUSH_LEN) continue;
+        if (script[2] != 0x53 || script[3] != 0x4f || script[4] != 0x50) continue; // 'S','O','P'
+
+        // If we've already found one P2SOP, having another is invalid.
+        if (found) {
+            return false;
+        }
+
+        // Extract the 32-byte commitment (bytes 5..36)
+        std::copy(script.begin() + 5, script.begin() + 5 + CSHA256::OUTPUT_SIZE, out_commitment);
+        found = true;
+    }
+
+    return found;
+}
+
+/**
+ * Check basic structural properties of a transaction that do not depend on the
+ * UTXO set or chain state.
+ *
+ * This is where we also enforce segOP's structural consensus rules:
+ *   - if a segOP payload is present, its size must not exceed 100,000 bytes
+ *   - if a segOP payload is present, there must be exactly one P2SOP output
+ *     whose 32-byte commitment equals SHA256(segop_payload)
+ */
+bool CheckTransaction(const CTransaction& tx, TxValidationState& state)
+{
+    // Basic checks that don't depend on any context
+    if (tx.vin.empty()) {
+        return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vin-empty");
+    }
+    if (tx.vout.empty()) {
+        return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-empty");
+    }
+
+    // Basic size limit: the non-witness serialized size times WITNESS_SCALE_FACTOR
+    // must not exceed MAX_BLOCK_WEIGHT.
+    //
+    // Note: TX_NO_WITNESS(tx) *does* include segOP when present, so segOP bytes
+    // are already charged at full 4 WU/byte here, matching the segOP spec.
+    if (::GetSerializeSize(TX_NO_WITNESS(tx)) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT) {
+        return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-oversize");
+    }
+
+    // segOP structural rules: only apply if a segOP payload is present.
+    if (!tx.segop_payload.IsNull()) {
+        // 1) Size cap: ≤ 100,000 bytes
+        static constexpr unsigned int MAX_SEGOP_PAYLOAD_SIZE = 100000;
+        if (tx.segop_payload.data.size() > MAX_SEGOP_PAYLOAD_SIZE) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-toolarge");
+        }
+
+        // 2) Extract P2SOP commitment from a dedicated OP_RETURN output.
+        unsigned char commitment_script[CSHA256::OUTPUT_SIZE];
+        if (!ExtractSegopCommitment(tx, commitment_script)) {
+            // Either no P2SOP output or more than one. Both are invalid when
+            // a segOP payload is present.
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-no-p2sop");
+        }
+
+        // 3) Compute SHA256(segop_payload) and compare.
+        unsigned char payload_hash[CSHA256::OUTPUT_SIZE];
+        CSHA256()
+            .Write(tx.segop_payload.data.data(), tx.segop_payload.data.size())
+            .Finalize(payload_hash);
+
+        if (!std::equal(std::begin(commitment_script), std::end(commitment_script),
+                        std::begin(payload_hash))) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-segop-commitment-mismatch");
+        }
+    }
+
+    // Check for negative or overflow output values (same style as upstream).
+    CAmount nValueOut{0};
+    for (const auto& txout : tx.vout) {
+        if (!MoneyRange(txout.nValue)) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-negative");
+        }
+
+        nValueOut += txout.nValue;
+
+        if (!MoneyRange(nValueOut)) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-vout-toolarge");
+        }
+    }
+
+    // Check for duplicate inputs.
+    std::set<COutPoint> vInOutPoints;
+    for (const auto& txin : tx.vin) {
+        if (!vInOutPoints.insert(txin.prevout).second) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-inputs-duplicate");
+        }
+    }
+
+    if (tx.IsCoinBase()) {
+        // Coinbase scriptsig size limits.
+        if (tx.vin[0].scriptSig.size() < 2 ||
+            tx.vin[0].scriptSig.size() > MAX_COINBASE_SCRIPTSIG_SIZE) {
+            return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-cb-length");
+        }
+    } else {
+        // For non-coinbase transactions, prevouts must not be null.
+        for (const auto& txin : tx.vin) {
+            if (txin.prevout.IsNull()) {
+                return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-txns-prevout-null");
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src_v1/src/core_read.cpp b/src_v1/src/core_read.cpp
new file mode 100644
index 0000000000..15fc518a7e
--- /dev/null
+++ b/src_v1/src/core_read.cpp
@@ -0,0 +1,276 @@
+// Copyright (c) 2009-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <core_io.h>
+
+#include <primitives/block.h>
+#include <primitives/transaction.h>
+#include <script/script.h>
+#include <script/sign.h>
+#include <serialize.h>
+#include <streams.h>
+#include <util/result.h>
+#include <util/strencodings.h>
+
+#include <algorithm>
+#include <string>
+
+using util::SplitString;
+
+namespace {
+class OpCodeParser
+{
+private:
+    std::map<std::string, opcodetype> mapOpNames;
+
+public:
+    OpCodeParser()
+    {
+        for (unsigned int op = 0; op <= MAX_OPCODE; ++op) {
+            // Allow OP_RESERVED to get into mapOpNames
+            if (op < OP_NOP && op != OP_RESERVED) {
+                continue;
+            }
+
+            std::string strName = GetOpName(static_cast<opcodetype>(op));
+            if (strName == "OP_UNKNOWN") {
+                continue;
+            }
+            mapOpNames[strName] = static_cast<opcodetype>(op);
+            // Convenience: OP_ADD and just ADD are both recognized:
+            if (strName.starts_with("OP_")) {
+                mapOpNames[strName.substr(3)] = static_cast<opcodetype>(op);
+            }
+        }
+    }
+    opcodetype Parse(const std::string& s) const
+    {
+        auto it = mapOpNames.find(s);
+        if (it == mapOpNames.end()) throw std::runtime_error("script parse error: unknown opcode");
+        return it->second;
+    }
+};
+
+opcodetype ParseOpCode(const std::string& s)
+{
+    static const OpCodeParser ocp;
+    return ocp.Parse(s);
+}
+
+} // namespace
+
+CScript ParseScript(const std::string& s)
+{
+    CScript result;
+
+    std::vector<std::string> words = SplitString(s, " \t\n");
+
+    for (const std::string& w : words) {
+        if (w.empty()) {
+            // Empty string, ignore. (SplitString doesn't combine multiple separators)
+        } else if (std::all_of(w.begin(), w.end(), ::IsDigit) ||
+                   (w.front() == '-' && w.size() > 1 && std::all_of(w.begin() + 1, w.end(), ::IsDigit)))
+        {
+            // Number
+            const auto num{ToIntegral<int64_t>(w)};
+
+            // limit the range of numbers ParseScript accepts in decimal
+            // since numbers outside -0xFFFFFFFF...0xFFFFFFFF are illegal in scripts
+            if (!num.has_value() || num > int64_t{0xffffffff} || num < -1 * int64_t{0xffffffff}) {
+                throw std::runtime_error("script parse error: decimal numeric value only allowed in the "
+                                         "range -0xFFFFFFFF...0xFFFFFFFF");
+            }
+
+            result << num.value();
+        } else if (w.starts_with("0x") && w.size() > 2 && IsHex(std::string(w.begin() + 2, w.end()))) {
+            // Raw hex data, inserted NOT pushed onto stack:
+            std::vector<unsigned char> raw = ParseHex(std::string(w.begin() + 2, w.end()));
+            result.insert(result.end(), raw.begin(), raw.end());
+        } else if (w.size() >= 2 && w.front() == '\'' && w.back() == '\'') {
+            // Single-quoted string, pushed as data. NOTE: this is poor-man's
+            // parsing, spaces/tabs/newlines in single-quoted strings won't work.
+            std::vector<unsigned char> value(w.begin() + 1, w.end() - 1);
+            result << value;
+        } else {
+            // opcode, e.g. OP_ADD or ADD:
+            result << ParseOpCode(w);
+        }
+    }
+
+    return result;
+}
+
+// Check that all of the input and output scripts of a transaction contains valid opcodes
+static bool CheckTxScriptsSanity(const CMutableTransaction& tx)
+{
+    // Check input scripts for non-coinbase txs
+    if (!CTransaction(tx).IsCoinBase()) {
+        for (unsigned int i = 0; i < tx.vin.size(); i++) {
+            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) {
+                return false;
+            }
+        }
+    }
+    // Check output scripts
+    for (unsigned int i = 0; i < tx.vout.size(); i++) {
+        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static bool DecodeTx(CMutableTransaction& tx, const std::vector<unsigned char>& tx_data, bool try_no_witness, bool try_witness)
+{
+    // General strategy:
+    // - Decode both with extended serialization (which interprets the 0x0001 tag as a marker for
+    //   the presence of witnesses) and with legacy serialization (which interprets the tag as a
+    //   0-input 1-output incomplete transaction).
+    //   - Restricted by try_no_witness (which disables legacy if false) and try_witness (which
+    //     disables extended if false).
+    //   - Ignore serializations that do not fully consume the hex string, *except* that for the
+    //     extended form we allow a trailing segOP payload and attempt to parse it.
+    // - If neither succeeds, fail.
+    // - If only one succeeds, return that one.
+    // - If both decode attempts succeed:
+    //   - If only one passes the CheckTxScriptsSanity check, return that one.
+    //   - If neither or both pass CheckTxScriptsSanity, return the extended one.
+
+    CMutableTransaction tx_extended, tx_legacy;
+    bool ok_extended = false, ok_legacy = false;
+
+    // Try decoding with extended serialization support, and remember if the result successfully
+    // consumes the entire input. With segOP support, we additionally allow a trailing segOP
+    // payload after the witness data and try to parse it into tx_extended.segop_payload.
+    if (try_witness) {
+        DataStream ssData(tx_data);
+        try {
+            ssData >> TX_WITH_WITNESS(tx_extended);
+
+            if (ssData.empty()) {
+                // Normal (non-segOP) extended transaction: everything consumed.
+                ok_extended = true;
+            } else {
+                // segOP-aware decode: if there are trailing bytes, try to interpret them
+                // as a CSegopPayload. Only treat this as successful if that parse consumes
+                // *all* remaining bytes.
+                try {
+                    CSegopPayload segop;
+                    ssData >> segop;
+
+                    if (ssData.empty()) {
+                        tx_extended.segop_payload = std::move(segop);
+                        ok_extended = true;
+                    }
+                } catch (const std::exception&) {
+                    // Trailing bytes were not a valid segOP payload; fall through and
+                    // treat extended decoding as failed.
+                }
+            }
+        } catch (const std::exception&) {
+            // Fall through.
+        }
+    }
+
+    // Optimization: if extended decoding succeeded and the result passes CheckTxScriptsSanity,
+    // don't bother decoding the other way.
+    if (ok_extended && CheckTxScriptsSanity(tx_extended)) {
+        tx = std::move(tx_extended);
+        return true;
+    }
+
+    // Try decoding with legacy serialization, and remember if the result successfully consumes the entire input.
+    if (try_no_witness) {
+        DataStream ssData(tx_data);
+        try {
+            ssData >> TX_NO_WITNESS(tx_legacy);
+            if (ssData.empty()) ok_legacy = true;
+        } catch (const std::exception&) {
+            // Fall through.
+        }
+    }
+
+    // If legacy decoding succeeded and passes CheckTxScriptsSanity, that's our answer, as we know
+    // at this point that extended decoding either failed or doesn't pass the sanity check.
+    if (ok_legacy && CheckTxScriptsSanity(tx_legacy)) {
+        tx = std::move(tx_legacy);
+        return true;
+    }
+
+    // If extended decoding succeeded, and neither decoding passes sanity, return the extended one.
+    if (ok_extended) {
+        tx = std::move(tx_extended);
+        return true;
+    }
+
+    // If legacy decoding succeeded and extended didn't, return the legacy one.
+    if (ok_legacy) {
+        tx = std::move(tx_legacy);
+        return true;
+    }
+
+    // If none succeeded, we failed.
+    return false;
+}
+
+bool DecodeHexTx(CMutableTransaction& tx, const std::string& hex_tx, bool try_no_witness, bool try_witness)
+{
+    if (!IsHex(hex_tx)) {
+        return false;
+    }
+
+    std::vector<unsigned char> txData(ParseHex(hex_tx));
+    return DecodeTx(tx, txData, try_no_witness, try_witness);
+}
+
+bool DecodeHexBlockHeader(CBlockHeader& header, const std::string& hex_header)
+{
+    if (!IsHex(hex_header)) return false;
+
+    const std::vector<unsigned char> header_data{ParseHex(hex_header)};
+    DataStream ser_header{header_data};
+    try {
+        ser_header >> header;
+    } catch (const std::exception&) {
+        return false;
+    }
+    return true;
+}
+
+bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)
+{
+    if (!IsHex(strHexBlk))
+        return false;
+
+    std::vector<unsigned char> blockData(ParseHex(strHexBlk));
+    DataStream ssBlock(blockData);
+    try {
+        ssBlock >> TX_WITH_WITNESS(block);
+    }
+    catch (const std::exception&) {
+        return false;
+    }
+
+    return true;
+}
+
+util::Result<int> SighashFromStr(const std::string& sighash)
+{
+    static const std::map<std::string, int> map_sighash_values = {
+        {std::string("DEFAULT"), int(SIGHASH_DEFAULT)},
+        {std::string("ALL"), int(SIGHASH_ALL)},
+        {std::string("ALL|ANYONECANPAY"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},
+        {std::string("NONE"), int(SIGHASH_NONE)},
+        {std::string("NONE|ANYONECANPAY"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},
+        {std::string("SINGLE"), int(SIGHASH_SINGLE)},
+        {std::string("SINGLE|ANYONECANPAY"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},
+    };
+    const auto& it = map_sighash_values.find(sighash);
+    if (it != map_sighash_values.end()) {
+        return it->second;
+    } else {
+        return util::Error{Untranslated("'" + sighash + "' is not a valid sighash parameter.")};
+    }
+}
diff --git a/src_v1/src/core_write.cpp b/src_v1/src/core_write.cpp
new file mode 100644
index 0000000000..c63699aab2
--- /dev/null
+++ b/src_v1/src/core_write.cpp
@@ -0,0 +1,281 @@
+// Copyright (c) 2009-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <core_io.h>
+
+#include <common/system.h>
+#include <consensus/amount.h>
+#include <consensus/consensus.h>
+#include <consensus/validation.h>
+#include <key_io.h>
+#include <script/descriptor.h>
+#include <script/script.h>
+#include <script/solver.h>
+#include <serialize.h>
+#include <streams.h>
+#include <undo.h>
+#include <univalue.h>
+#include <util/check.h>
+#include <util/strencodings.h>
+
+#include <map>
+#include <string>
+#include <vector>
+
+UniValue ValueFromAmount(const CAmount amount)
+{
+    static_assert(COIN > 1);
+    int64_t quotient = amount / COIN;
+    int64_t remainder = amount % COIN;
+    if (amount < 0) {
+        quotient = -quotient;
+        remainder = -remainder;
+    }
+    return UniValue(UniValue::VNUM,
+            strprintf("%s%d.%08d", amount < 0 ? "-" : "", quotient, remainder));
+}
+
+std::string FormatScript(const CScript& script)
+{
+    std::string ret;
+    CScript::const_iterator it = script.begin();
+    opcodetype op;
+    while (it != script.end()) {
+        CScript::const_iterator it2 = it;
+        std::vector<unsigned char> vch;
+        if (script.GetOp(it, op, vch)) {
+            if (op == OP_0) {
+                ret += "0 ";
+                continue;
+            } else if ((op >= OP_1 && op <= OP_16) || op == OP_1NEGATE) {
+                ret += strprintf("%i ", op - OP_1NEGATE - 1);
+                continue;
+            } else if (op >= OP_NOP && op <= OP_NOP10) {
+                std::string str(GetOpName(op));
+                if (str.substr(0, 3) == std::string("OP_")) {
+                    ret += str.substr(3, std::string::npos) + " ";
+                    continue;
+                }
+            }
+            if (vch.size() > 0) {
+                ret += strprintf("0x%x 0x%x ", HexStr(std::vector<uint8_t>(it2, it - vch.size())),
+                                               HexStr(std::vector<uint8_t>(it - vch.size(), it)));
+            } else {
+                ret += strprintf("0x%x ", HexStr(std::vector<uint8_t>(it2, it)));
+            }
+            continue;
+        }
+        ret += strprintf("0x%x ", HexStr(std::vector<uint8_t>(it2, script.end())));
+        break;
+    }
+    return ret.substr(0, ret.empty() ? ret.npos : ret.size() - 1);
+}
+
+const std::map<unsigned char, std::string> mapSigHashTypes = {
+    {static_cast<unsigned char>(SIGHASH_ALL), std::string("ALL")},
+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string("ALL|ANYONECANPAY")},
+    {static_cast<unsigned char>(SIGHASH_NONE), std::string("NONE")},
+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string("NONE|ANYONECANPAY")},
+    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string("SINGLE")},
+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string("SINGLE|ANYONECANPAY")},
+};
+
+std::string SighashToStr(unsigned char sighash_type)
+{
+    const auto& it = mapSigHashTypes.find(sighash_type);
+    if (it == mapSigHashTypes.end()) return "";
+    return it->second;
+}
+
+/**
+ * Create the assembly string representation of a CScript object.
+ * @param[in] script    CScript object to convert into the asm string representation.
+ * @param[in] fAttemptSighashDecode    Whether to attempt to decode sighash types on data within the script that matches the format
+ *                                     of a signature. Only pass true for scripts you believe could contain signatures. For example,
+ *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.
+ */
+std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)
+{
+    std::string str;
+    opcodetype opcode;
+    std::vector<unsigned char> vch;
+    CScript::const_iterator pc = script.begin();
+    while (pc < script.end()) {
+        if (!str.empty()) {
+            str += " ";
+        }
+        if (!script.GetOp(pc, opcode, vch)) {
+            str += "[error]";
+            return str;
+        }
+        if (0 <= opcode && opcode <= OP_PUSHDATA4) {
+            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {
+                str += strprintf("%d", CScriptNum(vch, false).getint());
+            } else {
+                // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature
+                if (fAttemptSighashDecode && !script.IsUnspendable()) {
+                    std::string strSigHashDecode;
+                    // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.
+                    // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to
+                    // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the
+                    // checks in CheckSignatureEncoding.
+                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, nullptr)) {
+                        const unsigned char chSigHashType = vch.back();
+                        const auto it = mapSigHashTypes.find(chSigHashType);
+                        if (it != mapSigHashTypes.end()) {
+                            strSigHashDecode = "[" + it->second + "]";
+                            vch.pop_back(); // remove the sighash type byte. it will be replaced by the decode.
+                        }
+                    }
+                    str += HexStr(vch) + strSigHashDecode;
+                } else {
+                    str += HexStr(vch);
+                }
+            }
+        } else {
+            str += GetOpName(opcode);
+        }
+    }
+    return str;
+}
+
+std::string EncodeHexTx(const CTransaction& tx)
+{
+    DataStream ssTx;
+    ssTx << TX_WITH_WITNESS(tx);
+    return HexStr(ssTx);
+}
+
+void ScriptToUniv(const CScript& script, UniValue& out, bool include_hex, bool include_address, const SigningProvider* provider)
+{
+    CTxDestination address;
+
+    out.pushKV("asm", ScriptToAsmStr(script));
+    if (include_address) {
+        out.pushKV("desc", InferDescriptor(script, provider ? *provider : DUMMY_SIGNING_PROVIDER)->ToString());
+    }
+    if (include_hex) {
+        out.pushKV("hex", HexStr(script));
+    }
+
+    std::vector<std::vector<unsigned char>> solns;
+    const TxoutType type{Solver(script, solns)};
+
+    if (include_address && ExtractDestination(script, address) && type != TxoutType::PUBKEY) {
+        out.pushKV("address", EncodeDestination(address));
+    }
+    out.pushKV("type", GetTxnOutputType(type));
+}
+
+void TxToUniv(const CTransaction& tx, const uint256& block_hash, UniValue& entry, bool include_hex, const CTxUndo* txundo, TxVerbosity verbosity)
+{
+    CHECK_NONFATAL(verbosity >= TxVerbosity::SHOW_DETAILS);
+
+    entry.pushKV("txid", tx.GetHash().GetHex());
+    entry.pushKV("hash", tx.GetWitnessHash().GetHex());
+    entry.pushKV("version", tx.version);
+    entry.pushKV("size", tx.GetTotalSize());
+    entry.pushKV("vsize", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);
+    entry.pushKV("weight", GetTransactionWeight(tx));
+    entry.pushKV("locktime", (int64_t)tx.nLockTime);
+
+    UniValue vin{UniValue::VARR};
+    vin.reserve(tx.vin.size());
+
+    // If available, use Undo data to calculate the fee. Note that txundo == nullptr
+    // for coinbase transactions and for transactions where undo data is unavailable.
+    const bool have_undo = txundo != nullptr;
+    CAmount amt_total_in = 0;
+    CAmount amt_total_out = 0;
+
+    for (unsigned int i = 0; i < tx.vin.size(); i++) {
+        const CTxIn& txin = tx.vin[i];
+        UniValue in(UniValue::VOBJ);
+        if (tx.IsCoinBase()) {
+            in.pushKV("coinbase", HexStr(txin.scriptSig));
+        } else {
+            in.pushKV("txid", txin.prevout.hash.GetHex());
+            in.pushKV("vout", (int64_t)txin.prevout.n);
+            UniValue o(UniValue::VOBJ);
+            o.pushKV("asm", ScriptToAsmStr(txin.scriptSig, true));
+            o.pushKV("hex", HexStr(txin.scriptSig));
+            in.pushKV("scriptSig", std::move(o));
+        }
+        if (!tx.vin[i].scriptWitness.IsNull()) {
+            UniValue txinwitness(UniValue::VARR);
+            txinwitness.reserve(tx.vin[i].scriptWitness.stack.size());
+            for (const auto& item : tx.vin[i].scriptWitness.stack) {
+                txinwitness.push_back(HexStr(item));
+            }
+            in.pushKV("txinwitness", std::move(txinwitness));
+        }
+        if (have_undo) {
+            const Coin& prev_coin = txundo->vprevout[i];
+            const CTxOut& prev_txout = prev_coin.out;
+
+            amt_total_in += prev_txout.nValue;
+
+            if (verbosity == TxVerbosity::SHOW_DETAILS_AND_PREVOUT) {
+                UniValue o_script_pub_key(UniValue::VOBJ);
+                ScriptToUniv(prev_txout.scriptPubKey, /*out=*/o_script_pub_key, /*include_hex=*/true, /*include_address=*/true);
+
+                UniValue p(UniValue::VOBJ);
+                p.pushKV("generated", bool(prev_coin.fCoinBase));
+                p.pushKV("height", uint64_t(prev_coin.nHeight));
+                p.pushKV("value", ValueFromAmount(prev_txout.nValue));
+                p.pushKV("scriptPubKey", std::move(o_script_pub_key));
+                in.pushKV("prevout", std::move(p));
+            }
+        }
+        in.pushKV("sequence", (int64_t)txin.nSequence);
+        vin.push_back(std::move(in));
+    }
+    entry.pushKV("vin", std::move(vin));
+
+    UniValue vout(UniValue::VARR);
+    vout.reserve(tx.vout.size());
+    for (unsigned int i = 0; i < tx.vout.size(); i++) {
+        const CTxOut& txout = tx.vout[i];
+
+        UniValue out(UniValue::VOBJ);
+
+        out.pushKV("value", ValueFromAmount(txout.nValue));
+        out.pushKV("n", (int64_t)i);
+
+        UniValue o(UniValue::VOBJ);
+        ScriptToUniv(txout.scriptPubKey, /*out=*/o, /*include_hex=*/true, /*include_address=*/true);
+        out.pushKV("scriptPubKey", std::move(o));
+        vout.push_back(std::move(out));
+
+        if (have_undo) {
+            amt_total_out += txout.nValue;
+        }
+    }
+    entry.pushKV("vout", std::move(vout));
+
+    if (have_undo) {
+        const CAmount fee = amt_total_in - amt_total_out;
+        CHECK_NONFATAL(MoneyRange(fee));
+        entry.pushKV("fee", ValueFromAmount(fee));
+    }
+
+    // --- segOP: expose payload in JSON when present ---
+    if (!tx.segop_payload.IsNull()) {
+        UniValue seg(UniValue::VOBJ);
+        seg.pushKV("version", (int64_t)tx.segop_payload.version);
+        seg.pushKV("size", (uint64_t)tx.segop_payload.data.size());
+        seg.pushKV("hex", HexStr(tx.segop_payload.data));
+        entry.pushKV("segop", std::move(seg));
+    }
+    // --- end segOP JSON section ---
+
+    if (!block_hash.IsNull()) {
+        entry.pushKV("blockhash", block_hash.GetHex());
+    }
+
+    if (include_hex) {
+        // The hex-encoded transaction. Used the name "hex" to be consistent with the verbose output of "getrawtransaction".
+        entry.pushKV("hex", EncodeHexTx(tx));
+    }
+}
diff --git a/src_v1/src/primitives/transaction.cpp b/src_v1/src/primitives/transaction.cpp
new file mode 100644
index 0000000000..f3483c0d89
--- /dev/null
+++ b/src_v1/src/primitives/transaction.cpp
@@ -0,0 +1,210 @@
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <primitives/transaction.h>
+
+#include <consensus/amount.h>
+#include <crypto/hex_base.h>
+#include <hash.h>
+#include <primitives/transaction_identifier.h>
+#include <script/script.h>
+#include <serialize.h>
+#include <tinyformat.h>
+#include <uint256.h>
+
+#include <algorithm>
+#include <cassert>
+#include <stdexcept>
+
+/** COutPoint *****************************************************************/
+
+std::string COutPoint::ToString() const
+{
+    return strprintf("COutPoint(%s, %u)", hash.ToString().substr(0, 10), n);
+}
+
+/** CTxIn *********************************************************************/
+
+CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)
+{
+    prevout = prevoutIn;
+    scriptSig = scriptSigIn;
+    nSequence = nSequenceIn;
+}
+
+CTxIn::CTxIn(Txid hashPrevTx, uint32_t nOut, CScript scriptSigIn, uint32_t nSequenceIn)
+{
+    prevout = COutPoint(hashPrevTx, nOut);
+    scriptSig = scriptSigIn;
+    nSequence = nSequenceIn;
+}
+
+std::string CTxIn::ToString() const
+{
+    std::string str;
+    str += "CTxIn(";
+    str += prevout.ToString();
+    if (prevout.IsNull()) {
+        str += strprintf(", coinbase %s", HexStr(scriptSig));
+    } else {
+        str += strprintf(", scriptSig=%s", HexStr(scriptSig).substr(0, 24));
+    }
+    if (nSequence != SEQUENCE_FINAL) {
+        str += strprintf(", nSequence=%u", nSequence);
+    }
+    str += ")";
+    return str;
+}
+
+/** CTxOut ********************************************************************/
+
+CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)
+{
+    nValue = nValueIn;
+    scriptPubKey = scriptPubKeyIn;
+}
+
+std::string CTxOut::ToString() const
+{
+    return strprintf(
+        "CTxOut(nValue=%d.%08d, scriptPubKey=%s)",
+        nValue / COIN,
+        nValue % COIN,
+        HexStr(scriptPubKey).substr(0, 30)
+    );
+}
+
+/** CMutableTransaction *******************************************************/
+
+CMutableTransaction::CMutableTransaction()
+    : vin(),
+      vout(),
+      version{CTransaction::CURRENT_VERSION},
+      nLockTime{0},
+      segop_payload() // segOP: default-constructed (null)
+{
+}
+
+CMutableTransaction::CMutableTransaction(const CTransaction& tx)
+    : vin(tx.vin),
+      vout(tx.vout),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(tx.segop_payload) // segOP: carry payload across
+{
+}
+
+Txid CMutableTransaction::GetHash() const
+{
+    // Hash of the transaction without witness (and without segwit discount).
+    return Txid::FromUint256((HashWriter{} << TX_NO_WITNESS(*this)).GetHash());
+}
+
+/** CTransaction (internal helpers) *******************************************/
+
+bool CTransaction::ComputeHasWitness() const
+{
+    return std::any_of(vin.begin(), vin.end(), [](const CTxIn& input) {
+        return !input.scriptWitness.IsNull();
+    });
+}
+
+Txid CTransaction::ComputeHash() const
+{
+    // Legacy txid: no witness, but includes segOP, since segOP lives in the
+    // non-witness serialization lane and pays full weight.
+    return Txid::FromUint256((HashWriter{} << TX_NO_WITNESS(*this)).GetHash());
+}
+
+Wtxid CTransaction::ComputeWitnessHash() const
+{
+    // If there is no witness, wtxid == txid (BIP141 behaviour).
+    if (!HasWitness()) {
+        return Wtxid::FromUint256(hash.ToUint256());
+    }
+
+    // With witness: hash over full-with-witness serialization (segOP lives in
+    // the non-witness lane and is *not* discounted).
+    return Wtxid::FromUint256((HashWriter{} << TX_WITH_WITNESS(*this)).GetHash());
+}
+
+/** CTransaction (public) *****************************************************/
+
+CTransaction::CTransaction(const CMutableTransaction& tx)
+    : vin(tx.vin),
+      vout(tx.vout),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(tx.segop_payload),
+      m_has_witness{ComputeHasWitness()},
+      hash{ComputeHash()},
+      m_witness_hash{ComputeWitnessHash()}
+{
+}
+
+CTransaction::CTransaction(CMutableTransaction&& tx)
+    : vin(std::move(tx.vin)),
+      vout(std::move(tx.vout)),
+      version{tx.version},
+      nLockTime{tx.nLockTime},
+      segop_payload(std::move(tx.segop_payload)),
+      m_has_witness{ComputeHasWitness()},
+      hash{ComputeHash()},
+      m_witness_hash{ComputeWitnessHash()}
+{
+}
+
+CAmount CTransaction::GetValueOut() const
+{
+    CAmount nValueOut = 0;
+    for (const auto& tx_out : vout) {
+        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut + tx_out.nValue)) {
+            throw std::runtime_error(std::string(__func__) + ": value out of range");
+        }
+        nValueOut += tx_out.nValue;
+    }
+    assert(MoneyRange(nValueOut));
+    return nValueOut;
+}
+
+unsigned int CTransaction::GetTotalSize() const
+{
+    // Full serialized size including witness (and segOP in the base lane).
+    return ::GetSerializeSize(TX_WITH_WITNESS(*this));
+}
+
+std::string CTransaction::ToString() const
+{
+    std::string str;
+    str += strprintf(
+        "CTransaction(hash=%s, ver=%u, vin.size=%u, vout.size=%u, nLockTime=%u)\n",
+        GetHash().ToString().substr(0, 10),
+        version,
+        vin.size(),
+        vout.size(),
+        nLockTime
+    );
+
+    for (const auto& tx_in : vin) {
+        str += "    " + tx_in.ToString() + "\n";
+    }
+    for (const auto& tx_in : vin) {
+        str += "    " + tx_in.scriptWitness.ToString() + "\n";
+    }
+    for (const auto& tx_out : vout) {
+        str += "    " + tx_out.ToString() + "\n";
+    }
+
+    // segOP debugging: show presence and size, but not full payload hex
+    if (!segop_payload.IsNull()) {
+        str += strprintf(
+            "    segOP(version=%u, size=%u bytes)\n",
+            segop_payload.version,
+            static_cast<unsigned int>(segop_payload.data.size())
+        );
+    }
+
+    return str;
+}
diff --git a/src_v1/src/primitives/transaction.h b/src_v1/src/primitives/transaction.h
new file mode 100644
index 0000000000..f1d6445cd2
--- /dev/null
+++ b/src_v1/src/primitives/transaction.h
@@ -0,0 +1,469 @@
+// Copyright (c) 2009-2010 Satoshi Nakamoto
+// Copyright (c) 2009-2022 The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_PRIMITIVES_TRANSACTION_H
+#define BITCOIN_PRIMITIVES_TRANSACTION_H
+
+#include <attributes.h>
+#include <consensus/amount.h>
+#include <primitives/transaction_identifier.h> // IWYU pragma: export
+#include <script/script.h>
+#include <serialize.h>
+#include <uint256.h>
+#include <segop/segop.h>   // segOP payload
+
+#include <cstddef>
+#include <cstdint>
+#include <ios>
+#include <limits>
+#include <memory>
+#include <numeric>
+#include <string>
+#include <tuple>
+#include <utility>
+#include <vector>
+
+/** An outpoint - a combination of a transaction hash and an index n into its vout */
+class COutPoint
+{
+public:
+    Txid hash;
+    uint32_t n;
+
+    static constexpr uint32_t NULL_INDEX = std::numeric_limits<uint32_t>::max();
+
+    COutPoint(): n(NULL_INDEX) { }
+    COutPoint(const Txid& hashIn, uint32_t nIn): hash(hashIn), n(nIn) { }
+
+    SERIALIZE_METHODS(COutPoint, obj) { READWRITE(obj.hash, obj.n); }
+
+    void SetNull() { hash.SetNull(); n = NULL_INDEX; }
+    bool IsNull() const { return (hash.IsNull() && n == NULL_INDEX); }
+
+    friend bool operator<(const COutPoint& a, const COutPoint& b)
+    {
+        return std::tie(a.hash, a.n) < std::tie(b.hash, b.n);
+    }
+
+    friend bool operator==(const COutPoint& a, const COutPoint& b)
+    {
+        return (a.hash == b.hash && a.n == b.n);
+    }
+
+    friend bool operator!=(const COutPoint& a, const COutPoint& b)
+    {
+        return !(a == b);
+    }
+
+    std::string ToString() const;
+};
+
+/** An input of a transaction.  It contains the location of the previous
+ * transaction's output that it claims and a signature that matches the
+ * output's public key.
+ */
+class CTxIn
+{
+public:
+    COutPoint prevout;
+    CScript scriptSig;
+    uint32_t nSequence;
+    CScriptWitness scriptWitness; //!< Only serialized through CTransaction
+
+    /**
+     * Setting nSequence to this value for every input in a transaction
+     * disables nLockTime/IsFinalTx().
+     * It fails OP_CHECKLOCKTIMEVERIFY/CheckLockTime() for any input that has
+     * it set (BIP 65).
+     * It has SEQUENCE_LOCKTIME_DISABLE_FLAG set (BIP 68/112).
+     */
+    static const uint32_t SEQUENCE_FINAL = 0xffffffff;
+    /**
+     * This is the maximum sequence number that enables both nLockTime and
+     * OP_CHECKLOCKTIMEVERIFY (BIP 65).
+     * It has SEQUENCE_LOCKTIME_DISABLE_FLAG set (BIP 68/112).
+     */
+    static const uint32_t MAX_SEQUENCE_NONFINAL{SEQUENCE_FINAL - 1};
+
+    // Below flags apply in the context of BIP 68. BIP 68 requires the tx
+    // version to be set to 2, or higher.
+    /**
+     * If this flag is set, CTxIn::nSequence is NOT interpreted as a
+     * relative lock-time.
+     * It skips SequenceLocks() for any input that has it set (BIP 68).
+     * It fails OP_CHECKSEQUENCEVERIFY/CheckSequence() for any input that has
+     * it set (BIP 112).
+     */
+    static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1U << 31);
+
+    /**
+     * If CTxIn::nSequence encodes a relative lock-time and this flag
+     * is set, the relative lock-time has units of 512 seconds,
+     * otherwise it specifies blocks with a granularity of 1. */
+    static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);
+
+    /**
+     * If CTxIn::nSequence encodes a relative lock-time, this mask is
+     * applied to extract that lock-time from the sequence field. */
+    static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;
+
+    /**
+     * In order to use the same number of bits to encode roughly the
+     * same wall-clock duration, and because blocks are naturally
+     * limited to occur every 600s on average, the minimum granularity
+     * for time-based relative lock-time is fixed at 512 seconds.
+     * Converting from CTxIn::nSequence to seconds is performed by
+     * multiplying by 512 = 2^9, or equivalently shifting up by
+     * 9 bits. */
+    static const int SEQUENCE_LOCKTIME_GRANULARITY = 9;
+
+    CTxIn()
+    {
+        nSequence = SEQUENCE_FINAL;
+    }
+
+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);
+    CTxIn(Txid hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);
+
+    SERIALIZE_METHODS(CTxIn, obj) { READWRITE(obj.prevout, obj.scriptSig, obj.nSequence); }
+
+    friend bool operator==(const CTxIn& a, const CTxIn& b)
+    {
+        return (a.prevout   == b.prevout &&
+                a.scriptSig == b.scriptSig &&
+                a.nSequence == b.nSequence);
+    }
+
+    friend bool operator!=(const CTxIn& a, const CTxIn& b)
+    {
+        return !(a == b);
+    }
+
+    std::string ToString() const;
+};
+
+/** An output of a transaction.  It contains the public key that the next input
+ * must be able to sign with to claim it.
+ */
+class CTxOut
+{
+public:
+    CAmount nValue;
+    CScript scriptPubKey;
+
+    CTxOut()
+    {
+        SetNull();
+    }
+
+    CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn);
+
+    SERIALIZE_METHODS(CTxOut, obj) { READWRITE(obj.nValue, obj.scriptPubKey); }
+
+    void SetNull()
+    {
+        nValue = -1;
+        scriptPubKey.clear();
+    }
+
+    bool IsNull() const
+    {
+        return (nValue == -1);
+    }
+
+    friend bool operator==(const CTxOut& a, const CTxOut& b)
+    {
+        return (a.nValue       == b.nValue &&
+                a.scriptPubKey == b.scriptPubKey);
+    }
+
+    friend bool operator!=(const CTxOut& a, const CTxOut& b)
+    {
+        return !(a == b);
+    }
+
+    std::string ToString() const;
+};
+
+struct CMutableTransaction;
+
+struct TransactionSerParams {
+    const bool allow_witness;
+    SER_PARAMS_OPFUNC
+};
+static constexpr TransactionSerParams TX_WITH_WITNESS{.allow_witness = true};
+static constexpr TransactionSerParams TX_NO_WITNESS{.allow_witness = false};
+
+/**
+ * Basic transaction serialization format:
+ * - uint32_t version
+ * - std::vector<CTxIn> vin
+ * - std::vector<CTxOut> vout
+ * - uint32_t nLockTime
+ *
+ * Extended transaction serialization format (SegWit + segOP):
+ * - uint32_t version
+ * - unsigned char dummy = 0x00
+ * - unsigned char flags (!= 0)
+ *   bit0 (0x01): witness data present
+ *   bit1 (0x02): segOP payload present
+ * - std::vector<CTxIn> vin
+ * - std::vector<CTxOut> vout
+ * - if (flags & 1):
+ *   - CScriptWitness scriptWitness; (deserialized into CTxIn)
+ * - if (flags & 2):
+ *   - uint8_t segop_marker = 0x53 ('S')
+ *   - CSegopPayload segop_payload;   // version + [len + bytes]
+ * - uint32_t nLockTime
+ */
+template<typename Stream, typename TxType>
+void UnserializeTransaction(TxType& tx, Stream& s, const TransactionSerParams& params)
+{
+    const bool fAllowWitness = params.allow_witness;
+
+    s >> tx.version;
+    unsigned char flags = 0;
+    tx.vin.clear();
+    tx.vout.clear();
+    /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */
+    s >> tx.vin;
+    if (tx.vin.size() == 0 && fAllowWitness) {
+        /* We read a dummy or an empty vin. */
+        s >> flags;
+        if (flags != 0) {
+            s >> tx.vin;
+            s >> tx.vout;
+        }
+    } else {
+        /* We read a non-empty vin. Assume a normal vout follows. */
+        s >> tx.vout;
+    }
+
+    // Witness (bit 0) – unchanged SegWit behaviour
+    if ((flags & 1) && fAllowWitness) {
+        /* The witness flag is present, and we support witnesses. */
+        flags ^= 1;
+        for (size_t i = 0; i < tx.vin.size(); i++) {
+            s >> tx.vin[i].scriptWitness.stack;
+        }
+        if (!tx.HasWitness()) {
+            /* It's illegal to encode witnesses when all witness stacks are empty. */
+            throw std::ios_base::failure("Superfluous witness record");
+        }
+    }
+
+    // segOP payload (bit 1)
+    if (flags & 2) {
+        flags ^= 2;
+
+        // Read and validate segOP marker 0x53 ('S')
+        unsigned char segop_marker = 0;
+        s >> segop_marker;
+        if (segop_marker != 0x53) {
+            throw std::ios_base::failure("Invalid segOP marker");
+        }
+
+        // Then deserialize version + len + bytes from CSegopPayload
+        s >> tx.segop_payload;
+    }
+
+    if (flags) {
+        /* Unknown flag in the serialization */
+        throw std::ios_base::failure("Unknown transaction optional data");
+    }
+    s >> tx.nLockTime;
+}
+
+template<typename Stream, typename TxType>
+void SerializeTransaction(const TxType& tx, Stream& s, const TransactionSerParams& params)
+{
+    const bool fAllowWitness = params.allow_witness;
+
+    s << tx.version;
+    unsigned char flags = 0;
+
+    // Witness flag (bit 0)
+    if (fAllowWitness && tx.HasWitness()) {
+        flags |= 1;
+    }
+    // segOP flag (bit 1)
+    if (!tx.segop_payload.IsNull()) {
+        flags |= 2;
+    }
+
+    if (flags) {
+        /* Use extended format in case any optional sections are to be serialized. */
+        std::vector<CTxIn> vinDummy;
+        s << vinDummy;
+        s << flags;
+    }
+
+    s << tx.vin;
+    s << tx.vout;
+
+    if ((flags & 1) && fAllowWitness) {
+        for (size_t i = 0; i < tx.vin.size(); i++) {
+            s << tx.vin[i].scriptWitness.stack;
+        }
+    }
+
+    if (flags & 2) {
+        // segOP marker 0x53 ('S') followed by payload (version + len + bytes)
+        unsigned char segop_marker = 0x53;
+        s << segop_marker;
+        s << tx.segop_payload;
+    }
+
+    s << tx.nLockTime;
+}
+
+template<typename TxType>
+inline CAmount CalculateOutputValue(const TxType& tx)
+{
+    return std::accumulate(tx.vout.cbegin(), tx.vout.cend(), CAmount{0}, [](CAmount sum, const auto& txout) { return sum + txout.nValue; });
+}
+
+
+/** The basic transaction that is broadcasted on the network and contained in
+ * blocks.  A transaction can contain multiple inputs and outputs.
+ */
+class CTransaction
+{
+public:
+    // Default transaction version.
+    static const uint32_t CURRENT_VERSION{2};
+
+    // The local variables are made const to prevent unintended modification
+    // without updating the cached hash value. However, CTransaction is not
+    // actually immutable; deserialization and assignment are implemented,
+    // and bypass the constness. This is safe, as they update the entire
+    // structure, including the hash.
+    const std::vector<CTxIn> vin;
+    const std::vector<CTxOut> vout;
+    const uint32_t version;
+    const uint32_t nLockTime;
+
+    // segOP: attached payload
+    const CSegopPayload segop_payload;
+
+private:
+    /** Memory only. */
+    const bool m_has_witness;
+    const Txid hash;
+    const Wtxid m_witness_hash;
+
+    Txid ComputeHash() const;
+    Wtxid ComputeWitnessHash() const;
+
+    bool ComputeHasWitness() const;
+
+public:
+    /** Convert a CMutableTransaction into a CTransaction. */
+    explicit CTransaction(const CMutableTransaction& tx);
+    explicit CTransaction(CMutableTransaction&& tx);
+
+    template <typename Stream>
+    inline void Serialize(Stream& s) const {
+        SerializeTransaction(*this, s, s.template GetParams<TransactionSerParams>());
+    }
+
+    /** This deserializing constructor is provided instead of an Unserialize method.
+     *  Unserialize is not possible, since it would require overwriting const fields. */
+    template <typename Stream>
+    CTransaction(deserialize_type, const TransactionSerParams& params, Stream& s) : CTransaction(CMutableTransaction(deserialize, params, s)) {}
+    template <typename Stream>
+    CTransaction(deserialize_type, Stream& s) : CTransaction(CMutableTransaction(deserialize, s)) {}
+
+    bool IsNull() const {
+        return vin.empty() && vout.empty();
+    }
+
+    const Txid& GetHash() const LIFETIMEBOUND { return hash; }
+    const Wtxid& GetWitnessHash() const LIFETIMEBOUND { return m_witness_hash; };
+
+    // Return sum of txouts.
+    CAmount GetValueOut() const;
+
+    /**
+     * Get the total transaction size in bytes, including witness data and segOP.
+     * "Total Size" defined in BIP141 and BIP144 plus segOP section.
+     * @return Total transaction size in bytes
+     */
+    unsigned int GetTotalSize() const;
+
+    bool IsCoinBase() const
+    {
+        return (vin.size() == 1 && vin[0].prevout.IsNull());
+    }
+
+    friend bool operator==(const CTransaction& a, const CTransaction& b)
+    {
+        return a.GetWitnessHash() == b.GetWitnessHash();
+    }
+
+    friend bool operator!=(const CTransaction& a, const CTransaction& b)
+    {
+        return !operator==(a, b);
+    }
+
+    std::string ToString() const;
+
+    bool HasWitness() const { return m_has_witness; }
+};
+
+/** A mutable version of CTransaction. */
+struct CMutableTransaction
+{
+    std::vector<CTxIn> vin;
+    std::vector<CTxOut> vout;
+    uint32_t version;
+    uint32_t nLockTime;
+
+    // segOP: mutable payload
+    CSegopPayload segop_payload;
+
+    explicit CMutableTransaction();
+    explicit CMutableTransaction(const CTransaction& tx);
+
+    template <typename Stream>
+    inline void Serialize(Stream& s) const {
+        SerializeTransaction(*this, s, s.template GetParams<TransactionSerParams>());
+    }
+
+    template <typename Stream>
+    inline void Unserialize(Stream& s) {
+        UnserializeTransaction(*this, s, s.template GetParams<TransactionSerParams>());
+    }
+
+    template <typename Stream>
+    CMutableTransaction(deserialize_type, const TransactionSerParams& params, Stream& s) {
+        UnserializeTransaction(*this, s, params);
+    }
+
+    template <typename Stream>
+    CMutableTransaction(deserialize_type, Stream& s) {
+        Unserialize(s);
+    }
+
+    /** Compute the hash of this CMutableTransaction. This is computed on the
+     * fly, as opposed to GetHash() in CTransaction, which uses a cached result.
+     */
+    Txid GetHash() const;
+
+    bool HasWitness() const
+    {
+        for (size_t i = 0; i < vin.size(); i++) {
+            if (!vin[i].scriptWitness.IsNull()) {
+                return true;
+            }
+        }
+        return false;
+    }
+};
+
+typedef std::shared_ptr<const CTransaction> CTransactionRef;
+template <typename Tx> static inline CTransactionRef MakeTransactionRef(Tx&& txIn) { return std::make_shared<const CTransaction>(std::forward<Tx>(txIn)); }
+
+#endif // BITCOIN_PRIMITIVES_TRANSACTION_H
diff --git a/src_v1/src/rpc/rawtransaction.cpp b/src_v1/src/rpc/rawtransaction.cpp
new file mode 100644
index 0000000000..61dac69374
--- /dev/null
+++ b/src_v1/src/rpc/rawtransaction.cpp
@@ -0,0 +1,2199 @@
+// Copyright (c) 2010 Satoshi Nakamoto
+// Copyright (c) 2009-present The Bitcoin Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#include <base58.h>
+#include <chain.h>
+#include <coins.h>
+#include <consensus/amount.h>
+#include <consensus/validation.h>
+#include <core_io.h>
+#include <index/txindex.h>
+#include <key_io.h>
+#include <node/blockstorage.h>
+#include <node/coin.h>
+#include <node/context.h>
+#include <node/psbt.h>
+#include <node/transaction.h>
+#include <node/types.h>
+#include <policy/packages.h>
+#include <policy/policy.h>
+#include <policy/rbf.h>
+#include <primitives/transaction.h>
+#include <psbt.h>
+#include <random.h>
+#include <rpc/blockchain.h>
+#include <rpc/rawtransaction_util.h>
+#include <rpc/server.h>
+#include <rpc/server_util.h>
+#include <rpc/util.h>
+#include <script/script.h>
+#include <script/sign.h>
+#include <script/signingprovider.h>
+#include <script/solver.h>
+#include <uint256.h>
+#include <undo.h>
+#include <util/bip32.h>
+#include <util/check.h>
+#include <util/strencodings.h>
+#include <util/string.h>
+#include <util/vector.h>
+#include <validation.h>
+#include <validationinterface.h>
+
+#include <cstdint>
+#include <numeric>
+
+#include <univalue.h>
+
+using node::AnalyzePSBT;
+using node::FindCoins;
+using node::GetTransaction;
+using node::NodeContext;
+using node::PSBTAnalysis;
+
+static constexpr decltype(CTransaction::version) DEFAULT_RAWTX_VERSION{CTransaction::CURRENT_VERSION};
+
+static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry,
+                     Chainstate& active_chainstate, const CTxUndo* txundo = nullptr,
+                     TxVerbosity verbosity = TxVerbosity::SHOW_DETAILS)
+{
+    CHECK_NONFATAL(verbosity >= TxVerbosity::SHOW_DETAILS);
+    // Call into TxToUniv() in bitcoin-common to decode the transaction hex.
+    //
+    // Blockchain contextual information (confirmations and blocktime) is not
+    // available to code in bitcoin-common, so we query them here and push the
+    // data into the returned UniValue.
+    TxToUniv(tx, /*block_hash=*/uint256(), entry, /*include_hex=*/true, txundo, verbosity);
+
+    if (!hashBlock.IsNull()) {
+        LOCK(cs_main);
+
+        entry.pushKV("blockhash", hashBlock.GetHex());
+        const CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(hashBlock);
+        if (pindex) {
+            if (active_chainstate.m_chain.Contains(pindex)) {
+                entry.pushKV("confirmations", 1 + active_chainstate.m_chain.Height() - pindex->nHeight);
+                entry.pushKV("time", pindex->GetBlockTime());
+                entry.pushKV("blocktime", pindex->GetBlockTime());
+            }
+            else
+                entry.pushKV("confirmations", 0);
+        }
+    }
+}
+
+static std::vector<RPCResult> DecodeTxDoc(const std::string& txid_field_doc)
+{
+    return {
+        {RPCResult::Type::STR_HEX, "txid", txid_field_doc},
+        {RPCResult::Type::STR_HEX, "hash", "The transaction hash (differs from txid for witness transactions)"},
+        {RPCResult::Type::NUM, "size", "The serialized transaction size"},
+        {RPCResult::Type::NUM, "vsize", "The virtual transaction size (differs from size for witness transactions)"},
+        {RPCResult::Type::NUM, "weight", "The transaction's weight (between vsize*4-3 and vsize*4)"},
+        {RPCResult::Type::NUM, "version", "The version"},
+        {RPCResult::Type::NUM_TIME, "locktime", "The lock time"},
+        {RPCResult::Type::ARR, "vin", "",
+        {
+            {RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR_HEX, "coinbase", /*optional=*/true, "The coinbase value (only if coinbase transaction)"},
+                {RPCResult::Type::STR_HEX, "txid", /*optional=*/true, "The transaction id (if not coinbase transaction)"},
+                {RPCResult::Type::NUM, "vout", /*optional=*/true, "The output number (if not coinbase transaction)"},
+                {RPCResult::Type::OBJ, "scriptSig", /*optional=*/true, "The script (if not coinbase transaction)",
+                {
+                    {RPCResult::Type::STR, "asm", "Disassembly of the signature script"},
+                    {RPCResult::Type::STR_HEX, "hex", "The raw signature script bytes, hex-encoded"},
+                }},
+                {RPCResult::Type::ARR, "txinwitness", /*optional=*/true, "",
+                {
+                    {RPCResult::Type::STR_HEX, "hex", "hex-encoded witness data (if any)"},
+                }},
+                {RPCResult::Type::NUM, "sequence", "The script sequence number"},
+            }},
+        }},
+        {RPCResult::Type::ARR, "vout", "",
+        {
+            {RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR_AMOUNT, "value", "The value in " + CURRENCY_UNIT},
+                {RPCResult::Type::NUM, "n", "index"},
+                {RPCResult::Type::OBJ, "scriptPubKey", "", ScriptPubKeyDoc()},
+            }},
+        }},
+    };
+}
+
+static std::vector<RPCArg> CreateTxDoc()
+{
+    return {
+        {"inputs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The inputs",
+            {
+                {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                    {
+                        {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                        {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                        {"sequence", RPCArg::Type::NUM, RPCArg::DefaultHint{"depends on the value of the 'replaceable' and 'locktime' arguments"}, "The sequence number"},
+                    },
+                },
+            },
+        },
+        {"outputs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The outputs specified as key-value pairs.\n"
+                "Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.\n"
+                "At least one output of either type must be specified.\n"
+                "For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\n"
+                "                             accepted as second parameter.",
+            {
+                {"", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, "",
+                    {
+                        {"address", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, "A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in " + CURRENCY_UNIT},
+                    },
+                },
+                {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                    {
+                        {"data", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "A key-value pair. The key must be \"data\", the value is hex-encoded data that becomes a part of an OP_RETURN output"},
+                    },
+                },
+            },
+         RPCArgOptions{.skip_type_check = true}},
+        {"locktime", RPCArg::Type::NUM, RPCArg::Default{0}, "Raw locktime. Non-0 value also locktime-activates inputs"},
+        {"replaceable", RPCArg::Type::BOOL, RPCArg::Default{true}, "Marks this transaction as BIP125-replaceable.\n"
+                "Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible."},
+        {"version", RPCArg::Type::NUM, RPCArg::Default{DEFAULT_RAWTX_VERSION}, "Transaction version"},
+    };
+}
+
+// Update PSBT with information from the mempool, the UTXO set, the txindex, and the provided descriptors.
+// Optionally, sign the inputs that we can using information from the descriptors.
+PartiallySignedTransaction ProcessPSBT(const std::string& psbt_string, const std::any& context, const HidingSigningProvider& provider, std::optional<int> sighash_type, bool finalize)
+{
+    // Unserialize the transactions
+    PartiallySignedTransaction psbtx;
+    std::string error;
+    if (!DecodeBase64PSBT(psbtx, psbt_string, error)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+    }
+
+    if (g_txindex) g_txindex->BlockUntilSyncedToCurrentChain();
+    const NodeContext& node = EnsureAnyNodeContext(context);
+
+    // If we can't find the corresponding full transaction for all of our inputs,
+    // this will be used to find just the utxos for the segwit inputs for which
+    // the full transaction isn't found
+    std::map<COutPoint, Coin> coins;
+
+    // Fetch previous transactions:
+    // First, look in the txindex and the mempool
+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+        PSBTInput& psbt_input = psbtx.inputs.at(i);
+        const CTxIn& tx_in = psbtx.tx->vin.at(i);
+
+        // The `non_witness_utxo` is the whole previous transaction
+        if (psbt_input.non_witness_utxo) continue;
+
+        CTransactionRef tx;
+
+        // Look in the txindex
+        if (g_txindex) {
+            uint256 block_hash;
+            g_txindex->FindTx(tx_in.prevout.hash, block_hash, tx);
+        }
+        // If we still don't have it look in the mempool
+        if (!tx) {
+            tx = node.mempool->get(tx_in.prevout.hash);
+        }
+        if (tx) {
+            psbt_input.non_witness_utxo = tx;
+        } else {
+            coins[tx_in.prevout]; // Create empty map entry keyed by prevout
+        }
+    }
+
+    // If we still haven't found all of the inputs, look for the missing ones in the utxo set
+    if (!coins.empty()) {
+        FindCoins(node, coins);
+        for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+            PSBTInput& input = psbtx.inputs.at(i);
+
+            // If there are still missing utxos, add them if they were found in the utxo set
+            if (!input.non_witness_utxo) {
+                const CTxIn& tx_in = psbtx.tx->vin.at(i);
+                const Coin& coin = coins.at(tx_in.prevout);
+                if (!coin.out.IsNull() && IsSegWitOutput(provider, coin.out.scriptPubKey)) {
+                    input.witness_utxo = coin.out;
+                }
+            }
+        }
+    }
+
+    const PrecomputedTransactionData& txdata = PrecomputePSBTData(psbtx);
+
+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+        if (PSBTInputSigned(psbtx.inputs.at(i))) {
+            continue;
+        }
+
+        // Update script/keypath information using descriptor data.
+        // Note that SignPSBTInput does a lot more than just constructing ECDSA signatures.
+        // We only actually care about those if our signing provider doesn't hide private
+        // information, as is the case with `descriptorprocesspsbt`
+        // Only error for mismatching sighash types as it is critical that the sighash to sign with matches the PSBT's
+        if (SignPSBTInput(provider, psbtx, /*index=*/i, &txdata, sighash_type, /*out_sigdata=*/nullptr, finalize) == common::PSBTError::SIGHASH_MISMATCH) {
+            throw JSONRPCPSBTError(common::PSBTError::SIGHASH_MISMATCH);
+        }
+    }
+
+    // Update script/keypath information using descriptor data.
+    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {
+        UpdatePSBTOutput(provider, psbtx, i);
+    }
+
+    RemoveUnnecessaryTransactions(psbtx);
+
+    return psbtx;
+}
+
+static RPCHelpMan getrawtransaction()
+{
+    return RPCHelpMan{
+                "getrawtransaction",
+
+                "By default, this call only returns a transaction if it is in the mempool. If -txindex is enabled\n"
+                "and no blockhash argument is passed, it will return the transaction if it is in the mempool or any block.\n"
+                "If a blockhash argument is passed, it will return the transaction if\n"
+                "the specified block is available and the transaction is in that block.\n\n"
+                "Hint: Use gettransaction for wallet transactions.\n\n"
+
+                "If verbosity is 0 or omitted, returns the serialized transaction as a hex-encoded string.\n"
+                "If verbosity is 1, returns a JSON Object with information about the transaction.\n"
+                "If verbosity is 2, returns a JSON Object with information about the transaction, including fee and prevout information.",
+                {
+                    {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                    {"verbosity|verbose", RPCArg::Type::NUM, RPCArg::Default{0}, "0 for hex-encoded data, 1 for a JSON object, and 2 for JSON object with fee and prevout",
+                     RPCArgOptions{.skip_type_check = true}},
+                    {"blockhash", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "The block in which to look for the transaction"},
+                },
+                {
+                    RPCResult{"if verbosity is not set or set to 0",
+                         RPCResult::Type::STR, "data", "The serialized transaction as a hex-encoded string for 'txid'"
+                     },
+                     RPCResult{"if verbosity is set to 1",
+                         RPCResult::Type::OBJ, "", "",
+                         Cat<std::vector<RPCResult>>(
+                         {
+                             {RPCResult::Type::BOOL, "in_active_chain", /*optional=*/true, "Whether specified block is in the active chain or not (only present with explicit \"blockhash\" argument)"},
+                             {RPCResult::Type::STR_HEX, "blockhash", /*optional=*/true, "the block hash"},
+                             {RPCResult::Type::NUM, "confirmations", /*optional=*/true, "The confirmations"},
+                             {RPCResult::Type::NUM_TIME, "blocktime", /*optional=*/true, "The block time expressed in " + UNIX_EPOCH_TIME},
+                             {RPCResult::Type::NUM, "time", /*optional=*/true, "Same as \"blocktime\""},
+                             {RPCResult::Type::STR_HEX, "hex", "The serialized, hex-encoded data for 'txid'"},
+                         },
+                         DecodeTxDoc(/*txid_field_doc=*/"The transaction id (same as provided)")),
+                    },
+                    RPCResult{"for verbosity = 2",
+                        RPCResult::Type::OBJ, "", "",
+                        {
+                            {RPCResult::Type::ELISION, "", "Same output as verbosity = 1"},
+                            {RPCResult::Type::NUM, "fee", /*optional=*/true, "transaction fee in " + CURRENCY_UNIT + ", omitted if block undo data is not available"},
+                            {RPCResult::Type::ARR, "vin", "",
+                            {
+                                {RPCResult::Type::OBJ, "", "utxo being spent",
+                                {
+                                    {RPCResult::Type::ELISION, "", "Same output as verbosity = 1"},
+                                    {RPCResult::Type::OBJ, "prevout", /*optional=*/true, "The previous output, omitted if block undo data is not available",
+                                    {
+                                        {RPCResult::Type::BOOL, "generated", "Coinbase or not"},
+                                        {RPCResult::Type::NUM, "height", "The height of the prevout"},
+                                        {RPCResult::Type::STR_AMOUNT, "value", "The value in " + CURRENCY_UNIT},
+                                        {RPCResult::Type::OBJ, "scriptPubKey", "", ScriptPubKeyDoc()},
+                                    }},
+                                }},
+                            }},
+                        }},
+                },
+                RPCExamples{
+                    HelpExampleCli("getrawtransaction", "\"mytxid\"")
+            + HelpExampleCli("getrawtransaction", "\"mytxid\" 1")
+            + HelpExampleRpc("getrawtransaction", "\"mytxid\", 1")
+            + HelpExampleCli("getrawtransaction", "\"mytxid\" 0 \"myblockhash\"")
+            + HelpExampleCli("getrawtransaction", "\"mytxid\" 1 \"myblockhash\"")
+            + HelpExampleCli("getrawtransaction", "\"mytxid\" 2 \"myblockhash\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    const NodeContext& node = EnsureAnyNodeContext(request.context);
+    ChainstateManager& chainman = EnsureChainman(node);
+
+    auto txid{Txid::FromUint256(ParseHashV(request.params[0], "parameter 1"))};
+    const CBlockIndex* blockindex = nullptr;
+
+    if (txid.ToUint256() == chainman.GetParams().GenesisBlock().hashMerkleRoot) {
+        // Special exception for the genesis block coinbase transaction
+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "The genesis block coinbase is not considered an ordinary transaction and cannot be retrieved");
+    }
+
+    int verbosity{ParseVerbosity(request.params[1], /*default_verbosity=*/0, /*allow_bool=*/true)};
+
+    if (!request.params[2].isNull()) {
+        LOCK(cs_main);
+
+        uint256 blockhash = ParseHashV(request.params[2], "parameter 3");
+        blockindex = chainman.m_blockman.LookupBlockIndex(blockhash);
+        if (!blockindex) {
+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block hash not found");
+        }
+    }
+
+    bool f_txindex_ready = false;
+    if (g_txindex && !blockindex) {
+        f_txindex_ready = g_txindex->BlockUntilSyncedToCurrentChain();
+    }
+
+    uint256 hash_block;
+    const CTransactionRef tx = GetTransaction(blockindex, node.mempool.get(), txid, hash_block, chainman.m_blockman);
+    if (!tx) {
+        std::string errmsg;
+        if (blockindex) {
+            const bool block_has_data = WITH_LOCK(::cs_main, return blockindex->nStatus & BLOCK_HAVE_DATA);
+            if (!block_has_data) {
+                throw JSONRPCError(RPC_MISC_ERROR, "Block not available");
+            }
+            errmsg = "No such transaction found in the provided block";
+        } else if (!g_txindex) {
+            errmsg = "No such mempool transaction. Use -txindex or provide a block hash to enable blockchain transaction queries";
+        } else if (!f_txindex_ready) {
+            errmsg = "No such mempool transaction. Blockchain transactions are still in the process of being indexed";
+        } else {
+            errmsg = "No such mempool or blockchain transaction";
+        }
+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errmsg + ". Use gettransaction for wallet transactions.");
+    }
+
+    if (verbosity <= 0) {
+        return EncodeHexTx(*tx);
+    }
+
+    UniValue result(UniValue::VOBJ);
+    if (blockindex) {
+        LOCK(cs_main);
+        result.pushKV("in_active_chain", chainman.ActiveChain().Contains(blockindex));
+    }
+    // If request is verbosity >= 1 but no blockhash was given, then look up the blockindex
+    if (request.params[2].isNull()) {
+        LOCK(cs_main);
+        blockindex = chainman.m_blockman.LookupBlockIndex(hash_block); // May be nullptr for mempool transactions
+    }
+    if (verbosity == 1) {
+        TxToJSON(*tx, hash_block, result, chainman.ActiveChainstate());
+        return result;
+    }
+
+    CBlockUndo blockUndo;
+    CBlock block;
+
+    if (tx->IsCoinBase() || !blockindex || WITH_LOCK(::cs_main, return !(blockindex->nStatus & BLOCK_HAVE_MASK))) {
+        TxToJSON(*tx, hash_block, result, chainman.ActiveChainstate());
+        return result;
+    }
+    if (!chainman.m_blockman.ReadBlockUndo(blockUndo, *blockindex)) {
+        throw JSONRPCError(RPC_INTERNAL_ERROR, "Undo data expected but can't be read. This could be due to disk corruption or a conflict with a pruning event.");
+    }
+    if (!chainman.m_blockman.ReadBlock(block, *blockindex)) {
+        throw JSONRPCError(RPC_INTERNAL_ERROR, "Block data expected but can't be read. This could be due to disk corruption or a conflict with a pruning event.");
+    }
+
+    CTxUndo* undoTX {nullptr};
+    auto it = std::find_if(block.vtx.begin(), block.vtx.end(), [tx](CTransactionRef t){ return *t == *tx; });
+    if (it != block.vtx.end()) {
+        // -1 as blockundo does not have coinbase tx
+        undoTX = &blockUndo.vtxundo.at(it - block.vtx.begin() - 1);
+    }
+    TxToJSON(*tx, hash_block, result, chainman.ActiveChainstate(), undoTX, TxVerbosity::SHOW_DETAILS_AND_PREVOUT);
+    return result;
+},
+    };
+}
+
+static RPCHelpMan createrawtransaction()
+{
+    return RPCHelpMan{
+        "createrawtransaction",
+        "Create a transaction spending the given inputs and creating new outputs.\n"
+                "Outputs can be addresses or data.\n"
+                "Returns hex-encoded raw transaction.\n"
+                "Note that the transaction's inputs are not signed, and\n"
+                "it is not stored in the wallet or transmitted to the network.\n",
+                CreateTxDoc(),
+                RPCResult{
+                    RPCResult::Type::STR_HEX, "transaction", "hex string of the transaction"
+                },
+                RPCExamples{
+                    HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"address\\\":0.01}]\"")
+            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\"")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"address\\\":0.01}]\"")
+            + HelpExampleRpc("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\", \"[{\\\"data\\\":\\\"00010203\\\"}]\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    std::optional<bool> rbf;
+    if (!request.params[3].isNull()) {
+        rbf = request.params[3].get_bool();
+    }
+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf, self.Arg<uint32_t>("version"));
+
+    return EncodeHexTx(CTransaction(rawTx));
+},
+    };
+}
+
+static RPCHelpMan decoderawtransaction()
+{
+    return RPCHelpMan{"decoderawtransaction",
+                "Return a JSON object representing the serialized, hex-encoded transaction.",
+                {
+                    {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction hex string"},
+                    {"iswitness", RPCArg::Type::BOOL, RPCArg::DefaultHint{"depends on heuristic tests"}, "Whether the transaction hex is a serialized witness transaction.\n"
+                        "If iswitness is not present, heuristic tests will be used in decoding.\n"
+                        "If true, only witness deserialization will be tried.\n"
+                        "If false, only non-witness deserialization will be tried.\n"
+                        "This boolean should reflect whether the transaction has inputs\n"
+                        "(e.g. fully valid, or on-chain transactions), if known by the caller."
+                    },
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    DecodeTxDoc(/*txid_field_doc=*/"The transaction id"),
+                },
+                RPCExamples{
+                    HelpExampleCli("decoderawtransaction", "\"hexstring\"")
+            + HelpExampleRpc("decoderawtransaction", "\"hexstring\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    CMutableTransaction mtx;
+
+    bool try_witness = request.params[1].isNull() ? true : request.params[1].get_bool();
+    bool try_no_witness = request.params[1].isNull() ? true : !request.params[1].get_bool();
+
+    if (!DecodeHexTx(mtx, request.params[0].get_str(), try_no_witness, try_witness)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+    }
+
+    UniValue result(UniValue::VOBJ);
+    TxToUniv(CTransaction(std::move(mtx)), /*block_hash=*/uint256(), /*entry=*/result, /*include_hex=*/false);
+
+    return result;
+},
+    };
+}
+
+static RPCHelpMan createsegoptx()
+{
+    return RPCHelpMan{
+        "createsegoptx",
+        "Attach a segOP payload to an existing raw transaction.\n"
+        "Takes a standard raw transaction hex string, sets segOP version=1 and the given payload,\n"
+        "and returns the re-serialized transaction hex (using the extended segOP-aware format).\n",
+        {
+            {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO,
+             "The transaction hex string (non-segOP or segOP-neutral)"},
+            {"payload",   RPCArg::Type::STR_HEX, RPCArg::Optional::NO,
+             "Hex-encoded segOP payload bytes"},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR_HEX, "hex",
+                 "The hex-encoded transaction with segOP payload attached"},
+            }
+        },
+        RPCExamples{
+            HelpExampleCli("createsegoptx", "\"0200000001...\" \"01020304\"") +
+            HelpExampleRpc("createsegoptx", "\"0200000001...\", \"01020304\"")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+        {
+            // Decode the input tx using the normal heuristics (witness or not)
+            CMutableTransaction mtx;
+            if (!DecodeHexTx(mtx,
+                             request.params[0].get_str(),
+                             /*try_no_witness=*/true,
+                             /*try_witness=*/true)) {
+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+            }
+
+            const std::string payload_hex = request.params[1].get_str();
+            if (!IsHex(payload_hex)) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER,
+                                   "Payload must be hex string");
+            }
+            std::vector<unsigned char> payload = ParseHex(payload_hex);
+
+            // Attach segOP payload; version 1 for now
+            mtx.segop_payload.version = 1;
+            mtx.segop_payload.data = std::move(payload);
+
+            // Serialize using the extended (witness+segOP-aware) format
+            DataStream ssTx{};
+            ssTx << TX_WITH_WITNESS(mtx);
+
+            UniValue result(UniValue::VOBJ);
+            result.pushKV("hex", HexStr(ssTx));
+            return result;
+        }
+    };
+}
+
+
+static RPCHelpMan decodescript()
+{
+    return RPCHelpMan{
+        "decodescript",
+        "Decode a hex-encoded script.\n",
+        {
+            {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "the hex-encoded script"},
+        },
+        RPCResult{
+            RPCResult::Type::OBJ, "", "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the script"},
+                {RPCResult::Type::STR, "desc", "Inferred descriptor for the script"},
+                {RPCResult::Type::STR, "type", "The output type (e.g. " + GetAllOutputTypes() + ")"},
+                {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
+                {RPCResult::Type::STR, "p2sh", /*optional=*/true,
+                 "address of P2SH script wrapping this redeem script (not returned for types that should not be wrapped)"},
+                {RPCResult::Type::OBJ, "segwit", /*optional=*/true,
+                 "Result of a witness output script wrapping this redeem script (not returned for types that should not be wrapped)",
+                 {
+                     {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
+                     {RPCResult::Type::STR_HEX, "hex", "The raw output script bytes, hex-encoded"},
+                     {RPCResult::Type::STR, "type", "The type of the output script (e.g. witness_v0_keyhash or witness_v0_scripthash)"},
+                     {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
+                     {RPCResult::Type::STR, "desc", "Inferred descriptor for the script"},
+                     {RPCResult::Type::STR, "p2sh-segwit", "address of the P2SH script wrapping this witness redeem script"},
+                 }},
+            },
+        },
+        RPCExamples{
+            HelpExampleCli("decodescript", "\"hexstring\"")
+          + HelpExampleRpc("decodescript", "\"hexstring\"")
+        },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    UniValue r(UniValue::VOBJ);
+    CScript script;
+    if (request.params[0].get_str().size() > 0){
+        std::vector<unsigned char> scriptData(ParseHexV(request.params[0], "argument"));
+        script = CScript(scriptData.begin(), scriptData.end());
+    } else {
+        // Empty scripts are valid
+    }
+    ScriptToUniv(script, /*out=*/r, /*include_hex=*/false, /*include_address=*/true);
+
+    std::vector<std::vector<unsigned char>> solutions_data;
+    const TxoutType which_type{Solver(script, solutions_data)};
+
+    const bool can_wrap{[&] {
+        switch (which_type) {
+        case TxoutType::MULTISIG:
+        case TxoutType::NONSTANDARD:
+        case TxoutType::PUBKEY:
+        case TxoutType::PUBKEYHASH:
+        case TxoutType::WITNESS_V0_KEYHASH:
+        case TxoutType::WITNESS_V0_SCRIPTHASH:
+            // Can be wrapped if the checks below pass
+            break;
+        case TxoutType::NULL_DATA:
+        case TxoutType::SCRIPTHASH:
+        case TxoutType::WITNESS_UNKNOWN:
+        case TxoutType::WITNESS_V1_TAPROOT:
+        case TxoutType::ANCHOR:
+            // Should not be wrapped
+            return false;
+        } // no default case, so the compiler can warn about missing cases
+        if (!script.HasValidOps() || script.IsUnspendable()) {
+            return false;
+        }
+        for (CScript::const_iterator it{script.begin()}; it != script.end();) {
+            opcodetype op;
+            CHECK_NONFATAL(script.GetOp(it, op));
+            if (op == OP_CHECKSIGADD || IsOpSuccess(op)) {
+                return false;
+            }
+        }
+        return true;
+    }()};
+
+    if (can_wrap) {
+        r.pushKV("p2sh", EncodeDestination(ScriptHash(script)));
+        // P2SH and witness programs cannot be wrapped in P2WSH, if this script
+        // is a witness program, don't return addresses for a segwit programs.
+        const bool can_wrap_P2WSH{[&] {
+            switch (which_type) {
+            case TxoutType::MULTISIG:
+            case TxoutType::PUBKEY:
+            // Uncompressed pubkeys cannot be used with segwit checksigs.
+            // If the script contains an uncompressed pubkey, skip encoding of a segwit program.
+                for (const auto& solution : solutions_data) {
+                    if ((solution.size() != 1) && !CPubKey(solution).IsCompressed()) {
+                        return false;
+                    }
+                }
+                return true;
+            case TxoutType::NONSTANDARD:
+            case TxoutType::PUBKEYHASH:
+                // Can be P2WSH wrapped
+                return true;
+            case TxoutType::NULL_DATA:
+            case TxoutType::SCRIPTHASH:
+            case TxoutType::WITNESS_UNKNOWN:
+            case TxoutType::WITNESS_V0_KEYHASH:
+            case TxoutType::WITNESS_V0_SCRIPTHASH:
+            case TxoutType::WITNESS_V1_TAPROOT:
+            case TxoutType::ANCHOR:
+                // Should not be wrapped
+                return false;
+            } // no default case, so the compiler can warn about missing cases
+            NONFATAL_UNREACHABLE();
+        }()};
+        if (can_wrap_P2WSH) {
+            UniValue sr(UniValue::VOBJ);
+            CScript segwitScr;
+            FlatSigningProvider provider;
+            if (which_type == TxoutType::PUBKEY) {
+                segwitScr = GetScriptForDestination(WitnessV0KeyHash(Hash160(solutions_data[0])));
+            } else if (which_type == TxoutType::PUBKEYHASH) {
+                segwitScr = GetScriptForDestination(WitnessV0KeyHash(uint160{solutions_data[0]}));
+            } else {
+                // Scripts that are not fit for P2WPKH are encoded as P2WSH.
+                provider.scripts[CScriptID(script)] = script;
+                segwitScr = GetScriptForDestination(WitnessV0ScriptHash(script));
+            }
+            ScriptToUniv(segwitScr, /*out=*/sr, /*include_hex=*/true, /*include_address=*/true, /*provider=*/&provider);
+            sr.pushKV("p2sh-segwit", EncodeDestination(ScriptHash(segwitScr)));
+            r.pushKV("segwit", std::move(sr));
+        }
+    }
+
+    return r;
+},
+    };
+}
+
+static RPCHelpMan combinerawtransaction()
+{
+    return RPCHelpMan{
+        "combinerawtransaction",
+        "Combine multiple partially signed transactions into one transaction.\n"
+                "The combined transaction may be another partially signed transaction or a \n"
+                "fully signed transaction.",
+                {
+                    {"txs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The hex strings of partially signed transactions",
+                        {
+                            {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "A hex-encoded raw transaction"},
+                        },
+                        },
+                },
+                RPCResult{
+                    RPCResult::Type::STR, "", "The hex-encoded raw transaction with signature(s)"
+                },
+                RPCExamples{
+                    HelpExampleCli("combinerawtransaction", R"('["myhex1", "myhex2", "myhex3"]')")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+
+    UniValue txs = request.params[0].get_array();
+    std::vector<CMutableTransaction> txVariants(txs.size());
+
+    for (unsigned int idx = 0; idx < txs.size(); idx++) {
+        if (!DecodeHexTx(txVariants[idx], txs[idx].get_str())) {
+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed for tx %d. Make sure the tx has at least one input.", idx));
+        }
+    }
+
+    if (txVariants.empty()) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Missing transactions");
+    }
+
+    // mergedTx will end up with all the signatures; it
+    // starts as a clone of the rawtx:
+    CMutableTransaction mergedTx(txVariants[0]);
+
+    // Fetch previous transactions (inputs):
+    CCoinsView viewDummy;
+    CCoinsViewCache view(&viewDummy);
+    {
+        NodeContext& node = EnsureAnyNodeContext(request.context);
+        const CTxMemPool& mempool = EnsureMemPool(node);
+        ChainstateManager& chainman = EnsureChainman(node);
+        LOCK2(cs_main, mempool.cs);
+        CCoinsViewCache &viewChain = chainman.ActiveChainstate().CoinsTip();
+        CCoinsViewMemPool viewMempool(&viewChain, mempool);
+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view
+
+        for (const CTxIn& txin : mergedTx.vin) {
+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.
+        }
+
+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long
+    }
+
+    // Use CTransaction for the constant parts of the
+    // transaction to avoid rehashing.
+    const CTransaction txConst(mergedTx);
+    // Sign what we can:
+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {
+        CTxIn& txin = mergedTx.vin[i];
+        const Coin& coin = view.AccessCoin(txin.prevout);
+        if (coin.IsSpent()) {
+            throw JSONRPCError(RPC_VERIFY_ERROR, "Input not found or already spent");
+        }
+        SignatureData sigdata;
+
+        // ... and merge in other signatures:
+        for (const CMutableTransaction& txv : txVariants) {
+            if (txv.vin.size() > i) {
+                sigdata.MergeSignatureData(DataFromTransaction(txv, i, coin.out));
+            }
+        }
+        ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(mergedTx, i, coin.out.nValue, 1), coin.out.scriptPubKey, sigdata);
+
+        UpdateInput(txin, sigdata);
+    }
+
+    return EncodeHexTx(CTransaction(mergedTx));
+},
+    };
+}
+
+static RPCHelpMan signrawtransactionwithkey()
+{
+    return RPCHelpMan{
+        "signrawtransactionwithkey",
+        "Sign inputs for raw transaction (serialized, hex-encoded).\n"
+                "The second argument is an array of base58-encoded private\n"
+                "keys that will be the only keys used to sign the transaction.\n"
+                "The third optional argument (may be null) is an array of previous transaction outputs that\n"
+                "this transaction depends on but may not yet be in the block chain.\n",
+                {
+                    {"hexstring", RPCArg::Type::STR, RPCArg::Optional::NO, "The transaction hex string"},
+                    {"privkeys", RPCArg::Type::ARR, RPCArg::Optional::NO, "The base58-encoded private keys for signing",
+                        {
+                            {"privatekey", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "private key in base58-encoding"},
+                        },
+                        },
+                    {"prevtxs", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "The previous dependent transaction outputs",
+                        {
+                            {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "",
+                                {
+                                    {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id"},
+                                    {"vout", RPCArg::Type::NUM, RPCArg::Optional::NO, "The output number"},
+                                    {"scriptPubKey", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "output script"},
+                                    {"redeemScript", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "(required for P2SH) redeem script"},
+                                    {"witnessScript", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, "(required for P2WSH or P2SH-P2WSH) witness script"},
+                                    {"amount", RPCArg::Type::AMOUNT, RPCArg::Optional::OMITTED, "(required for Segwit inputs) the amount spent"},
+                                },
+                                },
+                        },
+                        },
+                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type. Must be one of:\n"
+            "       \"DEFAULT\"\n"
+            "       \"ALL\"\n"
+            "       \"NONE\"\n"
+            "       \"SINGLE\"\n"
+            "       \"ALL|ANYONECANPAY\"\n"
+            "       \"NONE|ANYONECANPAY\"\n"
+            "       \"SINGLE|ANYONECANPAY\"\n"
+                    },
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR_HEX, "hex", "The hex-encoded raw transaction with signature(s)"},
+                        {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                        {RPCResult::Type::ARR, "errors", /*optional=*/true, "Script verification errors (if there are any)",
+                        {
+                            {RPCResult::Type::OBJ, "", "",
+                            {
+                                {RPCResult::Type::STR_HEX, "txid", "The hash of the referenced, previous transaction"},
+                                {RPCResult::Type::NUM, "vout", "The index of the output to spent and used as input"},
+                                {RPCResult::Type::ARR, "witness", "",
+                                {
+                                    {RPCResult::Type::STR_HEX, "witness", ""},
+                                }},
+                                {RPCResult::Type::STR_HEX, "scriptSig", "The hex-encoded signature script"},
+                                {RPCResult::Type::NUM, "sequence", "Script sequence number"},
+                                {RPCResult::Type::STR, "error", "Verification or signing error related to the input"},
+                            }},
+                        }},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("signrawtransactionwithkey", "\"myhex\" \"[\\\"key1\\\",\\\"key2\\\"]\"")
+            + HelpExampleRpc("signrawtransactionwithkey", "\"myhex\", \"[\\\"key1\\\",\\\"key2\\\"]\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    CMutableTransaction mtx;
+    if (!DecodeHexTx(mtx, request.params[0].get_str())) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed. Make sure the tx has at least one input.");
+    }
+
+    FlatSigningProvider keystore;
+    const UniValue& keys = request.params[1].get_array();
+    for (unsigned int idx = 0; idx < keys.size(); ++idx) {
+        UniValue k = keys[idx];
+        CKey key = DecodeSecret(k.get_str());
+        if (!key.IsValid()) {
+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key");
+        }
+
+        CPubKey pubkey = key.GetPubKey();
+        CKeyID key_id = pubkey.GetID();
+        keystore.pubkeys.emplace(key_id, pubkey);
+        keystore.keys.emplace(key_id, key);
+    }
+
+    // Fetch previous transactions (inputs):
+    std::map<COutPoint, Coin> coins;
+    for (const CTxIn& txin : mtx.vin) {
+        coins[txin.prevout]; // Create empty map entry keyed by prevout.
+    }
+    NodeContext& node = EnsureAnyNodeContext(request.context);
+    FindCoins(node, coins);
+
+    // Parse the prevtxs array
+    ParsePrevouts(request.params[2], &keystore, coins);
+
+    UniValue result(UniValue::VOBJ);
+    SignTransaction(mtx, &keystore, coins, request.params[3], result);
+    return result;
+},
+    };
+}
+
+const RPCResult decodepsbt_inputs{
+    RPCResult::Type::ARR, "inputs", "",
+    {
+        {RPCResult::Type::OBJ, "", "",
+        {
+            {RPCResult::Type::OBJ, "non_witness_utxo", /*optional=*/true, "Decoded network transaction for non-witness UTXOs",
+            {
+                {RPCResult::Type::ELISION, "",""},
+            }},
+            {RPCResult::Type::OBJ, "witness_utxo", /*optional=*/true, "Transaction output for witness UTXOs",
+            {
+                {RPCResult::Type::NUM, "amount", "The value in " + CURRENCY_UNIT},
+                {RPCResult::Type::OBJ, "scriptPubKey", "",
+                {
+                    {RPCResult::Type::STR, "asm", "Disassembly of the output script"},
+                    {RPCResult::Type::STR, "desc", "Inferred descriptor for the output"},
+                    {RPCResult::Type::STR_HEX, "hex", "The raw output script bytes, hex-encoded"},
+                    {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
+                    {RPCResult::Type::STR, "address", /*optional=*/true, "The Bitcoin address (only if a well-defined address exists)"},
+                }},
+            }},
+            {RPCResult::Type::OBJ_DYN, "partial_signatures", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "pubkey", "The public key and signature that corresponds to it."},
+            }},
+            {RPCResult::Type::STR, "sighash", /*optional=*/true, "The sighash type to be used"},
+            {RPCResult::Type::OBJ, "redeem_script", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the redeem script"},
+                {RPCResult::Type::STR_HEX, "hex", "The raw redeem script bytes, hex-encoded"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
+            }},
+            {RPCResult::Type::OBJ, "witness_script", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the witness script"},
+                {RPCResult::Type::STR_HEX, "hex", "The raw witness script bytes, hex-encoded"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
+            }},
+            {RPCResult::Type::ARR, "bip32_derivs", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR, "pubkey", "The public key with the derivation path as the value."},
+                    {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                    {RPCResult::Type::STR, "path", "The path"},
+                }},
+            }},
+            {RPCResult::Type::OBJ, "final_scriptSig", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the final signature script"},
+                {RPCResult::Type::STR_HEX, "hex", "The raw final signature script bytes, hex-encoded"},
+            }},
+            {RPCResult::Type::ARR, "final_scriptwitness", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR_HEX, "", "hex-encoded witness data (if any)"},
+            }},
+            {RPCResult::Type::OBJ_DYN, "ripemd160_preimages", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::STR, "hash", "The hash and preimage that corresponds to it."},
+            }},
+            {RPCResult::Type::OBJ_DYN, "sha256_preimages", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::STR, "hash", "The hash and preimage that corresponds to it."},
+            }},
+            {RPCResult::Type::OBJ_DYN, "hash160_preimages", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::STR, "hash", "The hash and preimage that corresponds to it."},
+            }},
+            {RPCResult::Type::OBJ_DYN, "hash256_preimages", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::STR, "hash", "The hash and preimage that corresponds to it."},
+            }},
+            {RPCResult::Type::STR_HEX, "taproot_key_path_sig", /*optional=*/ true, "hex-encoded signature for the Taproot key path spend"},
+            {RPCResult::Type::ARR, "taproot_script_path_sigs", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::OBJ, "signature", /*optional=*/ true, "The signature for the pubkey and leaf hash combination",
+                {
+                    {RPCResult::Type::STR, "pubkey", "The x-only pubkey for this signature"},
+                    {RPCResult::Type::STR, "leaf_hash", "The leaf hash for this signature"},
+                    {RPCResult::Type::STR, "sig", "The signature itself"},
+                }},
+            }},
+            {RPCResult::Type::ARR, "taproot_scripts", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "script", "A leaf script"},
+                    {RPCResult::Type::NUM, "leaf_ver", "The version number for the leaf script"},
+                    {RPCResult::Type::ARR, "control_blocks", "The control blocks for this script",
+                    {
+                        {RPCResult::Type::STR_HEX, "control_block", "A hex-encoded control block for this script"},
+                    }},
+                }},
+            }},
+            {RPCResult::Type::ARR, "taproot_bip32_derivs", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR, "pubkey", "The x-only public key this path corresponds to"},
+                    {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                    {RPCResult::Type::STR, "path", "The path"},
+                    {RPCResult::Type::ARR, "leaf_hashes", "The hashes of the leaves this pubkey appears in",
+                    {
+                        {RPCResult::Type::STR_HEX, "hash", "The hash of a leaf this pubkey appears in"},
+                    }},
+                }},
+            }},
+            {RPCResult::Type::STR_HEX, "taproot_internal_key", /*optional=*/ true, "The hex-encoded Taproot x-only internal key"},
+            {RPCResult::Type::STR_HEX, "taproot_merkle_root", /*optional=*/ true, "The hex-encoded Taproot merkle root"},
+            {RPCResult::Type::ARR, "musig2_participant_pubkeys", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "aggregate_pubkey", "The compressed aggregate public key for which the participants create."},
+                    {RPCResult::Type::ARR, "participant_pubkeys", "",
+                    {
+                        {RPCResult::Type::STR_HEX, "pubkey", "The compressed public keys that are aggregated for aggregate_pubkey."},
+                    }},
+                }},
+            }},
+            {RPCResult::Type::ARR, "musig2_pubnonces", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "participant_pubkey", "The compressed public key of the participant that created this pubnonce."},
+                    {RPCResult::Type::STR_HEX, "aggregate_pubkey", "The compressed aggregate public key for which this pubnonce is for."},
+                    {RPCResult::Type::STR_HEX, "leaf_hash", /*optional=*/true, "The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key."},
+                    {RPCResult::Type::STR_HEX, "pubnonce", "The public nonce itself."},
+                }},
+            }},
+            {RPCResult::Type::ARR, "musig2_partial_sigs", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "participant_pubkey", "The compressed public key of the participant that created this partial signature."},
+                    {RPCResult::Type::STR_HEX, "aggregate_pubkey", "The compressed aggregate public key for which this partial signature is for."},
+                    {RPCResult::Type::STR_HEX, "leaf_hash", /*optional=*/true, "The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key."},
+                    {RPCResult::Type::STR_HEX, "partial_sig", "The partial signature itself."},
+                }},
+            }},
+            {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/ true, "The unknown input fields",
+            {
+                {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
+            }},
+            {RPCResult::Type::ARR, "proprietary", /*optional=*/true, "The input proprietary map",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "identifier", "The hex string for the proprietary identifier"},
+                    {RPCResult::Type::NUM, "subtype", "The number for the subtype"},
+                    {RPCResult::Type::STR_HEX, "key", "The hex for the key"},
+                    {RPCResult::Type::STR_HEX, "value", "The hex for the value"},
+                }},
+            }},
+        }},
+    }
+};
+
+const RPCResult decodepsbt_outputs{
+    RPCResult::Type::ARR, "outputs", "",
+    {
+        {RPCResult::Type::OBJ, "", "",
+        {
+            {RPCResult::Type::OBJ, "redeem_script", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the redeem script"},
+                {RPCResult::Type::STR_HEX, "hex", "The raw redeem script bytes, hex-encoded"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
+            }},
+            {RPCResult::Type::OBJ, "witness_script", /*optional=*/true, "",
+            {
+                {RPCResult::Type::STR, "asm", "Disassembly of the witness script"},
+                {RPCResult::Type::STR_HEX, "hex", "The raw witness script bytes, hex-encoded"},
+                {RPCResult::Type::STR, "type", "The type, eg 'pubkeyhash'"},
+            }},
+            {RPCResult::Type::ARR, "bip32_derivs", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR, "pubkey", "The public key this path corresponds to"},
+                    {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                    {RPCResult::Type::STR, "path", "The path"},
+                }},
+            }},
+            {RPCResult::Type::STR_HEX, "taproot_internal_key", /*optional=*/ true, "The hex-encoded Taproot x-only internal key"},
+            {RPCResult::Type::ARR, "taproot_tree", /*optional=*/ true, "The tuples that make up the Taproot tree, in depth first search order",
+            {
+                {RPCResult::Type::OBJ, "tuple", /*optional=*/ true, "A single leaf script in the taproot tree",
+                {
+                    {RPCResult::Type::NUM, "depth", "The depth of this element in the tree"},
+                    {RPCResult::Type::NUM, "leaf_ver", "The version of this leaf"},
+                    {RPCResult::Type::STR, "script", "The hex-encoded script itself"},
+                }},
+            }},
+            {RPCResult::Type::ARR, "taproot_bip32_derivs", /*optional=*/ true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR, "pubkey", "The x-only public key this path corresponds to"},
+                    {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                    {RPCResult::Type::STR, "path", "The path"},
+                    {RPCResult::Type::ARR, "leaf_hashes", "The hashes of the leaves this pubkey appears in",
+                    {
+                        {RPCResult::Type::STR_HEX, "hash", "The hash of a leaf this pubkey appears in"},
+                    }},
+                }},
+            }},
+            {RPCResult::Type::ARR, "musig2_participant_pubkeys", /*optional=*/true, "",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "aggregate_pubkey", "The compressed aggregate public key for which the participants create."},
+                    {RPCResult::Type::ARR, "participant_pubkeys", "",
+                    {
+                        {RPCResult::Type::STR_HEX, "pubkey", "The compressed public keys that are aggregated for aggregate_pubkey."},
+                    }},
+                }},
+            }},
+            {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/true, "The unknown output fields",
+            {
+                {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
+            }},
+            {RPCResult::Type::ARR, "proprietary", /*optional=*/true, "The output proprietary map",
+            {
+                {RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::STR_HEX, "identifier", "The hex string for the proprietary identifier"},
+                    {RPCResult::Type::NUM, "subtype", "The number for the subtype"},
+                    {RPCResult::Type::STR_HEX, "key", "The hex for the key"},
+                    {RPCResult::Type::STR_HEX, "value", "The hex for the value"},
+                }},
+            }},
+        }},
+    }
+};
+
+static RPCHelpMan decodepsbt()
+{
+    return RPCHelpMan{
+        "decodepsbt",
+        "Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.",
+                {
+                    {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "The PSBT base64 string"},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::OBJ, "tx", "The decoded network-serialized unsigned transaction.",
+                        {
+                            {RPCResult::Type::ELISION, "", "The layout is the same as the output of decoderawtransaction."},
+                        }},
+                        {RPCResult::Type::ARR, "global_xpubs", "",
+                        {
+                            {RPCResult::Type::OBJ, "", "",
+                            {
+                                {RPCResult::Type::STR, "xpub", "The extended public key this path corresponds to"},
+                                {RPCResult::Type::STR_HEX, "master_fingerprint", "The fingerprint of the master key"},
+                                {RPCResult::Type::STR, "path", "The path"},
+                            }},
+                        }},
+                        {RPCResult::Type::NUM, "psbt_version", "The PSBT version number. Not to be confused with the unsigned transaction version"},
+                        {RPCResult::Type::ARR, "proprietary", "The global proprietary map",
+                        {
+                            {RPCResult::Type::OBJ, "", "",
+                            {
+                                {RPCResult::Type::STR_HEX, "identifier", "The hex string for the proprietary identifier"},
+                                {RPCResult::Type::NUM, "subtype", "The number for the subtype"},
+                                {RPCResult::Type::STR_HEX, "key", "The hex for the key"},
+                                {RPCResult::Type::STR_HEX, "value", "The hex for the value"},
+                            }},
+                        }},
+                        {RPCResult::Type::OBJ_DYN, "unknown", "The unknown global fields",
+                        {
+                             {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
+                        }},
+                        decodepsbt_inputs,
+                        decodepsbt_outputs,
+                        {RPCResult::Type::STR_AMOUNT, "fee", /*optional=*/true, "The transaction fee paid if all UTXOs slots in the PSBT have been filled."},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("decodepsbt", "\"psbt\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Unserialize the transactions
+    PartiallySignedTransaction psbtx;
+    std::string error;
+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+    }
+
+    UniValue result(UniValue::VOBJ);
+
+    // Add the decoded tx
+    UniValue tx_univ(UniValue::VOBJ);
+    TxToUniv(CTransaction(*psbtx.tx), /*block_hash=*/uint256(), /*entry=*/tx_univ, /*include_hex=*/false);
+    result.pushKV("tx", std::move(tx_univ));
+
+    // Add the global xpubs
+    UniValue global_xpubs(UniValue::VARR);
+    for (std::pair<KeyOriginInfo, std::set<CExtPubKey>> xpub_pair : psbtx.m_xpubs) {
+        for (auto& xpub : xpub_pair.second) {
+            std::vector<unsigned char> ser_xpub;
+            ser_xpub.assign(BIP32_EXTKEY_WITH_VERSION_SIZE, 0);
+            xpub.EncodeWithVersion(ser_xpub.data());
+
+            UniValue keypath(UniValue::VOBJ);
+            keypath.pushKV("xpub", EncodeBase58Check(ser_xpub));
+            keypath.pushKV("master_fingerprint", HexStr(std::span<unsigned char>(xpub_pair.first.fingerprint, xpub_pair.first.fingerprint + 4)));
+            keypath.pushKV("path", WriteHDKeypath(xpub_pair.first.path));
+            global_xpubs.push_back(std::move(keypath));
+        }
+    }
+    result.pushKV("global_xpubs", std::move(global_xpubs));
+
+    // PSBT version
+    result.pushKV("psbt_version", static_cast<uint64_t>(psbtx.GetVersion()));
+
+    // Proprietary
+    UniValue proprietary(UniValue::VARR);
+    for (const auto& entry : psbtx.m_proprietary) {
+        UniValue this_prop(UniValue::VOBJ);
+        this_prop.pushKV("identifier", HexStr(entry.identifier));
+        this_prop.pushKV("subtype", entry.subtype);
+        this_prop.pushKV("key", HexStr(entry.key));
+        this_prop.pushKV("value", HexStr(entry.value));
+        proprietary.push_back(std::move(this_prop));
+    }
+    result.pushKV("proprietary", std::move(proprietary));
+
+    // Unknown data
+    UniValue unknowns(UniValue::VOBJ);
+    for (auto entry : psbtx.unknown) {
+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));
+    }
+    result.pushKV("unknown", std::move(unknowns));
+
+    // inputs
+    CAmount total_in = 0;
+    bool have_all_utxos = true;
+    UniValue inputs(UniValue::VARR);
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
+        const PSBTInput& input = psbtx.inputs[i];
+        UniValue in(UniValue::VOBJ);
+        // UTXOs
+        bool have_a_utxo = false;
+        CTxOut txout;
+        if (!input.witness_utxo.IsNull()) {
+            txout = input.witness_utxo;
+
+            UniValue o(UniValue::VOBJ);
+            ScriptToUniv(txout.scriptPubKey, /*out=*/o, /*include_hex=*/true, /*include_address=*/true);
+
+            UniValue out(UniValue::VOBJ);
+            out.pushKV("amount", ValueFromAmount(txout.nValue));
+            out.pushKV("scriptPubKey", std::move(o));
+
+            in.pushKV("witness_utxo", std::move(out));
+
+            have_a_utxo = true;
+        }
+        if (input.non_witness_utxo) {
+            txout = input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n];
+
+            UniValue non_wit(UniValue::VOBJ);
+            TxToUniv(*input.non_witness_utxo, /*block_hash=*/uint256(), /*entry=*/non_wit, /*include_hex=*/false);
+            in.pushKV("non_witness_utxo", std::move(non_wit));
+
+            have_a_utxo = true;
+        }
+        if (have_a_utxo) {
+            if (MoneyRange(txout.nValue) && MoneyRange(total_in + txout.nValue)) {
+                total_in += txout.nValue;
+            } else {
+                // Hack to just not show fee later
+                have_all_utxos = false;
+            }
+        } else {
+            have_all_utxos = false;
+        }
+
+        // Partial sigs
+        if (!input.partial_sigs.empty()) {
+            UniValue partial_sigs(UniValue::VOBJ);
+            for (const auto& sig : input.partial_sigs) {
+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));
+            }
+            in.pushKV("partial_signatures", std::move(partial_sigs));
+        }
+
+        // Sighash
+        if (input.sighash_type != std::nullopt) {
+            in.pushKV("sighash", SighashToStr((unsigned char)*input.sighash_type));
+        }
+
+        // Redeem script and witness script
+        if (!input.redeem_script.empty()) {
+            UniValue r(UniValue::VOBJ);
+            ScriptToUniv(input.redeem_script, /*out=*/r);
+            in.pushKV("redeem_script", std::move(r));
+        }
+        if (!input.witness_script.empty()) {
+            UniValue r(UniValue::VOBJ);
+            ScriptToUniv(input.witness_script, /*out=*/r);
+            in.pushKV("witness_script", std::move(r));
+        }
+
+        // keypaths
+        if (!input.hd_keypaths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (auto entry : input.hd_keypaths) {
+                UniValue keypath(UniValue::VOBJ);
+                keypath.pushKV("pubkey", HexStr(entry.first));
+
+                keypath.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(entry.second.fingerprint)));
+                keypath.pushKV("path", WriteHDKeypath(entry.second.path));
+                keypaths.push_back(std::move(keypath));
+            }
+            in.pushKV("bip32_derivs", std::move(keypaths));
+        }
+
+        // Final scriptSig and scriptwitness
+        if (!input.final_script_sig.empty()) {
+            UniValue scriptsig(UniValue::VOBJ);
+            scriptsig.pushKV("asm", ScriptToAsmStr(input.final_script_sig, true));
+            scriptsig.pushKV("hex", HexStr(input.final_script_sig));
+            in.pushKV("final_scriptSig", std::move(scriptsig));
+        }
+        if (!input.final_script_witness.IsNull()) {
+            UniValue txinwitness(UniValue::VARR);
+            for (const auto& item : input.final_script_witness.stack) {
+                txinwitness.push_back(HexStr(item));
+            }
+            in.pushKV("final_scriptwitness", std::move(txinwitness));
+        }
+
+        // Ripemd160 hash preimages
+        if (!input.ripemd160_preimages.empty()) {
+            UniValue ripemd160_preimages(UniValue::VOBJ);
+            for (const auto& [hash, preimage] : input.ripemd160_preimages) {
+                ripemd160_preimages.pushKV(HexStr(hash), HexStr(preimage));
+            }
+            in.pushKV("ripemd160_preimages", std::move(ripemd160_preimages));
+        }
+
+        // Sha256 hash preimages
+        if (!input.sha256_preimages.empty()) {
+            UniValue sha256_preimages(UniValue::VOBJ);
+            for (const auto& [hash, preimage] : input.sha256_preimages) {
+                sha256_preimages.pushKV(HexStr(hash), HexStr(preimage));
+            }
+            in.pushKV("sha256_preimages", std::move(sha256_preimages));
+        }
+
+        // Hash160 hash preimages
+        if (!input.hash160_preimages.empty()) {
+            UniValue hash160_preimages(UniValue::VOBJ);
+            for (const auto& [hash, preimage] : input.hash160_preimages) {
+                hash160_preimages.pushKV(HexStr(hash), HexStr(preimage));
+            }
+            in.pushKV("hash160_preimages", std::move(hash160_preimages));
+        }
+
+        // Hash256 hash preimages
+        if (!input.hash256_preimages.empty()) {
+            UniValue hash256_preimages(UniValue::VOBJ);
+            for (const auto& [hash, preimage] : input.hash256_preimages) {
+                hash256_preimages.pushKV(HexStr(hash), HexStr(preimage));
+            }
+            in.pushKV("hash256_preimages", std::move(hash256_preimages));
+        }
+
+        // Taproot key path signature
+        if (!input.m_tap_key_sig.empty()) {
+            in.pushKV("taproot_key_path_sig", HexStr(input.m_tap_key_sig));
+        }
+
+        // Taproot script path signatures
+        if (!input.m_tap_script_sigs.empty()) {
+            UniValue script_sigs(UniValue::VARR);
+            for (const auto& [pubkey_leaf, sig] : input.m_tap_script_sigs) {
+                const auto& [xonly, leaf_hash] = pubkey_leaf;
+                UniValue sigobj(UniValue::VOBJ);
+                sigobj.pushKV("pubkey", HexStr(xonly));
+                sigobj.pushKV("leaf_hash", HexStr(leaf_hash));
+                sigobj.pushKV("sig", HexStr(sig));
+                script_sigs.push_back(std::move(sigobj));
+            }
+            in.pushKV("taproot_script_path_sigs", std::move(script_sigs));
+        }
+
+        // Taproot leaf scripts
+        if (!input.m_tap_scripts.empty()) {
+            UniValue tap_scripts(UniValue::VARR);
+            for (const auto& [leaf, control_blocks] : input.m_tap_scripts) {
+                const auto& [script, leaf_ver] = leaf;
+                UniValue script_info(UniValue::VOBJ);
+                script_info.pushKV("script", HexStr(script));
+                script_info.pushKV("leaf_ver", leaf_ver);
+                UniValue control_blocks_univ(UniValue::VARR);
+                for (const auto& control_block : control_blocks) {
+                    control_blocks_univ.push_back(HexStr(control_block));
+                }
+                script_info.pushKV("control_blocks", std::move(control_blocks_univ));
+                tap_scripts.push_back(std::move(script_info));
+            }
+            in.pushKV("taproot_scripts", std::move(tap_scripts));
+        }
+
+        // Taproot bip32 keypaths
+        if (!input.m_tap_bip32_paths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (const auto& [xonly, leaf_origin] : input.m_tap_bip32_paths) {
+                const auto& [leaf_hashes, origin] = leaf_origin;
+                UniValue path_obj(UniValue::VOBJ);
+                path_obj.pushKV("pubkey", HexStr(xonly));
+                path_obj.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(origin.fingerprint)));
+                path_obj.pushKV("path", WriteHDKeypath(origin.path));
+                UniValue leaf_hashes_arr(UniValue::VARR);
+                for (const auto& leaf_hash : leaf_hashes) {
+                    leaf_hashes_arr.push_back(HexStr(leaf_hash));
+                }
+                path_obj.pushKV("leaf_hashes", std::move(leaf_hashes_arr));
+                keypaths.push_back(std::move(path_obj));
+            }
+            in.pushKV("taproot_bip32_derivs", std::move(keypaths));
+        }
+
+        // Taproot internal key
+        if (!input.m_tap_internal_key.IsNull()) {
+            in.pushKV("taproot_internal_key", HexStr(input.m_tap_internal_key));
+        }
+
+        // Write taproot merkle root
+        if (!input.m_tap_merkle_root.IsNull()) {
+            in.pushKV("taproot_merkle_root", HexStr(input.m_tap_merkle_root));
+        }
+
+        // Write MuSig2 fields
+        if (!input.m_musig2_participants.empty()) {
+            UniValue musig_pubkeys(UniValue::VARR);
+            for (const auto& [agg, parts] : input.m_musig2_participants) {
+                UniValue musig_part(UniValue::VOBJ);
+                musig_part.pushKV("aggregate_pubkey", HexStr(agg));
+                UniValue part_pubkeys(UniValue::VARR);
+                for (const auto& pub : parts) {
+                    part_pubkeys.push_back(HexStr(pub));
+                }
+                musig_part.pushKV("participant_pubkeys", part_pubkeys);
+                musig_pubkeys.push_back(musig_part);
+            }
+            in.pushKV("musig2_participant_pubkeys", musig_pubkeys);
+        }
+        if (!input.m_musig2_pubnonces.empty()) {
+            UniValue musig_pubnonces(UniValue::VARR);
+            for (const auto& [agg_lh, part_pubnonce] : input.m_musig2_pubnonces) {
+                const auto& [agg, lh] = agg_lh;
+                for (const auto& [part, pubnonce] : part_pubnonce) {
+                    UniValue info(UniValue::VOBJ);
+                    info.pushKV("participant_pubkey", HexStr(part));
+                    info.pushKV("aggregate_pubkey", HexStr(agg));
+                    if (!lh.IsNull()) info.pushKV("leaf_hash", HexStr(lh));
+                    info.pushKV("pubnonce", HexStr(pubnonce));
+                    musig_pubnonces.push_back(info);
+                }
+            }
+            in.pushKV("musig2_pubnonces", musig_pubnonces);
+        }
+        if (!input.m_musig2_partial_sigs.empty()) {
+            UniValue musig_partial_sigs(UniValue::VARR);
+            for (const auto& [agg_lh, part_psig] : input.m_musig2_partial_sigs) {
+                const auto& [agg, lh] = agg_lh;
+                for (const auto& [part, psig] : part_psig) {
+                    UniValue info(UniValue::VOBJ);
+                    info.pushKV("participant_pubkey", HexStr(part));
+                    info.pushKV("aggregate_pubkey", HexStr(agg));
+                    if (!lh.IsNull()) info.pushKV("leaf_hash", HexStr(lh));
+                    info.pushKV("partial_sig", HexStr(psig));
+                    musig_partial_sigs.push_back(info);
+                }
+            }
+            in.pushKV("musig2_partial_sigs", musig_partial_sigs);
+        }
+
+        // Proprietary
+        if (!input.m_proprietary.empty()) {
+            UniValue proprietary(UniValue::VARR);
+            for (const auto& entry : input.m_proprietary) {
+                UniValue this_prop(UniValue::VOBJ);
+                this_prop.pushKV("identifier", HexStr(entry.identifier));
+                this_prop.pushKV("subtype", entry.subtype);
+                this_prop.pushKV("key", HexStr(entry.key));
+                this_prop.pushKV("value", HexStr(entry.value));
+                proprietary.push_back(std::move(this_prop));
+            }
+            in.pushKV("proprietary", std::move(proprietary));
+        }
+
+        // Unknown data
+        if (input.unknown.size() > 0) {
+            UniValue unknowns(UniValue::VOBJ);
+            for (auto entry : input.unknown) {
+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));
+            }
+            in.pushKV("unknown", std::move(unknowns));
+        }
+
+        inputs.push_back(std::move(in));
+    }
+    result.pushKV("inputs", std::move(inputs));
+
+    // outputs
+    CAmount output_value = 0;
+    UniValue outputs(UniValue::VARR);
+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {
+        const PSBTOutput& output = psbtx.outputs[i];
+        UniValue out(UniValue::VOBJ);
+        // Redeem script and witness script
+        if (!output.redeem_script.empty()) {
+            UniValue r(UniValue::VOBJ);
+            ScriptToUniv(output.redeem_script, /*out=*/r);
+            out.pushKV("redeem_script", std::move(r));
+        }
+        if (!output.witness_script.empty()) {
+            UniValue r(UniValue::VOBJ);
+            ScriptToUniv(output.witness_script, /*out=*/r);
+            out.pushKV("witness_script", std::move(r));
+        }
+
+        // keypaths
+        if (!output.hd_keypaths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (auto entry : output.hd_keypaths) {
+                UniValue keypath(UniValue::VOBJ);
+                keypath.pushKV("pubkey", HexStr(entry.first));
+                keypath.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(entry.second.fingerprint)));
+                keypath.pushKV("path", WriteHDKeypath(entry.second.path));
+                keypaths.push_back(std::move(keypath));
+            }
+            out.pushKV("bip32_derivs", std::move(keypaths));
+        }
+
+        // Taproot internal key
+        if (!output.m_tap_internal_key.IsNull()) {
+            out.pushKV("taproot_internal_key", HexStr(output.m_tap_internal_key));
+        }
+
+        // Taproot tree
+        if (!output.m_tap_tree.empty()) {
+            UniValue tree(UniValue::VARR);
+            for (const auto& [depth, leaf_ver, script] : output.m_tap_tree) {
+                UniValue elem(UniValue::VOBJ);
+                elem.pushKV("depth", (int)depth);
+                elem.pushKV("leaf_ver", (int)leaf_ver);
+                elem.pushKV("script", HexStr(script));
+                tree.push_back(std::move(elem));
+            }
+            out.pushKV("taproot_tree", std::move(tree));
+        }
+
+        // Taproot bip32 keypaths
+        if (!output.m_tap_bip32_paths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (const auto& [xonly, leaf_origin] : output.m_tap_bip32_paths) {
+                const auto& [leaf_hashes, origin] = leaf_origin;
+                UniValue path_obj(UniValue::VOBJ);
+                path_obj.pushKV("pubkey", HexStr(xonly));
+                path_obj.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(origin.fingerprint)));
+                path_obj.pushKV("path", WriteHDKeypath(origin.path));
+                UniValue leaf_hashes_arr(UniValue::VARR);
+                for (const auto& leaf_hash : leaf_hashes) {
+                    leaf_hashes_arr.push_back(HexStr(leaf_hash));
+                }
+                path_obj.pushKV("leaf_hashes", std::move(leaf_hashes_arr));
+                keypaths.push_back(std::move(path_obj));
+            }
+            out.pushKV("taproot_bip32_derivs", std::move(keypaths));
+        }
+
+        // Write MuSig2 fields
+        if (!output.m_musig2_participants.empty()) {
+            UniValue musig_pubkeys(UniValue::VARR);
+            for (const auto& [agg, parts] : output.m_musig2_participants) {
+                UniValue musig_part(UniValue::VOBJ);
+                musig_part.pushKV("aggregate_pubkey", HexStr(agg));
+                UniValue part_pubkeys(UniValue::VARR);
+                for (const auto& pub : parts) {
+                    part_pubkeys.push_back(HexStr(pub));
+                }
+                musig_part.pushKV("participant_pubkeys", part_pubkeys);
+                musig_pubkeys.push_back(musig_part);
+            }
+            out.pushKV("musig2_participant_pubkeys", musig_pubkeys);
+        }
+
+        // Proprietary
+        if (!output.m_proprietary.empty()) {
+            UniValue proprietary(UniValue::VARR);
+            for (const auto& entry : output.m_proprietary) {
+                UniValue this_prop(UniValue::VOBJ);
+                this_prop.pushKV("identifier", HexStr(entry.identifier));
+                this_prop.pushKV("subtype", entry.subtype);
+                this_prop.pushKV("key", HexStr(entry.key));
+                this_prop.pushKV("value", HexStr(entry.value));
+                proprietary.push_back(std::move(this_prop));
+            }
+            out.pushKV("proprietary", std::move(proprietary));
+        }
+
+        // Unknown data
+        if (output.unknown.size() > 0) {
+            UniValue unknowns(UniValue::VOBJ);
+            for (auto entry : output.unknown) {
+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));
+            }
+            out.pushKV("unknown", std::move(unknowns));
+        }
+
+        outputs.push_back(std::move(out));
+
+        // Fee calculation
+        if (MoneyRange(psbtx.tx->vout[i].nValue) && MoneyRange(output_value + psbtx.tx->vout[i].nValue)) {
+            output_value += psbtx.tx->vout[i].nValue;
+        } else {
+            // Hack to just not show fee later
+            have_all_utxos = false;
+        }
+    }
+    result.pushKV("outputs", std::move(outputs));
+    if (have_all_utxos) {
+        result.pushKV("fee", ValueFromAmount(total_in - output_value));
+    }
+
+    return result;
+},
+    };
+}
+
+static RPCHelpMan combinepsbt()
+{
+    return RPCHelpMan{
+        "combinepsbt",
+        "Combine multiple partially signed Bitcoin transactions into one transaction.\n"
+                "Implements the Combiner role.\n",
+                {
+                    {"txs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The base64 strings of partially signed transactions",
+                        {
+                            {"psbt", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "A base64 string of a PSBT"},
+                        },
+                        },
+                },
+                RPCResult{
+                    RPCResult::Type::STR, "", "The base64-encoded partially signed transaction"
+                },
+                RPCExamples{
+                    HelpExampleCli("combinepsbt", R"('["mybase64_1", "mybase64_2", "mybase64_3"]')")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Unserialize the transactions
+    std::vector<PartiallySignedTransaction> psbtxs;
+    UniValue txs = request.params[0].get_array();
+    if (txs.empty()) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Parameter 'txs' cannot be empty");
+    }
+    for (unsigned int i = 0; i < txs.size(); ++i) {
+        PartiallySignedTransaction psbtx;
+        std::string error;
+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {
+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+        }
+        psbtxs.push_back(psbtx);
+    }
+
+    PartiallySignedTransaction merged_psbt;
+    if (!CombinePSBTs(merged_psbt, psbtxs)) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "PSBTs not compatible (different transactions)");
+    }
+
+    DataStream ssTx{};
+    ssTx << merged_psbt;
+    return EncodeBase64(ssTx);
+},
+    };
+}
+
+static RPCHelpMan finalizepsbt()
+{
+    return RPCHelpMan{"finalizepsbt",
+                "Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\n"
+                "network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\n"
+                "created which has the final_scriptSig and final_scriptwitness fields filled for inputs that are complete.\n"
+                "Implements the Finalizer and Extractor roles.\n",
+                {
+                    {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "A base64 string of a PSBT"},
+                    {"extract", RPCArg::Type::BOOL, RPCArg::Default{true}, "If true and the transaction is complete,\n"
+            "                             extract and return the complete transaction in normal network serialization instead of the PSBT."},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR, "psbt", /*optional=*/true, "The base64-encoded partially signed transaction if not extracted"},
+                        {RPCResult::Type::STR_HEX, "hex", /*optional=*/true, "The hex-encoded network transaction if extracted"},
+                        {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("finalizepsbt", "\"psbt\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Unserialize the transactions
+    PartiallySignedTransaction psbtx;
+    std::string error;
+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+    }
+
+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());
+
+    CMutableTransaction mtx;
+    bool complete = FinalizeAndExtractPSBT(psbtx, mtx);
+
+    UniValue result(UniValue::VOBJ);
+    DataStream ssTx{};
+    std::string result_str;
+
+    if (complete && extract) {
+        ssTx << TX_WITH_WITNESS(mtx);
+        result_str = HexStr(ssTx);
+        result.pushKV("hex", result_str);
+    } else {
+        ssTx << psbtx;
+        result_str = EncodeBase64(ssTx.str());
+        result.pushKV("psbt", result_str);
+    }
+    result.pushKV("complete", complete);
+
+    return result;
+},
+    };
+}
+
+static RPCHelpMan createpsbt()
+{
+    return RPCHelpMan{
+        "createpsbt",
+        "Creates a transaction in the Partially Signed Transaction format.\n"
+                "Implements the Creator role.\n"
+                "Note that the transaction's inputs are not signed, and\n"
+                "it is not stored in the wallet or transmitted to the network.\n",
+                CreateTxDoc(),
+                RPCResult{
+                    RPCResult::Type::STR, "", "The resulting raw transaction (base64-encoded string)"
+                },
+                RPCExamples{
+                    HelpExampleCli("createpsbt", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"address\\\":0.01}]\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+
+    std::optional<bool> rbf;
+    if (!request.params[3].isNull()) {
+        rbf = request.params[3].get_bool();
+    }
+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf, self.Arg<uint32_t>("version"));
+
+    // Make a blank psbt
+    PartiallySignedTransaction psbtx;
+    psbtx.tx = rawTx;
+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {
+        psbtx.inputs.emplace_back();
+    }
+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {
+        psbtx.outputs.emplace_back();
+    }
+
+    // Serialize the PSBT
+    DataStream ssTx{};
+    ssTx << psbtx;
+
+    return EncodeBase64(ssTx);
+},
+    };
+}
+
+static RPCHelpMan converttopsbt()
+{
+    return RPCHelpMan{
+        "converttopsbt",
+        "Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\n"
+                "createpsbt and walletcreatefundedpsbt should be used for new applications.\n",
+                {
+                    {"hexstring", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The hex string of a raw transaction"},
+                    {"permitsigdata", RPCArg::Type::BOOL, RPCArg::Default{false}, "If true, any signatures in the input will be discarded and conversion\n"
+                            "                              will continue. If false, RPC will fail if any signatures are present."},
+                    {"iswitness", RPCArg::Type::BOOL, RPCArg::DefaultHint{"depends on heuristic tests"}, "Whether the transaction hex is a serialized witness transaction.\n"
+                        "If iswitness is not present, heuristic tests will be used in decoding.\n"
+                        "If true, only witness deserialization will be tried.\n"
+                        "If false, only non-witness deserialization will be tried.\n"
+                        "This boolean should reflect whether the transaction has inputs\n"
+                        "(e.g. fully valid, or on-chain transactions), if known by the caller."
+                    },
+                },
+                RPCResult{
+                    RPCResult::Type::STR, "", "The resulting raw transaction (base64-encoded string)"
+                },
+                RPCExamples{
+                            "\nCreate a transaction\n"
+                            + HelpExampleCli("createrawtransaction", "\"[{\\\"txid\\\":\\\"myid\\\",\\\"vout\\\":0}]\" \"[{\\\"data\\\":\\\"00010203\\\"}]\"") +
+                            "\nConvert the transaction to a PSBT\n"
+                            + HelpExampleCli("converttopsbt", "\"rawtransaction\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // parse hex string from parameter
+    CMutableTransaction tx;
+    bool permitsigdata = request.params[1].isNull() ? false : request.params[1].get_bool();
+    bool witness_specified = !request.params[2].isNull();
+    bool iswitness = witness_specified ? request.params[2].get_bool() : false;
+    const bool try_witness = witness_specified ? iswitness : true;
+    const bool try_no_witness = witness_specified ? !iswitness : true;
+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "TX decode failed");
+    }
+
+    // Remove all scriptSigs and scriptWitnesses from inputs
+    for (CTxIn& input : tx.vin) {
+        if ((!input.scriptSig.empty() || !input.scriptWitness.IsNull()) && !permitsigdata) {
+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Inputs must not have scriptSigs and scriptWitnesses");
+        }
+        input.scriptSig.clear();
+        input.scriptWitness.SetNull();
+    }
+
+    // Make a blank psbt
+    PartiallySignedTransaction psbtx;
+    psbtx.tx = tx;
+    for (unsigned int i = 0; i < tx.vin.size(); ++i) {
+        psbtx.inputs.emplace_back();
+    }
+    for (unsigned int i = 0; i < tx.vout.size(); ++i) {
+        psbtx.outputs.emplace_back();
+    }
+
+    // Serialize the PSBT
+    DataStream ssTx{};
+    ssTx << psbtx;
+
+    return EncodeBase64(ssTx);
+},
+    };
+}
+
+static RPCHelpMan utxoupdatepsbt()
+{
+    return RPCHelpMan{
+        "utxoupdatepsbt",
+        "Updates all segwit inputs and outputs in a PSBT with data from output descriptors, the UTXO set, txindex, or the mempool.\n",
+            {
+                {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "A base64 string of a PSBT"},
+                {"descriptors", RPCArg::Type::ARR, RPCArg::Optional::OMITTED, "An array of either strings or objects", {
+                    {"", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "An output descriptor"},
+                    {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "An object with an output descriptor and extra information", {
+                         {"desc", RPCArg::Type::STR, RPCArg::Optional::NO, "An output descriptor"},
+                         {"range", RPCArg::Type::RANGE, RPCArg::Default{1000}, "Up to what index HD chains should be explored (either end or [begin,end])"},
+                    }},
+                }},
+            },
+            RPCResult {
+                    RPCResult::Type::STR, "", "The base64-encoded partially signed transaction with inputs updated"
+            },
+            RPCExamples {
+                HelpExampleCli("utxoupdatepsbt", "\"psbt\"")
+            },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Parse descriptors, if any.
+    FlatSigningProvider provider;
+    if (!request.params[1].isNull()) {
+        auto descs = request.params[1].get_array();
+        for (size_t i = 0; i < descs.size(); ++i) {
+            EvalDescriptorStringOrObject(descs[i], provider);
+        }
+    }
+
+    // We don't actually need private keys further on; hide them as a precaution.
+    const PartiallySignedTransaction& psbtx = ProcessPSBT(
+        request.params[0].get_str(),
+        request.context,
+        HidingSigningProvider(&provider, /*hide_secret=*/true, /*hide_origin=*/false),
+        /*sighash_type=*/std::nullopt,
+        /*finalize=*/false);
+
+    DataStream ssTx{};
+    ssTx << psbtx;
+    return EncodeBase64(ssTx);
+},
+    };
+}
+
+static RPCHelpMan joinpsbts()
+{
+    return RPCHelpMan{
+        "joinpsbts",
+        "Joins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs\n"
+            "No input in any of the PSBTs can be in more than one of the PSBTs.\n",
+            {
+                {"txs", RPCArg::Type::ARR, RPCArg::Optional::NO, "The base64 strings of partially signed transactions",
+                    {
+                        {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "A base64 string of a PSBT"}
+                    }}
+            },
+            RPCResult {
+                    RPCResult::Type::STR, "", "The base64-encoded partially signed transaction"
+            },
+            RPCExamples {
+                HelpExampleCli("joinpsbts", "\"psbt\"")
+            },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Unserialize the transactions
+    std::vector<PartiallySignedTransaction> psbtxs;
+    UniValue txs = request.params[0].get_array();
+
+    if (txs.size() <= 1) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "At least two PSBTs are required to join PSBTs.");
+    }
+
+    uint32_t best_version = 1;
+    uint32_t best_locktime = 0xffffffff;
+    for (unsigned int i = 0; i < txs.size(); ++i) {
+        PartiallySignedTransaction psbtx;
+        std::string error;
+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {
+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+        }
+        psbtxs.push_back(psbtx);
+        // Choose the highest version number
+        if (psbtx.tx->version > best_version) {
+            best_version = psbtx.tx->version;
+        }
+        // Choose the lowest lock time
+        if (psbtx.tx->nLockTime < best_locktime) {
+            best_locktime = psbtx.tx->nLockTime;
+        }
+    }
+
+    // Create a blank psbt where everything will be added
+    PartiallySignedTransaction merged_psbt;
+    merged_psbt.tx = CMutableTransaction();
+    merged_psbt.tx->version = best_version;
+    merged_psbt.tx->nLockTime = best_locktime;
+
+    // Merge
+    for (auto& psbt : psbtxs) {
+        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {
+            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input %s:%d exists in multiple PSBTs", psbt.tx->vin[i].prevout.hash.ToString(), psbt.tx->vin[i].prevout.n));
+            }
+        }
+        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {
+            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);
+        }
+        for (auto& xpub_pair : psbt.m_xpubs) {
+            if (merged_psbt.m_xpubs.count(xpub_pair.first) == 0) {
+                merged_psbt.m_xpubs[xpub_pair.first] = xpub_pair.second;
+            } else {
+                merged_psbt.m_xpubs[xpub_pair.first].insert(xpub_pair.second.begin(), xpub_pair.second.end());
+            }
+        }
+        merged_psbt.unknown.insert(psbt.unknown.begin(), psbt.unknown.end());
+    }
+
+    // Generate list of shuffled indices for shuffling inputs and outputs of the merged PSBT
+    std::vector<int> input_indices(merged_psbt.inputs.size());
+    std::iota(input_indices.begin(), input_indices.end(), 0);
+    std::vector<int> output_indices(merged_psbt.outputs.size());
+    std::iota(output_indices.begin(), output_indices.end(), 0);
+
+    // Shuffle input and output indices lists
+    std::shuffle(input_indices.begin(), input_indices.end(), FastRandomContext());
+    std::shuffle(output_indices.begin(), output_indices.end(), FastRandomContext());
+
+    PartiallySignedTransaction shuffled_psbt;
+    shuffled_psbt.tx = CMutableTransaction();
+    shuffled_psbt.tx->version = merged_psbt.tx->version;
+    shuffled_psbt.tx->nLockTime = merged_psbt.tx->nLockTime;
+    for (int i : input_indices) {
+        shuffled_psbt.AddInput(merged_psbt.tx->vin[i], merged_psbt.inputs[i]);
+    }
+    for (int i : output_indices) {
+        shuffled_psbt.AddOutput(merged_psbt.tx->vout[i], merged_psbt.outputs[i]);
+    }
+    shuffled_psbt.unknown.insert(merged_psbt.unknown.begin(), merged_psbt.unknown.end());
+
+    DataStream ssTx{};
+    ssTx << shuffled_psbt;
+    return EncodeBase64(ssTx);
+},
+    };
+}
+
+static RPCHelpMan analyzepsbt()
+{
+    return RPCHelpMan{
+        "analyzepsbt",
+        "Analyzes and provides information about the current status of a PSBT and its inputs\n",
+            {
+                {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "A base64 string of a PSBT"}
+            },
+            RPCResult {
+                RPCResult::Type::OBJ, "", "",
+                {
+                    {RPCResult::Type::ARR, "inputs", /*optional=*/true, "",
+                    {
+                        {RPCResult::Type::OBJ, "", "",
+                        {
+                            {RPCResult::Type::BOOL, "has_utxo", "Whether a UTXO is provided"},
+                            {RPCResult::Type::BOOL, "is_final", "Whether the input is finalized"},
+                            {RPCResult::Type::OBJ, "missing", /*optional=*/true, "Things that are missing that are required to complete this input",
+                            {
+                                {RPCResult::Type::ARR, "pubkeys", /*optional=*/true, "",
+                                {
+                                    {RPCResult::Type::STR_HEX, "keyid", "Public key ID, hash160 of the public key, of a public key whose BIP 32 derivation path is missing"},
+                                }},
+                                {RPCResult::Type::ARR, "signatures", /*optional=*/true, "",
+                                {
+                                    {RPCResult::Type::STR_HEX, "keyid", "Public key ID, hash160 of the public key, of a public key whose signature is missing"},
+                                }},
+                                {RPCResult::Type::STR_HEX, "redeemscript", /*optional=*/true, "Hash160 of the redeem script that is missing"},
+                                {RPCResult::Type::STR_HEX, "witnessscript", /*optional=*/true, "SHA256 of the witness script that is missing"},
+                            }},
+                            {RPCResult::Type::STR, "next", /*optional=*/true, "Role of the next person that this input needs to go to"},
+                        }},
+                    }},
+                    {RPCResult::Type::NUM, "estimated_vsize", /*optional=*/true, "Estimated vsize of the final signed transaction"},
+                    {RPCResult::Type::STR_AMOUNT, "estimated_feerate", /*optional=*/true, "Estimated feerate of the final signed transaction in " + CURRENCY_UNIT + "/kvB. Shown only if all UTXO slots in the PSBT have been filled"},
+                    {RPCResult::Type::STR_AMOUNT, "fee", /*optional=*/true, "The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled"},
+                    {RPCResult::Type::STR, "next", "Role of the next person that this psbt needs to go to"},
+                    {RPCResult::Type::STR, "error", /*optional=*/true, "Error message (if there is one)"},
+                }
+            },
+            RPCExamples {
+                HelpExampleCli("analyzepsbt", "\"psbt\"")
+            },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Unserialize the transaction
+    PartiallySignedTransaction psbtx;
+    std::string error;
+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {
+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
+    }
+
+    PSBTAnalysis psbta = AnalyzePSBT(psbtx);
+
+    UniValue result(UniValue::VOBJ);
+    UniValue inputs_result(UniValue::VARR);
+    for (const auto& input : psbta.inputs) {
+        UniValue input_univ(UniValue::VOBJ);
+        UniValue missing(UniValue::VOBJ);
+
+        input_univ.pushKV("has_utxo", input.has_utxo);
+        input_univ.pushKV("is_final", input.is_final);
+        input_univ.pushKV("next", PSBTRoleName(input.next));
+
+        if (!input.missing_pubkeys.empty()) {
+            UniValue missing_pubkeys_univ(UniValue::VARR);
+            for (const CKeyID& pubkey : input.missing_pubkeys) {
+                missing_pubkeys_univ.push_back(HexStr(pubkey));
+            }
+            missing.pushKV("pubkeys", std::move(missing_pubkeys_univ));
+        }
+        if (!input.missing_redeem_script.IsNull()) {
+            missing.pushKV("redeemscript", HexStr(input.missing_redeem_script));
+        }
+        if (!input.missing_witness_script.IsNull()) {
+            missing.pushKV("witnessscript", HexStr(input.missing_witness_script));
+        }
+        if (!input.missing_sigs.empty()) {
+            UniValue missing_sigs_univ(UniValue::VARR);
+            for (const CKeyID& pubkey : input.missing_sigs) {
+                missing_sigs_univ.push_back(HexStr(pubkey));
+            }
+            missing.pushKV("signatures", std::move(missing_sigs_univ));
+        }
+        if (!missing.getKeys().empty()) {
+            input_univ.pushKV("missing", std::move(missing));
+        }
+        inputs_result.push_back(std::move(input_univ));
+    }
+    if (!inputs_result.empty()) result.pushKV("inputs", std::move(inputs_result));
+
+    if (psbta.estimated_vsize != std::nullopt) {
+        result.pushKV("estimated_vsize", (int)*psbta.estimated_vsize);
+    }
+    if (psbta.estimated_feerate != std::nullopt) {
+        result.pushKV("estimated_feerate", ValueFromAmount(psbta.estimated_feerate->GetFeePerK()));
+    }
+    if (psbta.fee != std::nullopt) {
+        result.pushKV("fee", ValueFromAmount(*psbta.fee));
+    }
+    result.pushKV("next", PSBTRoleName(psbta.next));
+    if (!psbta.error.empty()) {
+        result.pushKV("error", psbta.error);
+    }
+
+    return result;
+},
+    };
+}
+
+RPCHelpMan descriptorprocesspsbt()
+{
+    return RPCHelpMan{
+        "descriptorprocesspsbt",
+        "Update all segwit inputs in a PSBT with information from output descriptors, the UTXO set or the mempool. \n"
+                "Then, sign the inputs we are able to with information from the output descriptors. ",
+                {
+                    {"psbt", RPCArg::Type::STR, RPCArg::Optional::NO, "The transaction base64 string"},
+                    {"descriptors", RPCArg::Type::ARR, RPCArg::Optional::NO, "An array of either strings or objects", {
+                        {"", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "An output descriptor"},
+                        {"", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, "An object with an output descriptor and extra information", {
+                             {"desc", RPCArg::Type::STR, RPCArg::Optional::NO, "An output descriptor"},
+                             {"range", RPCArg::Type::RANGE, RPCArg::Default{1000}, "Up to what index HD chains should be explored (either end or [begin,end])"},
+                        }},
+                    }},
+                    {"sighashtype", RPCArg::Type::STR, RPCArg::Default{"DEFAULT for Taproot, ALL otherwise"}, "The signature hash type to sign with if not specified by the PSBT. Must be one of\n"
+            "       \"DEFAULT\"\n"
+            "       \"ALL\"\n"
+            "       \"NONE\"\n"
+            "       \"SINGLE\"\n"
+            "       \"ALL|ANYONECANPAY\"\n"
+            "       \"NONE|ANYONECANPAY\"\n"
+            "       \"SINGLE|ANYONECANPAY\""},
+                    {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"finalize", RPCArg::Type::BOOL, RPCArg::Default{true}, "Also finalize inputs if possible"},
+                },
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::STR, "psbt", "The base64-encoded partially signed transaction"},
+                        {RPCResult::Type::BOOL, "complete", "If the transaction has a complete set of signatures"},
+                        {RPCResult::Type::STR_HEX, "hex", /*optional=*/true, "The hex-encoded network transaction if complete"},
+                    }
+                },
+                RPCExamples{
+                    HelpExampleCli("descriptorprocesspsbt", "\"psbt\" \"[\\\"descriptor1\\\", \\\"descriptor2\\\"]\"") +
+                    HelpExampleCli("descriptorprocesspsbt", "\"psbt\" \"[{\\\"desc\\\":\\\"mydescriptor\\\", \\\"range\\\":21}]\"")
+                },
+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
+{
+    // Add descriptor information to a signing provider
+    FlatSigningProvider provider;
+
+    auto descs = request.params[1].get_array();
+    for (size_t i = 0; i < descs.size(); ++i) {
+        EvalDescriptorStringOrObject(descs[i], provider, /*expand_priv=*/true);
+    }
+
+    std::optional<int> sighash_type = ParseSighashString(request.params[2]);
+    bool bip32derivs = request.params[3].isNull() ? true : request.params[3].get_bool();
+    bool finalize = request.params[4].isNull() ? true : request.params[4].get_bool();
+
+    const PartiallySignedTransaction& psbtx = ProcessPSBT(
+        request.params[0].get_str(),
+        request.context,
+        HidingSigningProvider(&provider, /*hide_secret=*/false, !bip32derivs),
+        sighash_type,
+        finalize);
+
+    // Check whether or not all of the inputs are now signed
+    bool complete = true;
+    for (const auto& input : psbtx.inputs) {
+        complete &= PSBTInputSigned(input);
+    }
+
+    DataStream ssTx{};
+    ssTx << psbtx;
+
+    UniValue result(UniValue::VOBJ);
+
+    result.pushKV("psbt", EncodeBase64(ssTx));
+    result.pushKV("complete", complete);
+    if (complete) {
+        CMutableTransaction mtx;
+        PartiallySignedTransaction psbtx_copy = psbtx;
+        CHECK_NONFATAL(FinalizeAndExtractPSBT(psbtx_copy, mtx));
+        DataStream ssTx_final;
+        ssTx_final << TX_WITH_WITNESS(mtx);
+        result.pushKV("hex", HexStr(ssTx_final));
+    }
+    return result;
+},
+    };
+}
+
+void RegisterRawTransactionRPCCommands(CRPCTable& t)
+{
+    static const CRPCCommand commands[]{
+        {"rawtransactions", &getrawtransaction},
+        {"rawtransactions", &createrawtransaction},
+        {"rawtransactions", &decoderawtransaction},
+        {"rawtransactions", &createsegoptx},  //segOP
+        {"rawtransactions", &decodescript},
+        {"rawtransactions", &combinerawtransaction},
+        {"rawtransactions", &signrawtransactionwithkey},
+        {"rawtransactions", &decodepsbt},
+        {"rawtransactions", &combinepsbt},
+        {"rawtransactions", &finalizepsbt},
+        {"rawtransactions", &createpsbt},
+        {"rawtransactions", &converttopsbt},
+        {"rawtransactions", &utxoupdatepsbt},
+        {"rawtransactions", &descriptorprocesspsbt},
+        {"rawtransactions", &joinpsbts},
+        {"rawtransactions", &analyzepsbt},
+    };
+    for (const auto& c : commands) {
+        t.appendCommand(c.name, &c);
+    }
+}
diff --git a/src_v1/src/segop/CMakeLists.txt b/src_v1/src/segop/CMakeLists.txt
new file mode 100644
index 0000000000..25c26fd8f0
--- /dev/null
+++ b/src_v1/src/segop/CMakeLists.txt
@@ -0,0 +1,8 @@
+# SegOP module
+add_library(segop STATIC segop.cpp)
+
+# Ensure it’s compiled as C++
+set_target_properties(segop PROPERTIES LINKER_LANGUAGE CXX)
+
+# Make headers visible to the rest of the project
+target_include_directories(segop PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)
diff --git a/src_v1/src/segop/segop.cpp b/src_v1/src/segop/segop.cpp
new file mode 100644
index 0000000000..48d7a7ac54
--- /dev/null
+++ b/src_v1/src/segop/segop.cpp
@@ -0,0 +1,3 @@
+#include <segop/segop.h>
+
+// Stub translation unit so CMake can compile segop library
diff --git a/src_v1/src/segop/segop.h b/src_v1/src/segop/segop.h
new file mode 100644
index 0000000000..6cdc939727
--- /dev/null
+++ b/src_v1/src/segop/segop.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2025 segOP Authors
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef BITCOIN_SEGOP_SEGOP_H
+#define BITCOIN_SEGOP_SEGOP_H
+
+#include <serialize.h>
+
+#include <cstdint>
+#include <cstddef>
+#include <vector>
+
+/**
+ * SegOP payload carried in the extended transaction serialization.
+ *
+ * Wire layout of the SegOP section (when enabled by the tx flag):
+ *
+ *   [ segop_marker (1) = 0x53 ]       // ASCII 'S'  (handled in tx serialization)
+ *   [ segop_flag   (1) = version ]    // segOP version / feature bits
+ *   [ segop_len    (varint) ]         // length of payload
+ *   [ segop_payload (segop_len bytes) ]
+ *
+ * This struct models everything *after* the marker:
+ *   - `version`  → segop_flag
+ *   - `data`     → segop_payload bytes (TLV, Merkle root, etc.)
+ */
+struct CSegopPayload
+{
+    // segOP v1 version byte.
+    static constexpr uint8_t SEGOP_VERSION_1 = 0x01;
+
+    // Hard cap from the spec: maximum segOP payload size in bytes.
+    // Enforced as a consensus rule in tx_check.
+    static constexpr std::size_t MAX_SEGOP_PAYLOAD_SIZE = 100'000;
+
+    uint8_t version;
+    std::vector<unsigned char> data;
+
+    CSegopPayload() { SetNull(); }
+
+    void SetNull()
+    {
+        version = 0;
+        data.clear();
+    }
+
+    bool IsNull() const
+    {
+        return version == 0 && data.empty();
+    }
+
+    // Convenience helper used by consensus checks.
+    bool TooLarge() const
+    {
+        return data.size() > MAX_SEGOP_PAYLOAD_SIZE;
+    }
+
+    SERIALIZE_METHODS(CSegopPayload, obj)
+    {
+        // NOTE:
+        //  - The 0x53 marker byte is *not* handled here; it is emitted/checked
+        //    by the transaction serializer when the segOP flag bit is set.
+        //  - std::vector<unsigned char> uses CompactSize/varint length encoding
+        //    automatically, so this matches: [segop_len][segop_payload bytes].
+        READWRITE(obj.version);
+        READWRITE(obj.data);
+    }
+};
+
+#endif // BITCOIN_SEGOP_SEGOP_H
